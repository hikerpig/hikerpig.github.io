<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="hikerpig,hikerpigwinnie@gmail.com"><title> · HP goes FE</title><meta name="description" content="{&quot;compress&quot;:true,&quot;commitItems&quot;:[[&quot;8f67408f-1df5-4e8e-9214-230d70fa9122&quot;,1531113042353,&quot;---\nlayout: post\ntitle: \&quot;Vuex 模块动态注册的一些实践经验\&quot;\ndescription: "><meta name="keywords" content="Front-End,Programming,Hexo"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/avatar.jpeg" class="sidebar__avatar"><h3 title=""><a href="/">HP goes FE</a></h3><div class="description"><p>Note for everything</p></div></div></div><ul class="social-links"><li><a href="http://github.com/https://github.com/hikerpig"><i class="fa fa-github"></i></a></li></ul><div class="sidebar-nav animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><a onclick="window.history.go(-1)" class="fa fa-chevron-left"></a></div></div></div><div class="footer"><a target="_blank" href="/"><span>Theme by  </span></a><a href="https://github/hikerpig">Hikerpig </a><span>forked from </span><a href="https://github.com/Ben02/hexo-theme-Anatole">Anatole</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo</a></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h1><a></a></h1></div><div class="post-content">{"compress":true,"commitItems":[["8f67408f-1df5-4e8e-9214-230d70fa9122",1531113042353,"---\nlayout: post\ntitle: \"Vuex 模块动态注册的一些实践经验\"\ndescription: \"\"\ncategory: 前端\nuse_toc: True\ntags:\n- Vue\n\nmemos:\n\n- 几个时间点\n\n- 1. 服务器端 asyncData 获取数据\n- 2. 浏览器端首次进入页面，获得预取数据\n- 3. 浏览器端 SPA，从其他页面进入\n- 4. 浏览器端 SPA，再一次进入此页面，例如 '/storage/1 -\\> /home -\\> /storage/2'\n\n- 可能问题\n\n- 1. 服务器/客户端 在尚未注册 Module 时，调用其下的 action/mutation ，Vuex 因找不到对应函数而出错\n- 2. 客户端没有用上服务器端预取的数据\n- 3. 客户端在时机3情况下，没有正确清除\n\n---\n\n# 前言\n\n构建大型 SPA 应用时，代码分割和懒加载是比较常用的优化手段，在 Vue 生态下，使用 vue-router 很容易实现组件的懒加载。\n\n但应用里除了组件，还有庞大的业务逻辑，这部分如何分割和懒加载比较合适呢？\n\n使用 Vuex 管理状态的话，其提供了方法 `registerModule` 用于[动态注册][1] Module。\n\n因此某个页面独有的业务逻辑和状态管理，在初始化全局 store 的时候可以不用引入，之后在该页面路由组件中再引入和注册 Vuex 模块。\n\n# 简单的示例\n\n```javascript\nconst PageA = () => import('./views/PageA.js')\n\nconst router = new VueRouter({\n  routes: [\n    { path: '/page-a', component: PageA }\n  ]\n})\n```\n\n简单的 Vuex 模块：\n\n```javascript\n// store/modules/page-a.js\nexport const VUEX_NS = 'page-a'\n\nexport default {\n  namespaced: true,\n  state() {\n    return {\n      inventory: {\n        list: []\n      }\n    }\n  },\n  getters: {\n    inventoryList(state) {\n      return state.inventory.list\n    }\n  }\n}\n```\n\n\n实践时遭遇了几个问题：\n\n## 问题 1：服务器/客户端 在尚未注册 Module 时，调用其下的 action/mutation ，Vuex 因找不到对应函数而出错\n\n\n```javascript\n// views/PageA.js\n\nimport PAGE_A_MODULE, { VUEX_NS } from 'store/modules/page-a'\n\nexport default {\n  name: 'PageA',\n  beforeCreate() {\n    this.$store.registerModule(VUEX_NS, PAGE_A_MODULE)\n    return this.$store.dispatch(`${VUEX_NS}/fetchInventory`)\n  },\n}\n```\n\n### 考虑服务器端预取数据注入给客户端的时候\n\n```js\n// entry-client.js\nstore.replaceState(window.__INITIAL_STATE__)\n```\n\n此处的 `__INITIAL_STATE__` 是 Vue SSR 提供的一个功能，使得浏览器端可以复用服务器端已经预取过的数据。\n\n```js\n// 在所有预取钩子(preFetch hook) resolve 后，\n// 我们的 store 现在已经填充入渲染应用程序所需的状态。\n// 当我们将状态附加到上下文，\n// 并且 `template` 选项用于 renderer 时，\n// 状态将自动序列化为 `window.__INITIAL_STATE__`，并注入 HTML。\ncontext.state = store.state\n```\n\n此处的 `asyncData` 与 [Vue SSR 文档中的例子][2]类似，与 Nuxt.js 中的同名函数用法略有不同。\n\n`prepareVuex` 为自定义的组件钩子函数，会先于 asyncData 调用，具体过程之后探讨。\n\n```diff\n export default {\n   name: 'PageA',\n-  beforeCreate() {\n-    this.$store.registerModule(VUEX_NS, PAGE_A_MODULE)\n-    return this.$store.dispatch(`${VUEX_NS}/fetchInventory`)\n+  prepareVuex({ store }) {\n+    store.registerModule(VUEX_NS, PAGE_A_MODULE)\n+  },\n+  asyncData({ store }) {\n+    return store.dispatch(`${VUEX_NS}/fetchInventory`)\n   },\n }\n```\n\n此时会遇见\n\n## 问题2: 客户端没有用上服务器端预取的数据\n\n解决方式：\n\n```diff\n export default {\n   name: 'PageA',\n-  prepareVuex({ store }) {\n-    store.registerModule(VUEX_NS, PAGE_A_MODULE)\n+  prepareVuex({ store, isClientInitialRoute }) {\n+    store.registerModule(VUEX_NS, PAGE_A_MODULE, { preserveState: isClientInitialRoute })\n   },\n   asyncData({ store }) {\n     return store.dispatch(`${VUEX_NS}/fetchInventory`)\n   },\n+  beforeDestroy() {\n+    // 销毁该模块\n+    this.$store.unregisterModule(VUEX_NS)\n+  }\n }\n\n```\n\n注册 Vuex 模块的时候使用了 `preserveState` ，若启用此选项，注册 Module 时若 `store.state[namespace]` 下已存在数据，便不会使用声明 vuex 模块时的初始 state 覆盖已有数据。但需要注意，若 state 中没有 namespace 相应数据却开启了此选项，Vuex 还是会报错。因此此处添加了一个输入参数 `isClientInitialRoute` ， 只有在客户端初次进入页面（可以使用服务器预取数据）时才开启 `preserveState` 选项。\n\n## 问题3: 组件热更新时，Vuex 模块被销毁\n\n开发期间使用 HotModuleReplacementPlugin 和 vue-loader，若改变了 PageA.js 中的代码，会触发热更新。在 [vue-hot-reload-api][3] 中，当使用 vue-hot-reload-api 的 `reload` 方法处理组件实例时，该实例会被销毁而后重新创建。`beforeDestroy` 中销毁了 Vuex 的 `page-a` 模块，却没有调用 `prepareVuex` 方法重新注册，因此热更新之后，使用该模块也会报错。\n\n解决方案：\n\n```diff\n   asyncData({ store }) {\n     return store.dispatch(`${VUEX_NS}/fetchInventory`)\n   },\n-  beforeDestroy() {\n-    // 销毁该模块\n-    this.$store.unregisterModule(VUEX_NS)\n+  beforeRouteLeave(to, from, next) {\n+    this.$once('hook:beforeDestroy', () => {\n+      // 销毁该模块\n+      this.$store.unregisterModule(VUEX_NS)\n+    })\n+    next()\n   }\n }\n```\n\n仔细想想，注册模块的时机是与路由相关的（进入页面之前），那么销毁的时机也可以与路由相关。不过并不适合在 `beforeRouteLeave` 钩子中立刻销毁模块。因为根据以下 vue-router 文档内容，在此钩子被调用完成时，整个页面还是在正常工作的（第2步到第11步中间），仍未进入组件的 destroy 过程，此时销毁模块会导致依赖其的所有组件异常。\n\n> <cite>[vue-router 文档中关于导航解析流程的部分](https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%AF%BC%E8%88%AA%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B)</cite>\n>\n> 1. 导航被触发。\n> 1. 在失活的组件里调用离开守卫。\n> 1. 调用全局的 beforeEach 守卫。\n> 1. 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。\n> 1. 在路由配置里调用 beforeEnter。\n> 1. 解析异步路由组件。\n> 1. 在被激活的组件里调用 beforeRouteEnter。\n> 1. 调用全局的 beforeResolve 守卫 (2.5+)。\n> 1. 导航被确认。\n> 1. 调用全局的 afterEach 钩子。\n> 1. 触发 DOM 更新。\n> 1. 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。\n\n因此安全的模块销毁时机需要在 DOM 更新中或后，旧的页面组件实例销毁过程调用时。\n\n# 相关代码\n\n最后的 PageA.js：\n\n```js\nimport PAGE_A_MODULE, { VUEX_NS } from 'store/modules/page-a'\n\nexport default {\n  name: 'PageA',\n  prepareVuex({ store, isClientInitialRoute }) {\n    store.registerModule(VUEX_NS, PAGE_A_MODULE, { preserveState: isClientInitialRoute })\n  },\n  asyncData({ store }) {\n    return store.dispatch(`${VUEX_NS}/fetchInventory`)\n  },\n  beforeRouteLeave(to, from, next) {\n    this.$once('hook:beforeDestroy', () => {\n      // 销毁该模块\n      this.$store.unregisterModule(VUEX_NS)\n    })\n    next()\n  }\n}\n```\n\n两端的入口文件中相关代码如下：\n\n```typescript\n// router-util.ts\n\nimport Vue, { VueConstructor } from 'vue'\n\ntype VueCtor = VueConstructor<any>\n\nexport function getHookFromComponent(compo: any, name: string) {\n  return compo[name] || (compo.options && compo.options[name])\n}\n\nexport function callComponentsHookWith(compoList: VueCtor[], hookName: string, context: any) {\n  return compoList.map((component) => {\n    const hook = getHookFromComponent(component, hookName)\n    if (hook) {\n      return hook(context)\n    }\n  }).filter(_ => _)\n}\n```\n\n```js\n// entry-server.js\n\nexport default context => {\n  return new Promise((resolve, reject) => {\n    // set router's location\n    router.push(context.url)\n\n    router.onReady(() => {\n      const matchedComponents = router.getMatchedComponents()\n\n      try {\n        // 加上 try/catch 避免此 block 内抛出的错误造成 promise unhandledRejection\n        callComponentsHookWith(matchedComponents, 'prepareVuex', { store })\n\n        const asyncDataResults = callComponentsHookWith(matchedComponents, 'asyncData',\n          {\n            store,\n            route: router.currentRoute,\n          }\n        )\n        Promise.all(asyncDataResults).then(() => {\n          context.state = store.state\n          resolve(app)\n        }).catch(reject)\n\n      } catch(err) {\n        reject(err)\n      }\n    }, reject)\n  })\n}\n```\n\n\n```js\n// entry-client.js\n\nrouter.onReady((initialRoute) => {\n  const initialMatched = router.getMatchedComponents(initialRoute)\n  callComponentsHookWith(initialMatched, 'prepareVuex', { store, isClientInitialRoute: true })\n\n  router.beforeResolve((to, from, next) => {\n    const matched = router.getMatchedComponents(to)\n\n    callComponentsHookWith(matched, 'prepareVuex', { store })\n\n    Promise.all(callComponentsHookWith(activated, 'asyncData', { store, route: to }))\n      .then(next)\n      .catch(next)\n  })\n\n  // actually mount to DOM\n  app.$mount('#app')\n})\n```\n\n[1]:\thttps://vuex.vuejs.org/guide/modules.html#dynamic-module-registration\n[2]:\thttps://ssr.vuejs.org/zh/guide/data.html#%E6%95%B0%E6%8D%AE%E9%A2%84%E5%8F%96%E5%AD%98%E5%82%A8%E5%AE%B9%E5%99%A8-data-store\n[3]:\thttps://github.com/vuejs/vue-hot-reload-api/blob/master/src/index.js",[[1531112987770,["hikerpig@localhost",[[-1,2986,"Client"],[1,2992,"\n"]],[2986,2992],[2987,2987]]],[1531112988205,["hikerpig@localhost",[[1,2987,"\n"]],[2987,2987],[2988,2988]]],[1531112990784,["hikerpig@localhost",[[-1,2987,"\n"]],[2988,2988],[2987,2987]]],[1531112991022,["hikerpig@localhost",[[1,2986,"Client"],[-1,2986,"\n"]],[2987,2987],[2986,2992]]],[1531112999685,["hikerpig@localhost",[[1,1477,"\n"]],[1476,1476],[1477,1477]]],[1531112999842,["hikerpig@localhost",[[1,1478,"\n"]],[1477,1477],[1478,1478]]],[1531113000245,["hikerpig@localhost",[[1,1477,"d"]],[1477,1477],[1478,1478]]],[1531113000403,["hikerpig@localhost",[[-1,1477,"d"]],[1478,1478],[1477,1477]]],[1531113003925,["hikerpig@localhost",[[1,1477,"客户端"]],[1477,1477],[1480,1480]]],[1531113018689,["hikerpig@localhost",[[1,1477,"在"]],[1477,1477],[1478,1478]]],[1531113019403,["hikerpig@localhost",[[-1,1477,"在"]],[1478,1478],[1477,1477]]],[1531113019523,["hikerpig@localhost",[[-1,1476,"\n"]],[1477,1477],[1476,1476]]],[1531113022444,["hikerpig@localhost",[[1,1476,"\n"]],[1476,1476],[1477,1477]]],[1531113027691,["hikerpig@localhost",[[1,1479,"（）"]],[1479,1479],[1481,1481]]],[1531113029529,["hikerpig@localhost",[[1,1480,"浏览器"]],[1480,1480],[1483,1483]]],[1531113036290,["hikerpig@localhost",[[1,1485,"初始华代码"]],[1485,1485],[1490,1490]]],[1531113037564,["hikerpig@localhost",[[-1,1487,"华"]],[1488,1488],[1487,1487]]],[1531113039690,["hikerpig@localhost",[[1,1487,"化"]],[1487,1487],[1488,1488]]],[1531113056766,["hikerpig@localhost",[[1,1490,"，在初始化 router 之前："]],[1490,1490],[1506,1506]]],[1531113067048,["hikerpig@localhost",[[1,1505,","]],[1505,1505],[1506,1506]]],[1531113067923,["hikerpig@localhost",[[-1,1505,","]],[1506,1506],[1505,1505]]],[1531113074329,["hikerpig@localhost",[[1,1505,"，给 Vuex store 注入数据"]],[1505,1505],[1523,1523]]],[1531113078808,["hikerpig@localhost",[[1,1513,"全局 "]],[1513,1513],[1516,1516]]]],null,"hikerpig@localhost"]]}</any></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-07-09</span><i class="fa fa-tag"></i></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://hikerpig.github.io/2018/07/09/2018-07-03-Vuex-Dynamic-Module-Hints.resource/commit/,HP goes FE,,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a role="navigation" href="/2018/07/07/2018-05-03-Try-Rust-Webassemly/" title="Try Rust WebAssembly" class="btn">下一篇</a></li></ul></div><div id="comments"><div id="gitalk-container"></div></div><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
  clientID: '0b21579fda2f1d2e73f4',
  clientSecret: 'abc0351a314cc46bb3d58b6dad62c670c2d1e8f9',
  repo: 'hikerpig.github.io',
  owner: 'hikerpig',
  admin: 'hikerpig',
  labels: ['Gitalk'],
  id: '2018/07/09/2018-07-03-Vuex-Dynamic-Module-Hints.resource/commit/',
  title: '',
  // facebook-like distraction free mode
  distractionFreeMode: false
})

gitalk.render('gitalk-container')
</script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>