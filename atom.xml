<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HP goes FE</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hikerpig.github.io/"/>
  <updated>2019-05-21T16:00:17.339Z</updated>
  <id>http://hikerpig.github.io/</id>
  
  <author>
    <name>Hikerpig</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图像近似高斯模糊的快速实现，以及 WebAssembly 模块的导出</title>
    <link href="http://hikerpig.github.io/2019/05/13/2019-05-13-Fastblur-implemetation-with-rust/"/>
    <id>http://hikerpig.github.io/2019/05/13/2019-05-13-Fastblur-implemetation-with-rust/</id>
    <published>2019-05-12T16:00:00.000Z</published>
    <updated>2019-05-21T16:00:17.339Z</updated>
    
    <content type="html"><![CDATA[<p>在图像处理软件中的模糊滤镜一般都会有<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A?oldformat=true" target="_blank" rel="noopener">高斯模糊（Gaussian Blur）</a>，因为它效果最好，接近人眼的模糊效果（也许是由于正态分布的无处不在？）。但对图像做真正的高斯模糊（在我的理解，也即使用满足二阶正态分布的卷积核对二维离散分布的空间域做平滑处理），由于卷积的定义，计算量颇大。可以采用一些快速的算法去模拟这个效果。</p><h1 id="使用盒模糊模拟高斯模糊">使用盒模糊模拟高斯模糊</h1><p>根据<a href="http://blog.ivank.net/fastest-gaussian-blur.html" target="_blank" rel="noopener">这个 JS 实现</a> 和 <a href="http://www.peterkovesi.com/papers/FastGaussianSmoothing.pdf" target="_blank" rel="noopener">论文 《Fast Almost-Gaussian Filtering》</a>中的论证，通过对图像进行多次盒模糊操作，来模拟高斯模糊的效果。设盒模糊次数为 n，当 n = 5 时，模拟效果已足够好。</p><h2 id="盒滤波-box-filter">盒滤波 Box filter</h2><p>卷积核的每一点权重都是一样的，所以也称作平均滤波（Averaging filter）。一个边长为 3 的二维盒滤波的卷积核如下</p><p><br><span class="math display">$$\left[ \begin{array}{lll}{1} &amp; {1} &amp; {1} \\ {1} &amp; {1} &amp; {1} \\ {1} &amp; {1} &amp; {1}\end{array}\right]$$</span><br></p><p>由于权重相同，使用盒滤波对图像进行模糊处理时有一个可爱的特性能使得计算变得更加快速：对图像在水平方向进行一次一维平均滤波，再在垂直方向进行一次，等价于对整个图片做一次二维盒滤波。</p><h2 id="论文的大概操作思路">论文的大概操作思路</h2><p>对于平均分布的图像，经过 n 次平均滤波，标准差如下，其中 <span class="math inline"><em>w</em></span> 为滤波器宽度。</p><p><br><span class="math display">$$\sigma_{n a v}=\sqrt{\frac{n w^{2}-n}{12}}$$</span><br></p><p>那么理想的滤波器宽度 <span class="math inline"><em>w</em><sub><em>i</em><em>d</em><em>e</em><em>a</em><em>l</em></sub></span> 求法：</p><p><br><span class="math display">$$w_{i d e a l}=\sqrt{\frac{12 \sigma^{2}}{n}+1}$$</span><br></p><p>对于图像滤波来说，w 需要是整数，且最好是奇数，如此一来总会有一个中心点的像素值可以被指定。于是在理想宽度附近找到两个奇数，<span class="math inline"><em>w</em><sub><em>l</em></sub> &lt; <em>w</em><sub><em>i</em><em>d</em><em>e</em><em>a</em><em>l</em></sub> &lt; <em>w</em><sub><em>u</em></sub></span>，分别为下限(l)和上限(u)，显然 <span class="math inline"><em>w</em><sub><em>l</em></sub> + 2 = <em>w</em><sub><em>u</em></sub></span>。接下来要进行 n 次平均滤波，设 c 为当前滤波的轮数，从 1 开始，在 <span class="math inline">0 &lt; <em>c</em> &lt;  = <em>m</em></span>时，滤波器宽度为 <span class="math inline"><em>w</em><sub><em>l</em></sub></span>，在 <span class="math inline"><em>m</em> &lt; <em>c</em> &lt;  = <em>n</em></span> 时，滤波器宽度为 <span class="math inline"><em>w</em><sub><em>u</em></sub></span>。</p><p><br><span class="math display">$$\begin{aligned} \sigma &amp;=\sqrt{\frac{m w_{l}^{2}+(n-m) w_{u}^{2}-n}{12}} \\ &amp;=\sqrt{\frac{m w_{l}^{2}+(n-m)\left(w_{l}+2\right)^{2}-n}{12}} \end{aligned}$$</span><br></p><p>因此算出 m:</p><p><br><span class="math display">$$m=\frac{12 \sigma^{2}-n w_{l}^{2}-4 n w_{l}-3 n}{-4 w_{l}-4}$$</span><br></p><h1 id="开发和使用-webassembly">开发和使用 WebAssembly</h1><p>我们基于 github 上用 rust 写的一个实现，继续填充一些细节，完成了<a href="https://github.com/bestminr/fastblur" target="_blank" rel="noopener">fastblur</a>这个模块。</p><p>考虑到中间涉及大量运算，使用 WebAssembly 应该比纯 js 更快点。使用 rust 和 <a href="https://crates.io/crates/image" target="_blank" rel="noopener">image crate</a> 使得算法验证和调试输出能快速进行，同时 rust 有着目前编译到 WebAssembly 最佳的工具链<a href="https://github.com/rustwasm/wasm-pack" target="_blank" rel="noopener">wasm-pack</a>（毕竟这俩都是 Mozilla 在积极推行的标准）。</p><h2 id="在-typescript-webpack-项目中引入和使用">在 Typescript + Webpack 项目中引入和使用</h2><p>确保 <code>tsconfig.json</code> 中的 <code>compilerOptions.module: esnext</code>，才能方便地使用 <code>import().then()</code>。</p><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">applyFastBlur</span>(<span class="hljs-params">imageData: ImageData, blurRadius: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">Bluebird</span>&lt;<span class="hljs-title">ImageData</span>&gt; </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-keyword">import</span>(<span class="hljs-string">'@bestminr/fastblur'</span>)      .then(<span class="hljs-function">(<span class="hljs-params">m</span>) =&gt;</span> &#123;        <span class="hljs-keyword">const</span> &#123; width, height &#125; = imageData        <span class="hljs-keyword">const</span> inputDataArr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(imageData.data)        m.do_fast_blur(inputDataArr, width, height, blurRadius)        <span class="hljs-keyword">const</span> outputImageData = <span class="hljs-keyword">new</span> ImageData(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8ClampedArray</span>(inputDataArr), width, height)        <span class="hljs-keyword">return</span> resolve(outputImageData)      &#125;).catch(reject)  &#125;)&#125;</code></pre><h2 id="参考">参考</h2><ul><li><a href="http://blog.ivank.net/fastest-gaussian-blur.html" target="_blank" rel="noopener">Fastest Gaussian Blur (in linear time)</a></li><li>http://elynxsdk.free.fr/ext-docs/Blur/Fast_box_blur.pdf</li><li><a href="http://www.peterkovesi.com/papers/FastGaussianSmoothing.pdf" target="_blank" rel="noopener">FastGaussianSmoothing 论文</a></li><li>https://stackoverflow.com/questions/1696113/how-do-i-gaussian-blur-an-image-without-using-any-in-built-gaussian-functions</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在图像处理软件中的模糊滤镜一般都会有&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A?oldformat=true&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
      <category term="图像处理" scheme="http://hikerpig.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="WebAssembly" scheme="http://hikerpig.github.io/tags/WebAssembly/"/>
    
      <category term="Rust" scheme="http://hikerpig.github.io/tags/Rust/"/>
    
      <category term="图像处理" scheme="http://hikerpig.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>使用 d8 快速测试 WebAssembly 模块性能</title>
    <link href="http://hikerpig.github.io/2019/05/05/2019-05-05-Benchmark-WASM-with-d8/"/>
    <id>http://hikerpig.github.io/2019/05/05/2019-05-05-Benchmark-WASM-with-d8/</id>
    <published>2019-05-04T16:00:00.000Z</published>
    <updated>2019-05-07T03:09:36.652Z</updated>
    
    <content type="html"><![CDATA[<p>d8 是 v8 的简易 CLI，它提供了一个极简的 JS 宿主环境，可用于 v8 的学习和调试，比起 nodejs，它更精简和专注。</p><p>除了 JS 以外，d8 也具有 WASM 的解释功能，可以方便地用于测试 WASM 模块的性能。如果你的 WASM 是要在浏览器里运行的，比起 wasmtime，v8（以及 spidermonkey 等主流浏览器 JS 引擎）显然是个更合适的命令行测试方案。</p><h2 id="安装-v8">安装 v8</h2><h3 id="使用包管理器">使用包管理器</h3><pre><code class="hljs undefined">brew install v8</code></pre><h3 id="使用-jsvu">使用 jsvu</h3><p><a href="https://github.com/GoogleChromeLabs/jsvu" target="_blank" rel="noopener">jsvu</a> 是 GoogleChromeLabs 出品的一个工具, 可以快速安装多个主流 JS 引擎(spidermonkey/v8/chakra/javascriptcore)。不过用它安装的 CLI 名字是 <code>v8</code>。</p><h2 id="使用例子">使用例子</h2><p>不同于 nodejs 的模块系统和库函数，d8 提供给脚本的全局函数很克制。<a href="https://v8.dev/docs/d8" target="_blank" rel="noopener">简易的文档</a>说明了几个，如直接使用 <code>load()</code> 加载和执行外部脚本至当前上下文，或是使用 <code>read()</code> 读取文件内容。</p><p>除了看文档外，还可以去查看 <a href="https://chromium.googlesource.com/v8/v8/+/master/src/d8.cc" target="_blank" rel="noopener">d8.cc 源码</a> 获知 d8 script 支持的全部全局方法。</p><p>可使用 <code>readbuffer()</code> 方法获取 WASM 二进制内容。</p><p>假如用 rust 编译出了一个 <code>rotate.wasm</code> 模块 ，导出了一个简单方法 <code>rotate_90</code>，用于将图片旋转 90 度。</p><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">rotate_90</span></span>(width: <span class="hljs-built_in">usize</span>, height: <span class="hljs-built_in">usize</span>, image_data_ptr: *<span class="hljs-keyword">mut</span> <span class="hljs-built_in">u8</span>)</code></pre><p>简单的测试脚本 <code>benchmark.js</code> 如下:</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> iterTimes = <span class="hljs-number">10</span>;<span class="hljs-keyword">const</span> imageDimensions = <span class="hljs-number">4096</span>;<span class="hljs-keyword">const</span> iterations = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(iterTimes);<span class="hljs-keyword">const</span> imageByteSize = imageDimensions * imageDimensions * <span class="hljs-number">4</span>;<span class="hljs-keyword">const</span> wasmPageSize = <span class="hljs-number">64</span> * <span class="hljs-number">1024</span>;<span class="hljs-keyword">const</span> buffer = readbuffer(<span class="hljs-string">"rotate.wasm"</span>);<span class="hljs-keyword">const</span> &#123; instance &#125; = <span class="hljs-keyword">await</span> WebAssembly.instantiate(buffer);<span class="hljs-keyword">const</span> pagesAvailable = <span class="hljs-built_in">Math</span>.floor(instance.exports.memory.buffer.byteLength / wasmPageSize);<span class="hljs-keyword">const</span> pagesNeeded = <span class="hljs-built_in">Math</span>.floor((imageByteSize * <span class="hljs-number">2</span> + <span class="hljs-number">4</span>) / wasmPageSize) + <span class="hljs-number">1</span>;<span class="hljs-keyword">const</span> additionalPagesNeeded = pagesNeeded - pagesAvailable;<span class="hljs-keyword">if</span> (additionalPagesNeeded &gt; <span class="hljs-number">0</span>) &#123;instance.exports.memory.grow(additionalPagesNeeded);&#125;<span class="hljs-keyword">const</span> imageData = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>(imageByteSize)print(<span class="hljs-string">`==============================`</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; iterTimes; i++) &#123;  <span class="hljs-keyword">const</span> view = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8ClampedArray</span>(instance.exports.memory.buffer);  <span class="hljs-keyword">const</span> dataPtr = <span class="hljs-number">8</span>;  view.set(imageData.data, dataPtr);  <span class="hljs-keyword">const</span> start = <span class="hljs-built_in">Date</span>.now();  instance.exports.rotate_90(imageDimensions, imageDimensions, dataPtr);  iterations[i] = <span class="hljs-built_in">Date</span>.now() - start;&#125;<span class="hljs-keyword">const</span> average = iterations.reduce(<span class="hljs-function">(<span class="hljs-params">sum, c</span>) =&gt;</span> sum + c) / iterations.length;<span class="hljs-keyword">const</span> stddev = <span class="hljs-built_in">Math</span>.sqrt(  iterations    .map(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> <span class="hljs-built_in">Math</span>.pow(i - average, <span class="hljs-number">2</span>))    .reduce(<span class="hljs-function">(<span class="hljs-params">sum, c</span>) =&gt;</span> sum + c) / iterations.length);print(<span class="hljs-string">`n = <span class="hljs-subst">$&#123;iterations.length&#125;</span>`</span>);print(<span class="hljs-string">`Average: <span class="hljs-subst">$&#123;average&#125;</span>`</span>);print(<span class="hljs-string">`StdDev: <span class="hljs-subst">$&#123;stddev&#125;</span>`</span>);</code></pre><p>使用 d8 运行脚本：</p><pre><code class="hljs bash">d8 benchmark.js</code></pre><p>结果打印出平均时间和方差：</p><pre><code class="hljs undefined">==============================n = 10Average: 45.8StdDev: 19.75246820020222</code></pre><h2 id="参考">参考</h2><p>Squoosh 项目的 <a href="https://github.com/GoogleChromeLabs/squoosh/blob/master/codecs/rotate/rotate.rs" target="_blank" rel="noopener">codecs/rotate</a> 模块。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;d8 是 v8 的简易 CLI，它提供了一个极简的 JS 宿主环境，可用于 v8 的学习和调试，比起 nodejs，它更精简和专注。&lt;/p&gt;
&lt;p&gt;除了 JS 以外，d8 也具有 WASM 的解释功能，可以方便地用于测试 WASM 模块的性能。如果你的 WASM 是要在浏览
      
    
    </summary>
    
      <category term="前端" scheme="http://hikerpig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="WebAssembly" scheme="http://hikerpig.github.io/tags/WebAssembly/"/>
    
      <category term="Benchmark" scheme="http://hikerpig.github.io/tags/Benchmark/"/>
    
      <category term="V8" scheme="http://hikerpig.github.io/tags/V8/"/>
    
  </entry>
  
  <entry>
    <title>Handy Video Analyze Tool</title>
    <link href="http://hikerpig.github.io/2019/03/14/2019-03-13-Handy-Video-Analyze-Tool/"/>
    <id>http://hikerpig.github.io/2019/03/14/2019-03-13-Handy-Video-Analyze-Tool/</id>
    <published>2019-03-13T16:00:00.000Z</published>
    <updated>2019-05-25T05:34:27.181Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写一些跟视频解码相关的简单程序，学习 avcodec 技术时有一些强大的分析工具，分享一下。</p><h1 id="码流与封装容器相关">码流与封装容器相关</h1><h2 id="iso-viewer">ISO Viewer</h2><p><a href="https://github.com/sannies/isoviewer" target="_blank" rel="noopener">isoviewer</a> 是 Mac 下一个检查 mp4 文件构成的 GUI 程序，能直观地看到各个 box 的数据。</p><img src="//images-hikerpig.oss-cn-beijing.aliyuncs.com/image/iso-viewer.png" alt="undefined" title="undefined"><h2 id="bento4">bento4</h2><p><a href="https://www.bento4.com/" target="_blank" rel="noopener">bento4</a> 是一套专用于 mp4 格式文件分析和编辑的 SDK，支持的功能非常多。</p><table><colgroup><col style="width: 11%"><col style="width: 88%"></colgroup><thead><tr class="header"><th>工具</th><th>用途</th></tr></thead><tbody><tr class="odd"><td>mp4info</td><td>displays high level info about an MP4 file, including all tracks and codec details</td></tr><tr class="even"><td>mp4dump</td><td>displays the entire atom/box structure of an MP4 file</td></tr><tr class="odd"><td>mp4edit</td><td>add/insert/remove/replace atom/box items of an MP4 file</td></tr><tr class="even"><td>mp4extract</td><td>extracts an atom/box from an MP4 file</td></tr><tr class="odd"><td>mp4encrypt</td><td>encrypts an MP4 file (multiple encryption schemes are supported)</td></tr><tr class="even"><td>mp4decrypt</td><td>decrypts an MP4 file (multiple encryption schemes are supported)</td></tr><tr class="odd"><td>mp4dcfpackager</td><td>encrypts a media file into an OMA DCF file</td></tr><tr class="even"><td>mp4compact</td><td>converts 'stsz' tables into 'stz2' tables to create more compact MP4 files</td></tr><tr class="odd"><td>mp4fragment</td><td>creates a fragmented MP4 file from a non-fragmented one.</td></tr><tr class="even"><td>mp4split</td><td>splits a fragmented MP4 file into discrete files</td></tr><tr class="odd"><td>mp4tag</td><td>show/edit MP4 metadata (iTunes-style and others)</td></tr><tr class="even"><td>mp4mux</td><td>multiplexes one or more elementary streams (H264/AVC, H265/HEVC, AAC) into an MP4 file</td></tr><tr class="odd"><td>mp42aac</td><td>extract a raw AAC elementary stream from an MP4 file</td></tr><tr class="even"><td>mp42avc</td><td>extract a raw AVC/H.264 elementary stream from an MP4 file</td></tr><tr class="odd"><td>mp42hls</td><td>converts an MP4 file to an HLS (HTTP Live Streaming) presentation, including the generation of the segments and .m3u8 playlist as well as AES-128 and SAMPLE-AES (for Fairplay) encryption. This can be used as a replacement for Apple's mediafilesegmenter tool.</td></tr><tr class="even"><td>mp42ts</td><td>converts an MP4 file to an MPEG2-TS file.</td></tr><tr class="odd"><td>mp4dash</td><td>creates an MPEG DASH output from one or more MP4 files, including encryption. This is a full-featured MPEG DASH packager.</td></tr><tr class="even"><td>mp4dashclone</td><td>creates a local clone of a remote or local MPEG DASH presentation, optionally encrypting the segments as they are cloned.</td></tr><tr class="odd"><td>mp4hls</td><td>creates a multi-bitrate HLS master playlist from one or more MP4 files, including support for encryption and I-frame-only playlists. This tool uses the 'mp42hls' low level tool internally, so all the options supported by that low level tool are also available. This can be used as a replacement for Apple's variantplaylistcreator tool.</td></tr></tbody></table><h2 id="gpac">GPAC</h2><p><a href="https://gpac.wp.imt.fr/" target="_blank" rel="noopener">GPAC</a> 是一个为科研和学术领域开发的多媒体的框架，包括几个视频分析和码流编辑的 CLI 工具。官网主要 feature 如下:</p><blockquote><p>GPAC features encoders and multiplexers, publishing and content distribution tools for MP4 and 3GPP or 3GPP2 files and many tools for scene descriptions (BIFS/VRML/X3D converters, SWF/BIFS, SVG/BIFS, etc…). MP4Box provides all these tools in a single command-line application. An exhaustive list of packaging features is available here but a good summary of what MP4Box can do for you is the following:</p><ul><li>MP4/3GP Conversion from MP3, AVI, MEPG-2 TS, MPEG-PS, AAC, H263, H264, AMR, and many others,</li><li>3GPP DIMS Packaging from SVG files,</li><li>File layout: fragmentation or interleaving, and cleaning,</li><li>File hinting for RTP/RTSP and QTSS/DSS servers (MPEG-4 / ISMA / 3GP / 3GP2 files),</li><li>File splitting by size or time, extraction from file and file concatenation,</li><li>XML information dumping for MP4 and RTP hint tracks,</li><li>Media Track extractions,</li><li>ISMA E&amp;A encryption and decryption,</li><li>3GPP timed text tools (SUB/SRT/TTXT/TeXML), VobSub import/export,</li><li>BIFS codec and scene conversion between MP4, BT and XMT-A,</li><li>LASeR codec and scene conversion between MP4, SAF, SVG and XSR (XML LASeR),</li><li>XML scene statistics for BIFS scene (BT, XMT-A and MP4),</li><li>Conversion to and from BT, XMT-A, WRL, X3D and X3DV with support for gzip.</li><li>Preparing MP4,3GP and MPEG-2 TS files for DASH streaming</li></ul></blockquote><p>主要使用的可能是 <code>MP4Box</code> 工具，功能很多，几个例子:</p><pre><code class="hljs bash">MP4Box -add file.av1 file_av1.mp4 <span class="hljs-comment"># 将 av1 码流封装写入 mp4 文件</span></code></pre><h2 id="ffprobe">ffprobe</h2><p>大名鼎鼎的 ffmpeg 项目一员，一身<a href="https://ffmpeg.org/ffprobe.html" target="_blank" rel="noopener">技能和 API 参数</a>。</p><p>其中一个用法是 dump 出所有的 frame:</p><pre><code class="hljs undefined">ffprobe -show_frames some.mp4 &gt; probe-mp4.txt</code></pre><pre><code class="hljs undefined">[FRAME]media_type=videostream_index=0key_frame=1pkt_pts=0pkt_pts_time=0.000000pkt_dts=0pkt_dts_time=0.000000best_effort_timestamp=0best_effort_timestamp_time=0.000000pkt_duration=512pkt_duration_time=0.040000pkt_pos=48pkt_size=27979width=320height=564pix_fmt=yuv420psample_aspect_ratio=N/Apict_type=Icoded_picture_number=0display_picture_number=0interlaced_frame=0top_field_first=0repeat_pict=0color_range=unknowncolor_space=unknowncolor_primaries=unknowncolor_transfer=unknownchroma_location=left[/FRAME][FRAME]media_type=audiostream_index=1key_frame=1pkt_pts=0pkt_pts_time=0.000000pkt_dts=0pkt_dts_time=0.000000best_effort_timestamp=0best_effort_timestamp_time=0.000000pkt_duration=1024pkt_duration_time=0.021333pkt_pos=28243pkt_size=6sample_fmt=fltpnb_samples=1024channels=2channel_layout=stereo[/FRAME]</code></pre><h1 id="二进制显示编辑">二进制显示/编辑</h1><h2 id="hex-fiend">Hex Fiend</h2><p><a href="https://github.com/ridiculousfish/HexFiend" target="_blank" rel="noopener">Hex Fiend</a>, Mac 下的 hex 编辑 GUI 工具，支持按文本或hex搜索/编辑/diff，功能强大。</p><figure><img src="https://raw.githubusercontent.com/ridiculousfish/HexFiend/master/docs/screenshot.png" alt="HexFiend"><figcaption>HexFiend</figcaption></figure><h2 id="hexyl">hexyl</h2><p><a href="https://github.com/sharkdp/hexyl" target="_blank" rel="noopener">hexyl</a> ，一个轻量 CLI 查看二进制数据的工具，用 rust 编写。优点是快速，好看。</p><figure><img src="https://camo.githubusercontent.com/1f71ee7031e1962b23f21c8cc89cb837e1201238/68747470733a2f2f692e696d6775722e636f6d2f4d574f3975534c2e706e67" alt="hexyl 效果图"><figcaption>hexyl 效果图</figcaption></figure>]]></content>
    
    <summary type="html">
    
      分享一些学习 avcodec 技术时好用的分析工具
    
    </summary>
    
      <category term="工具" scheme="http://hikerpig.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="video" scheme="http://hikerpig.github.io/tags/video/"/>
    
  </entry>
  
  <entry>
    <title>Tips On Viewing Logs</title>
    <link href="http://hikerpig.github.io/2019/03/08/2019-03-08-Tips-On-Viewing-Logs/"/>
    <id>http://hikerpig.github.io/2019/03/08/2019-03-08-Tips-On-Viewing-Logs/</id>
    <published>2019-03-08T05:48:27.839Z</published>
    <updated>2019-03-08T06:00:52.239Z</updated>
    
    <content type="html"><![CDATA[<p>面对浩如烟海的 log，在排查错误和查找信息时使用一些趁手的工具，快速定位，关爱视力，有益身心健康。</p><h1 id="高级的工具">高级的工具</h1><h2 id="lnav">lnav</h2><p><a href="http://lnav.org/" target="_blank" rel="noopener">lnav</a> 是一个非常强大的日志查看器，有多种视图和过滤功能，不过最喜欢的其实还是自动的颜色高亮。</p><figure><img src="https://static1.squarespace.com/static/51bd4e13e4b0052d7873ad34/t/551aa43fe4b065952ea849ad/1427809346467/?format=1500w" alt="lnav 官网给出的效果图"><figcaption>lnav 官网给出的效果图</figcaption></figure><h1 id="系统自带工具">系统自带工具</h1><p>不用安装额外的程序，linux 多数发行版都有的基础工具。</p><h2 id="less">less</h2><h3 id="高亮搜索命中内容">高亮搜索命中内容</h3><p><a href="https://unix.stackexchange.com/questions/179173/make-less-highlight-search-patterns-instead-of-italicizing-them" target="_blank" rel="noopener">Make Less highlight search patterns instead of italicizing them</a></p><pre><code class="hljs undefined">export LESS_TERMCAP_se=$&apos;\E[39;49m&apos;</code></pre>]]></content>
    
    <summary type="html">
    
      一些看 LOG 时方便的工具和技巧
    
    </summary>
    
      <category term="Tips" scheme="http://hikerpig.github.io/categories/Tips/"/>
    
    
      <category term="tip" scheme="http://hikerpig.github.io/tags/tip/"/>
    
  </entry>
  
  <entry>
    <title>Decode Video Using ffmpeg In Browser</title>
    <link href="http://hikerpig.github.io/2019/03/06/2019-03-06-Decode-Video-Using-FFMpeg-In-Browser/"/>
    <id>http://hikerpig.github.io/2019/03/06/2019-03-06-Decode-Video-Using-FFMpeg-In-Browser/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-04-03T16:06:00.419Z</updated>
    
    <content type="html"><![CDATA[<p>音视频开发入门，可能绕不开 ffmpeg 这个项目，最近看了篇 <a href="https://zhuanlan.zhihu.com/p/40786748" target="_blank" rel="noopener">知乎专栏</a>，觉得这个事情很有意思。</p><p>比起直接编辑整个 ffmpeg 项目的 CLI 到前端，更符合实际需求的方式，是先基于 ffmpeg 各种 lib二次开发出合适的功能，然后再使用 Emscripten 编译到 Webassembly。</p><p>跟着教程实现一个功能：解析出视频任意一帧的图像并绘制到 canvas 上。</p><h2 id="web-demo-应用流程">Web demo 应用流程</h2><p>demo 页的简单流程</p><pre><code class="hljs mermaid">graph TD    P1[获取视频 buffer 并写入wasm将要使用的线性内存空间] -- 进入wasm调用 --&gt; Asubgraph C 程序转成的 wasm    A[avcodec 解析视频文件 buffer] --&gt; B[解出指定时间的图像并转成 RGB 格式数据]    B --&gt; C[将图像等数据写入内存, 并将指针返给 js 端]end    C  -- 回到 js --&gt;  D[根据指针读出数据, 构建 ImageData, 绘制到 canvas 上]</code></pre><h2 id="从源码编译-ffmpeg">从源码编译 ffmpeg</h2><p>本文写就的时候使用的是 ffmpeg <code>n4.2-dev</code> 版，将其源码置于项目相对目录 <code>lib/ffmpeg</code> 下。</p><p>ffmpeg 是一个很大的项目，包含的很多功能对于我们的需求来说，都用不上，可以通过 <a href="https://github.com/FFmpeg/FFmpeg/blob/master/configure" target="_blank" rel="noopener">configure</a> 配置留下合适的功能集。以前用 c 写的比较复杂的项目，通常在实际编译之前，可以使用 configure 根据参数和环境生成实际编译过程需要的 Makefile。</p><h3 id="项目-makefile">项目 Makefile</h3><p>参考 <a href="https://github.com/Kagami/ffmpeg.js/" target="_blank" rel="noopener">ffmpeg.js</a> 项目的一些配置</p><pre><code class="hljs makefile">COMMON_FILTERS = scale crop overlayCOMMON_DEMUXERS = matroska ogg avi mov flv mpegps image2 mp3 concatCOMMON_DECODERS = \mpeg2video mpeg4 h264 hevc \png mjpeg \mp3 ac3 aacMUXERS = mp4 null image2ENCODERS = mjpegFFMPEG_CONFIGURE_ARGS = \--cc=emcc \--ar=emar \--enable-cross-compile \--target-os=none \--cpu=generic \--arch=x86 \--disable-runtime-cpudetect \--disable-asm \--disable-fast-unaligned \--disable-pthreads \--disable-w32threads \--disable-os2threads \--disable-debug \--disable-stripping \\--disable-all \--enable-avcodec \--enable-avformat \--enable-avutil \--enable-swscale \--enable-shared \--enable-protocol=file \<span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> --enable-decoder=,<span class="hljs-variable">$(COMMON_DECODERS)</span>)</span> \<span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> --enable-demuxer=,<span class="hljs-variable">$(COMMON_DEMUXERS)</span>)</span> \<span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> --enable-encoder=,<span class="hljs-variable">$(ENCODERS)</span>)</span> \<span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> --enable-muxer=,<span class="hljs-variable">$(MUXERS)</span>)</span> \<span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> --enable-<span class="hljs-built_in">filter</span>=,<span class="hljs-variable">$(COMMON_FILTERS)</span>)</span> <span class="hljs-comment"># to run ffmpeg configure and emmake</span><span class="hljs-section">lib/ffmpeg/libavcodec/libavcodec.a:</span>cd lib/ffmpeg &amp;&amp; \patch -p1 &lt; ../swscale.c.patch &amp;&amp; \emconfigure ./configure \<span class="hljs-variable">$(FFMPEG_CONFIGURE_ARGS)</span> \&amp;&amp; \emmake make</code></pre><p>说下 <code>lib/ffmpeg/libavcodec/libavcodec.a</code> 这个目标，分成几步:</p><ul><li><code>emconfigure</code> 是 emsdk 提供的工具，执行完这一步之后，会生成 <code>lib/ffmpeg/Makefile</code></li><li><code>emmake make</code> 便是开始编译了，由于我们在前一步 configure 的时候有 <code>--enable-avcodec</code>，所以用这个 Makefile 编译，会生成 <code>lib/ffmpeg/libavcodec/libavcodec.a</code> 这个静态库文件</li><li>编译原本的 ffmpeg 代码会报错，定位到 <code>libswscale/swscale.c</code> 文件里，为了编译通过，在编译前加了个不影响主要功能的简单的 patch</li></ul><p>运行 <code>make lib/ffmpeg/libavcodec/libavcodec.a</code>，等待大约一两分钟，emscripten 编译 ffmpeg 静态库完成，闪过了一堆 warning 可以优雅地无视掉。接下来就是编写我们的应用接口代码并编译到 WebAssembly 了。</p><h2 id="编译和使用">编译和使用</h2><h3 id="生成-js-和-wasm-文件">生成 JS 和 WASM 文件</h3><pre><code class="hljs makefile"><span class="hljs-section">dist/vidy-standalone.js:</span>    emcc transcoder/web.c transcoder/process.c \                lib/ffmpeg/libavformat/libavformat.a \                lib/ffmpeg/libavcodec/libavcodec.a \                lib/ffmpeg/libswscale/libswscale.a \                lib/ffmpeg/libavutil/libavutil.a \                -s TOTAL_MEMORY=33554432 \                -s MODULARIZE=1 \                -O1 -s WASM=1 -s EXTRA_EXPORTED_RUNTIME_METHODS='[<span class="hljs-string">"ccall"</span>, <span class="hljs-string">"cwrap"</span>]' -s ALLOW_MEMORY_GROWTH=1  \                -Ilib/ffmpeg \                --post-js transcoder/js/post.js \                -o dist/vidy-standalone.js</code></pre><p>使用 <code>emcc</code> 编译：</p><ul><li>存放暴露给浏览器的相关接口的 <code>web.c</code></li><li>存放通用的 ffmpeg 方法调用的 <code>process.c</code></li><li>以及之前生成个几个静态库文件 <code>.a</code></li></ul><p>其中一些参数说明一下： - <code>-s MODULARIZE=1</code> 让 emcc 生成模块工厂函数（而且还是 UMD 格式的），留待之后调用。否则默认情况下生成的 JS 会立刻执行，而且还会污染其所在全局环境（例如添加一个 self.Module 对象）</p><p>一起生成目标文件 <code>dist/vidy-standalone.js</code>，由于传递了 <code>-s WASM=1</code>，还会生成同名的 <code>dist/vidy-standalone.wasm</code> 文件。JS 是一个一千来行的胶水代码，负责 WASM 模块的初始化和调用适配。WASM 文件大概 4.7M。</p><p>查看 <a href="%5Bhttps://emscripten.org/docs/tools_reference/emcc.html">emcc文档</a> 和 <a href="https://github.com/emscripten-core/emscripten/blob/master/src/settings.js" target="_blank" rel="noopener">关于 <code>-s</code> 的全部可选 setting</a>。</p><h3 id="使用方法">使用方法</h3><h4 id="简单的例子">简单的例子</h4><pre><code class="hljs js"><span class="hljs-keyword">import</span> Module <span class="hljs-keyword">from</span> <span class="hljs-string">'../dist/vidy-standalone'</span><span class="hljs-keyword">let</span> vidyModulefetch(<span class="hljs-string">'//path/to/dist/vidy-standalone.wasm'</span>)    .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.arrayBuffer())    .then(<span class="hljs-function">(<span class="hljs-params">arrayBuffer</span>) =&gt;</span> &#123;        vidyModule = Module(&#123;            <span class="hljs-attr">wasmBinary</span>: arrayBuffer        &#125;)        decodeVideoFrameImage(<span class="hljs-string">'some.mp4'</span>, <span class="hljs-number">1.2</span>)    &#125;)<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">decodeVideoFrameImage</span>(<span class="hljs-params">videoPath, timeStamp</span>) </span>&#123;    fetch(videoPath).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.arrayBuffer())        .then(<span class="hljs-function">(<span class="hljs-params">videoBuffer</span>) =&gt;</span> &#123;            <span class="hljs-keyword">const</span> imageResult = vidyModule.getImage(<span class="hljs-keyword">this</span>.result, <span class="hljs-built_in">parseFloat</span>(timeStamp))            <span class="hljs-comment">// ...</span>        &#125;)&#125;</code></pre><h4 id="稍微复杂点的例子">稍微复杂点的例子</h4><p>为了将模块更好地整合到前端工程中，有必要考虑在使用 webpack 的情况下如何引入。</p><p>参考 <a href="https://github.com/GoogleChromeLabs/squoosh/" target="_blank" rel="noopener">GoogleChromeLabs/squoosh</a> 项目中的一些经验，首先看下 webpack 配置。webpack 团队在 v4 以后做了很多努力，想要让 WASM 模块的引入和使用与 js 文件一样方便，但实际实用中有很多边边角角<a href="https://github.com/webpack/webpack/issues/6725" target="_blank" rel="noopener">奇怪的问题和报错</a>，而且处理一个好几兆的 wasm 文件拖慢 webpack 冷启动许多，我们可以用一下配置让 webpack 不去读取 WASM 文件。使用 file-loader 也可以简单地配置带哈希的文件名，比起在项目中硬编码 WASM 文件路径，少去一些缓存问题。</p><pre><code class="hljs js"><span class="hljs-comment">// webpack config</span>    rules: [    ...      &#123;        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.wasm$/</span>,        <span class="hljs-comment">// This is needed to make webpack NOT process wasm files.</span>        type: <span class="hljs-string">'javascript/auto'</span>,        <span class="hljs-attr">loader</span>: <span class="hljs-string">'file-loader'</span>,        <span class="hljs-attr">options</span>: &#123;          <span class="hljs-attr">name</span>: <span class="hljs-string">'[name].[hash:5].[ext]'</span>,        &#125;,      &#125;,    ...    ]</code></pre><p>跟上面简单例子里效果相似的写法可以变成这样:</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> Module <span class="hljs-keyword">from</span> <span class="hljs-string">'../dist/vidy-standalone'</span><span class="hljs-keyword">import</span> vidyWasmUrl <span class="hljs-keyword">from</span> <span class="hljs-string">'../dist/vidy-standalone.wasm'</span> <span class="hljs-comment">// 会被 file-loader 处理成一个静态文件的 url</span><span class="hljs-keyword">const</span> vidyModule = Module(&#123;    locateFile(url) &#123;        <span class="hljs-comment">// Redirect the request for the wasm binary to whatever webpack gave us.</span>        <span class="hljs-keyword">if</span> (url.endsWith(<span class="hljs-string">'.wasm'</span>)) <span class="hljs-keyword">return</span> vidyWasmUrl;        <span class="hljs-keyword">return</span> url;    &#125;,&#125;)</code></pre><p>emcc 生成的胶水代码里，默认请求的 WASM 文件路径是 <code>vidy-standalone.wasm</code>，但看看 <a href="https://github.com/emscripten-core/emscripten/blob/master/emcc.py#L2800" target="_blank" rel="noopener">emcc 这一部分实现</a> 知道，如果给模块工厂函数 Module 传递了 <code>locateFile</code> 函数，就可以改写其内部会去请求的 WASM 文件路径。使用模块工厂函数的话，也不用自己去调用 <code>fetch</code> 了。</p><h2 id="一些具体实现的代码">一些具体实现的代码</h2><p>首先看看 <code>web.c</code> 里暴露出的方法签名：</p><pre><code class="hljs c"><span class="hljs-function">EMSCRIPTEN_KEEPALIVE MyImageData *<span class="hljs-title">seek_video_to</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *buff, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> buff_length, <span class="hljs-keyword">float</span> time_stamp)</span></span></code></pre><p>buffer 数组头指针 <code>buff</code>，buffer 长度 <code>buff_length</code>，以及用单精度浮点数表示的需要提取图像的时间。返回数据为我们自定义的结构。</p><h3 id="js-将视频数据写入-wasm-线性内存">[JS] 将视频数据写入 WASM 线性内存</h3><p>在 <code>post.js</code> 里，添加的一部分代码。</p><ul><li>根据 C 的方法签名，使用 emscripten 的胶水代码工具函数 <code>Module.cwrap</code> 包装一个 JS 的调用方法</li><li>给 emscripten 模块加上了 <code>Module.getImage</code> 方法，供外部调用</li></ul><pre><code class="hljs js"><span class="hljs-keyword">let</span> seek_video_to = <span class="hljs-literal">null</span>Module.onRuntimeInitialized = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  seek_video_to = Module.cwrap(<span class="hljs-string">'seek_video_to'</span>, <span class="hljs-string">'number'</span>, [<span class="hljs-string">'number'</span>, <span class="hljs-string">'number'</span>, <span class="hljs-string">'number'</span>]);&#125;;Module.getImage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">buffer, timeStamp</span>) </span>&#123;  <span class="hljs-keyword">if</span> (!seek_video_to) &#123;    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">errcode</span>: <span class="hljs-number">1</span> &#125;  &#125;  <span class="hljs-keyword">let</span> ptr = <span class="hljs-number">0</span>;  <span class="hljs-keyword">let</span> offset = <span class="hljs-number">0</span>;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">const</span> before = <span class="hljs-built_in">Date</span>.now()    <span class="hljs-keyword">let</span> data_arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(buffer);    offset = Module._malloc(data_arr.length);    Module.HEAP8.set(data_arr, offset);    ptr = seek_video_to(offset, data_arr.length, timeStamp);    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'seek_video_to costs'</span>, <span class="hljs-built_in">Date</span>.now() - before)  &#125; <span class="hljs-keyword">catch</span> (e) &#123;    <span class="hljs-keyword">throw</span> e;  &#125;  ...</code></pre><h3 id="c-程序头部">[C] 程序头部</h3><p>首先声明一些方便数据读取的全局变量:</p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span>    <span class="hljs-keyword">uint8_t</span> *ptr;    <span class="hljs-keyword">size_t</span> size;&#125; BufferData;<span class="hljs-comment">/** * some global variables */</span>BufferData global_buffer_data;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-keyword">uint32_t</span> width;    <span class="hljs-keyword">uint32_t</span> height;    <span class="hljs-keyword">uint8_t</span> *data;&#125; MyImageData;</code></pre><p>全局变量 <code>global_buffer_data</code> 留作存放原始视频数据的结构，它所在的内存区域会被 JS 直接写入。</p><h3 id="c-avcodec-解析视频文件">[C] avcodec 解析视频文件</h3><p>我们需要让 ffmpeg 能够从内存（而不是文件）中读取视频数据。</p><pre><code class="hljs c">...  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *avio_ctx_buffer = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 对于普通的mp4文件，这个size只要1MB就够了，但是对于mov/m4v需要和buff一样大</span>  <span class="hljs-keyword">size_t</span> avio_ctx_buffer_size = buff_length;  global_buffer_data.ptr = buff;         <span class="hljs-comment">/* will be grown as needed by the realloc above */</span>  global_buffer_data.size = buff_length; <span class="hljs-comment">/* no data at this point */</span>  AVFormatContext *pFormatCtx = avformat_alloc_context();  <span class="hljs-keyword">uint8_t</span> *avio_ctx_buffer = (<span class="hljs-keyword">uint8_t</span> *)av_malloc(avio_ctx_buffer_size);  <span class="hljs-comment">/* 读内存数据 */</span>  AVIOContext *avio_ctx = avio_alloc_context(avio_ctx_buffer, avio_ctx_buffer_size, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, read_packet, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);  pFormatCtx-&gt;pb = avio_ctx;  pFormatCtx-&gt;flags = AVFMT_FLAG_CUSTOM_IO;...</code></pre><p>新建 <code>AVIOContext *avio_ctx</code>，指定目标 buffer 指针，目标 buffer 大小，以及我们提供的读取数据的 <code>read_packet</code> 函数，该 iocontext 需要读下一段数据时， <code>read_packet</code> 函数就将 <code>global_buffer_data</code> 中指定大小的数据写入目标 <code>*buf</code> 位置</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read_packet</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *opaque, <span class="hljs-keyword">uint8_t</span> *buf, <span class="hljs-keyword">int</span> buf_size)</span></span>&#123;    buf_size = FFMIN(buf_size, global_buffer_data.size);    <span class="hljs-comment">/* copy internal buffer data to buf */</span>    <span class="hljs-built_in">memcpy</span>(buf, global_buffer_data.ptr, buf_size);    global_buffer_data.ptr += buf_size;    global_buffer_data.size -= buf_size;    <span class="hljs-keyword">return</span> buf_size;&#125;</code></pre><h3 id="c-获取图片rgb数据">[C] 获取图片rgb数据</h3><p>这里内容太多，主要涉及 FFMpeg 的接口和视频编解码的知识，准备另写一篇。</p><h3 id="c-将图像等数据写入内存">[C] 将图像等数据写入内存</h3><p>当拿到包含 RGB 格式图像数据的 <code>AVFrame pFrameRGB</code> 后，是时候将其中的颜色信息取出，转化为线性存储的，利于 JS 中 Canvas 元素使用的数据格式。</p><pre><code class="hljs c"><span class="hljs-keyword">uint8_t</span> *get_image_frame_buffer(AVFrame *pFrame, AVCodecContext *pCodecCtx)&#123;    <span class="hljs-keyword">int</span> width = pCodecCtx-&gt;width;    <span class="hljs-keyword">int</span> height = pCodecCtx-&gt;height;    <span class="hljs-keyword">int</span> buffer_size = height * width * <span class="hljs-number">3</span>;    <span class="hljs-keyword">uint8_t</span> *buffer = (<span class="hljs-keyword">uint8_t</span> *)<span class="hljs-built_in">malloc</span>(buffer_size);    <span class="hljs-comment">// Write pixel data</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; height; y++)    &#123;        <span class="hljs-built_in">memcpy</span>(buffer + y * pFrame-&gt;linesize[<span class="hljs-number">0</span>], pFrame-&gt;data[<span class="hljs-number">0</span>] + y * pFrame-&gt;linesize[<span class="hljs-number">0</span>], width * <span class="hljs-number">3</span>);    &#125;    <span class="hljs-keyword">return</span> buffer;&#125;</code></pre><p>此函数返回的 <code>buffer</code> 指针指向的内存区域，会按照 <code>rgbrgb...</code> 的顺序存储图像颜色数据。每个像素需要 3 个存储单元，所以整个的 <code>buffer_size</code> 会是 <code>height * width * 3</code>。</p><p>接下来我们回到 JS 端。</p><h3 id="js-根据指针读出数据-构建-imagedata">[JS] 根据指针读出数据, 构建 ImageData</h3><p>WASM 返回的只是一个内存偏移量，此时我们手上有整个 WASM 实例的内存区域，得想办法把有用的数据读取出来。</p><p>首先我们知道 <code>MyImageData</code> 结构体宽和高都是用 <code>uint32_t</code>，紧接着存放颜色信息的数组单元类型为 <code>uint8_t</code>。</p><p>Emscripten 的胶水代码有提供 HEAPU(8/16/32/64) 几种步长的 dataviewer，可以按照以下方法读出数字和颜色数组。</p><pre><code class="hljs ts"><span class="hljs-comment">// ...</span>  <span class="hljs-keyword">let</span> heap32Start = ptr / <span class="hljs-number">4</span>  <span class="hljs-keyword">let</span> width = Module.HEAPU32[heap32Start]  <span class="hljs-keyword">let</span> height = Module.HEAPU32[heap32Start + <span class="hljs-number">1</span>],    imgBufferPtr = Module.HEAPU32[heap32Start + <span class="hljs-number">2</span>],    imageBuffer = Module.HEAP.subarray(imgBufferPtr, imgBufferPtr + width * height * <span class="hljs-number">3</span>)  <span class="hljs-keyword">let</span> imageInfo = &#123; width, height, imageDataArr: imageBuffer &#125;  <span class="hljs-keyword">let</span> imageData = imageInfoToImageData(imageInfo)<span class="hljs-comment">// ...</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">imageInfoToImageData</span>(<span class="hljs-params">imageInfo: VidyImageInfo</span>) </span>&#123;  <span class="hljs-keyword">const</span> &#123; width, height, imageDataArr &#125; = imageInfo  <span class="hljs-keyword">const</span> imageData = <span class="hljs-keyword">new</span> ImageData(width, height)  <span class="hljs-comment">// 目前只返回 RGB24 格式的数据, 不处理透明度</span>  <span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; imageDataArr.length; i++) &#123;    <span class="hljs-keyword">if</span> (i &amp;&amp; i % <span class="hljs-number">3</span> === <span class="hljs-number">0</span>) &#123;      imageData.data[k++] = <span class="hljs-number">255</span>    &#125;    imageData.data[k++] = imageDataArr[i]  &#125;  imageData.data[k] = <span class="hljs-number">255</span>  <span class="hljs-keyword">return</span> imageData&#125;</code></pre><p>绘制到 canvas 上就很简单了</p><pre><code class="hljs ts">canvas.width = widthcanvas.height = height<span class="hljs-keyword">let</span> ctx = canvas.getContext(<span class="hljs-string">'2d'</span>)ctx.drawImage(imageData, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</code></pre><h2 id="总结">总结</h2><p>跟着别人的文章思路，小小修改，跑通了一个 demo，大致熟悉一下 C 项目使用 Emscripten 转化为前端可用模块的方案。</p><p>不是很熟悉 C 语言，同时在 JS 和 C 端手动管理内存虽然对于入门者来说很容易操作，但稍显繁琐。</p><p>Emscripten 多用于翻译现有的 C/C++ 库代码，对于 Web API 和前端生态的支持，明显没有隔壁 Mozilla 的 Rust 社区积极。不过音视频技术实现，的确是 C 的传统强项领域，若想少造轮子，还是要好好学习的。</p><h2 id="参考">参考</h2><p>https://zhuanlan.zhihu.com/p/40786748</p>]]></content>
    
    <summary type="html">
    
      借助 Emscripten，基于 ffmpeg 二次开发前端音视频功能
    
    </summary>
    
      <category term="前端" scheme="http://hikerpig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Avtech" scheme="http://hikerpig.github.io/tags/Avtech/"/>
    
      <category term="Webassembly" scheme="http://hikerpig.github.io/tags/Webassembly/"/>
    
      <category term="Emscripten" scheme="http://hikerpig.github.io/tags/Emscripten/"/>
    
  </entry>
  
  <entry>
    <title>使用 docker 构造前端构建环境</title>
    <link href="http://hikerpig.github.io/2019/02/15/2019-02-14-Setup-CI-in-docker/"/>
    <id>http://hikerpig.github.io/2019/02/15/2019-02-14-Setup-CI-in-docker/</id>
    <published>2019-02-14T16:00:00.000Z</published>
    <updated>2019-02-18T11:52:23.883Z</updated>
    
    <content type="html"><![CDATA[<p>托管在公司 gitlab 上的一个前端项目，最近在尝试 docker 化。</p><h1 id="准备阶段">准备阶段</h1><h2 id="gitlab-上的一些问题">Gitlab 上的一些问题</h2><p>如果项目不是公开的，从 docker 环境中拉取代码会有些许权限问题，可一一解决。</p><h3 id="clone-with-deploy-token">clone with deploy token</h3><p>到 Gitlab 中对应项目的 settings/repository 页面，生成 Deploy Tokens, 便可以使用 https clone 项目，不用输入用户密码，也不必使用设置相对比较麻烦的 ssh deploy key 方式。</p><p>克隆项目的命令为</p><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://&lt;name&gt;:&lt;token&gt;@gitlab.com/&lt;USER&gt;/&lt;REPO&gt;.git</code></pre><p>此处的 <code>name</code> 是 token name, 不是用户名。只对此项目生效，避免使用权限较高的用户 token。</p><h3 id="git-lfs-拉取文件出错">git-lfs 拉取文件出错</h3><p>即便使用了 deploy token 可以克隆项目文件，但其中使用 git-lfs 追踪的一些文件会失败：</p><pre><code class="hljs txt">Error downloading object: some/filename/blah: Smudge error: https://&lt;name&gt;:&lt;token&gt;@gitlab.com/some/repo.git/info/lfs/objects/batch</code></pre><p>应该是权限问题，可以越过 git-lfs 的 smudge 步骤来规避此问题。</p><pre><code class="hljs bash">GIT_LFS_SKIP_SMUDGE=1 git <span class="hljs-built_in">clone</span> &lt;SERVER-REPOSITORY&gt;</code></pre><p>参考: https://stackoverflow.com/questions/42019529/how-to-clone-pull-a-git-repository-ignoring-lfs</p><h1 id="开始">开始</h1><h2 id="dockerfile">Dockerfile</h2><pre><code class="hljs undefined">FROM node:8.15.0-slim# install git-lfsRUN curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh |  bashRUN apt-get install -y git-lfsWORKDIR /appRUN GIT_LFS_SKIP_SMUDGE=1 git clone https://&lt;name&gt;:&lt;token&gt;@gitlab.com/&lt;USER&gt;/&lt;REPO&gt;.git myrepoWORKDIR /app/myrepoRUN yarn</code></pre><h2 id="构建镜像">构建镜像</h2><p>在 Dockerfile 所在目录下:</p><pre><code class="hljs bash">docker build -t my-app .</code></pre><p>等待几分钟，构建完成便可使用 <code>docker inspect my-app</code> 命令看看新添加的镜像。</p><p>若 package.json 依赖较多，且可以接受在 docker host 和 vm 之间共享文件，可以去掉 <code>RUN yarn</code> 这一步，然后使用 <a href="https://docs.docker.com/storage/volumes/" target="_blank" rel="noopener">docker volume</a> 共享宿主环境中已经提前安装好的 node_modules 文件夹。</p><h2 id="启动容器">启动容器</h2><p>启动一个带 tty 的 interactive 容器并运行 bash，可以在容器里转一转，看看有什么东西:</p><pre><code class="hljs bash">docker run -v /path/to/current/node_modules:/app/myrepo/node_modules -it my-app  --name app-tty /bin/bash</code></pre><p>或是直接跑测试:</p><pre><code class="hljs bash">docker run -v /path/to/current/node_modules:/app/myrepo/node_modules -it my-app  --name <span class="hljs-built_in">test</span>-container /bin/bash -c <span class="hljs-string">'cd /app/myrepo &amp;&amp; npm run test'</span></code></pre>]]></content>
    
    <summary type="html">
    
      使用 docker 构造前端构建环境
    
    </summary>
    
      <category term="运维" scheme="http://hikerpig.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="git" scheme="http://hikerpig.github.io/tags/git/"/>
    
      <category term="前端" scheme="http://hikerpig.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="docker" scheme="http://hikerpig.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>CSS 中的两种模糊半径</title>
    <link href="http://hikerpig.github.io/2018/12/22/2018-12-22-svg-blur-and-css-text-shadow/"/>
    <id>http://hikerpig.github.io/2018/12/22/2018-12-22-svg-blur-and-css-text-shadow/</id>
    <published>2018-12-22T05:52:02.288Z</published>
    <updated>2018-12-30T04:23:40.503Z</updated>
    
    <content type="html"><![CDATA[<p>CSS 中两种实现阴影的方式</p><ol type="1"><li>text-shadow 和 box-shadow</li><li>filter: drop-shadow</li></ol><p>前者的 blur-radius 指的是阴影的最外延半径，后者的 blur-radius 指的是高斯模糊中的标准差($σ)</p><p><a href="https://drafts.csswg.org/css-backgrounds/#shadow-blur" target="_blank" rel="noopener">W3C 的 CSS 标准此处</a> 说到将 stdDeviation 设为 blur-radius 的一半可以得到近似的效果</p><blockquote><p>A non-zero blur radius indicates that the resulting shadow should be blurred, such as by a Gaussian filter. The exact algorithm is not defined; however the resulting shadow must approximate (with each pixel being within 5% of its expected value) the image that would be generated by applying to the shadow a Gaussian blur with a standard deviation equal to half the blur radius</p></blockquote><h2 id="一个实验">一个实验</h2><script async src="//jsfiddle.net/hikerpig/1wq70fgn/embed/result,html,js,css/"></script><p>相同的数值，在不同浏览器中效果不同。总体来说 drop-shadow 的结果会比 text-shadow/box-shadow 的效果更加发散和柔和。</p><h2 id="参考">参考</h2><ul><li><a href="https://dbaron.org/log/20110225-blur-radius" target="_blank" rel="noopener">What does a blur radius mean?</a></li><li><a href="https://drafts.csswg.org/css-backgrounds/#blur-radius" target="_blank" rel="noopener">Blurring Shadow Edges</a></li><li>https://github.com/w3c/fxtf-drafts/issues/102</li><li>https://bugs.chromium.org/p/chromium/issues/detail?id=677689</li><li>https://developer.mozilla.org/en-US/docs/Web/CSS/filter</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CSS 中两种实现阴影的方式&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;text-shadow 和 box-shadow&lt;/li&gt;
&lt;li&gt;filter: drop-shadow&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;前者的 blur-radius 指的是阴影的最外延半径，后者的 
      
    
    </summary>
    
      <category term="前端" scheme="http://hikerpig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="http://hikerpig.github.io/tags/CSS/"/>
    
      <category term="SVG" scheme="http://hikerpig.github.io/tags/SVG/"/>
    
  </entry>
  
  <entry>
    <title>浏览器中的字体信息测量</title>
    <link href="http://hikerpig.github.io/2018/11/15/2018-11-15-font-metrics-in-browser/"/>
    <id>http://hikerpig.github.io/2018/11/15/2018-11-15-font-metrics-in-browser/</id>
    <published>2018-11-14T16:00:00.000Z</published>
    <updated>2019-01-06T02:58:47.755Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题图来自 http://iamvdo.me/en/blog/css-font-metrics-line-height-and-vertical-align</p></blockquote><h1 id="为什么同样的-font-size-文字高度不一样">为什么同样的 font-size ，文字高度不一样？</h1><p>每个字体在设计的时候，都是基于一个 <a href="http://designwithfontforge.com/zh-CN/The_EM_Square.html" target="_blank" rel="noopener">EM Square</a>，这是活字印刷中字模的高度。</p><blockquote><p>在数字化字体中，em 是空间的数字化定义总量。在OpenType字体中，UPM或em大小通常是1000单位。在TrueType字体中，UPM约定是2的幂，通常是1024或2048。</p></blockquote><p>实际情况中，许多字体的内容高度其实是比 em box 要大的。</p><p>同是 <code>font-size: 30px</code> 情况下，此处的 Noto Sans JP 的字体空间就比 Kosugi Maru 要高。而且在字体框内，垂直方向上还有留白。</p><img src="//images-hikerpig.oss-cn-beijing.aliyuncs.com/image/fonts/noto-sans-jp-1.jpg" alt="undefined" title="undefined"><img src="//images-hikerpig.oss-cn-beijing.aliyuncs.com//image/fonts/kosugi-maru-1.jpg" alt="undefined" title="undefined"><p>垂直方向留白大小的计算公式，可以由字体文件中的定义得到：</p><blockquote><p>internal leading = ascent - descent - EM_size</p></blockquote><h1 id="代码片段">代码片段</h1><p>可以在<a href="https://jsfiddle.net/hikerpig/xkt3o4sd/4/" target="_blank" rel="noopener">这个 fiddle</a> 里看到结果。</p><h2 id="使用-canvas-度量文字宽度">使用 canvas 度量文字宽度</h2><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMetricsByCanvas</span>(<span class="hljs-params">canvas, str, font</span>) </span>&#123;  <span class="hljs-keyword">const</span> ctx = canvas.getContext(<span class="hljs-string">'2d'</span>)  ctx.font = font  <span class="hljs-built_in">console</span>.log(str, font, ctx.measureText(str))&#125;<span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">const</span> canvas = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'canvas'</span>)  <span class="hljs-built_in">document</span>.body.appendChild(canvas)  <span class="hljs-built_in">window</span>.canvas = canvas  getMetricsByCanvas(canvas, <span class="hljs-string">'字'</span>, <span class="hljs-string">'30px  Noto Sans JP'</span>) <span class="hljs-comment">// 字 30px  Noto Sans JP TextMetrics &#123;width: 30&#125;</span>&#125;</code></pre><p>不过此 API 是拿不到字符的高度的。就有一些比较黑的方法来估算字体的内容高度，例如使用大写字母 'M' 的宽度作为内功高度的近似。这些技巧其实都与字形设计的惯例有关，在拉丁字母中，'M' 是字形最为饱满和方正的字符，高度与宽度近似。</p><p>不过明显这个惯例对于以上两个日文字体<em>并不适用</em>。</p><p>汉字因为字形多数为饱满的方块字，用宽度去估计内容高度其实更容易，例如 '人' 和 '口' 就很好用。</p><h2 id="创建临时-dom-元素用于度量高度">创建临时 dom 元素用于度量高度</h2><p>能拿到更全的字形盒信息</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMetricsBySpan</span>(<span class="hljs-params">str, font</span>) </span>&#123;  <span class="hljs-keyword">var</span> d = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"span"</span>);  d.style.font = font;  d.textContent = str;  <span class="hljs-built_in">document</span>.body.appendChild(d);  <span class="hljs-keyword">const</span> emHeight = d.offsetHeight;  <span class="hljs-keyword">const</span> emWidth = d.offsetWidth;  <span class="hljs-built_in">console</span>.log(str, font, &#123; emWidth, emHeight &#125;)  <span class="hljs-built_in">document</span>.body.removeChild(d);&#125;getMetricsBySpan(<span class="hljs-string">'字'</span>, <span class="hljs-string">'30px  Noto Sans JP'</span>) <span class="hljs-comment">// 字 30px  Noto Sans JP &#123;emWidth: 30, emHeight: 45&#125;</span></code></pre><h1 id="稍微不那么简单但准确的方法">稍微不那么简单但准确的方法</h1><h2 id="基于-canvas-的-fontmetrics">基于 canvas 的 FontMetrics</h2><p><a href="https://github.com/soulwire/FontMetrics" target="_blank" rel="noopener">FontMetrics</a> 这个库，先清空 canvas，将文字渲染至 canvas 上，然后逐行统计 canvas 上的像素，由此可以知道文字的上下内容边界，再与 font size 换算，便可以得到字符的高度。</p><h2 id="opentype.js">opentype.js</h2><figure><img src="https://camo.githubusercontent.com/2eae816a7d7ec3155c6136a50cc7a939eee608ca/68747470733a2f2f7261772e6769746875622e636f6d2f6f70656e747970656a732f6f70656e747970652e6a732f6d61737465722f672f68656c6c6f2d776f726c642e706e67" alt="opentype.js"><figcaption>opentype.js</figcaption></figure><p><a href="https://opentype.js.org/" target="_blank" rel="noopener">opentype.js</a> 是一个优秀的解析 OpenType 字体的 js 库。以 ArrayBuffer 传入字体的数据，解析出所有 OpenType 标准数据，完全可以基于此写出符合自己需求的排版引擎。</p><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> font = parse(buffer)<span class="hljs-keyword">const</span> g = font.charToGlyph(<span class="hljs-string">'字'</span>)<span class="hljs-keyword">const</span> bb = g.getBoundingBox()  <span class="hljs-comment">// 得出 &#123; x1, x2 , y1, y2 &#125;</span></code></pre><h1 id="参考">参考</h1><p><a href="https://stackoverflow.com/questions/1134586/how-can-you-find-the-height-of-text-on-an-html-canvas" target="_blank" rel="noopener">SO 上的一个问题</a></p><p><a href="https://www.freetype.org/freetype2/docs/glyphs/glyphs-3.html" target="_blank" rel="noopener">FreeType Glyph Metrics</a></p><p><a href="https://www.html5rocks.com/en/tutorials/canvas/texteffects/#toc-text-shadow-clipping" target="_blank" rel="noopener">Typographic effects in canvas</a></p><p><a href="http://iamvdo.me/en/blog/css-font-metrics-line-height-and-vertical-align" target="_blank" rel="noopener">Deep dive CSS: font metrics, line-height and vertical-align</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;题图来自 http://iamvdo.me/en/blog/css-font-metrics-line-height-and-vertical-align&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;为什么同样的-font-size-文字高
      
    
    </summary>
    
      <category term="前端" scheme="http://hikerpig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="浏览器" scheme="http://hikerpig.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="字体" scheme="http://hikerpig.github.io/tags/%E5%AD%97%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>SVG 元素的自定义  transform origin</title>
    <link href="http://hikerpig.github.io/2018/08/26/2018-08-26-beware-of-svg-transform/"/>
    <id>http://hikerpig.github.io/2018/08/26/2018-08-26-beware-of-svg-transform/</id>
    <published>2018-08-25T16:00:00.000Z</published>
    <updated>2019-05-23T06:20:52.554Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不要使用-transform-origin-属性">不要使用 transform-origin 属性</h2><p>SVG 支持 <code>transform</code>，而且写法似乎与 CSS 中相同，但是它的<a href="https://www.w3.org/TR/SVG11/coords.html" target="_blank" rel="noopener">标准</a>里并不支持 <code>transform-origin</code> 属性。虽然在部分浏览器中，给 SVG 元素指定 <code>transform-origin</code> 似乎是有效果的（写法和结果也与 CSS 一样），但是无法指望这个行为在所有浏览器里都有效。</p><h1 id="自行解释-transformorigin">自行解释 transformOrigin</h1><p>既然不能通过 attribute 来指定变换原点，我们只好通过对其他 transform 值的变动来实现想要的效果了。</p><p>首先建立一个对象系统</p><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> Display &#123;  x: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>  y: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>  width: <span class="hljs-built_in">number</span>  height: <span class="hljs-built_in">number</span>  scale: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]  transformOrigin?: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>]  parent?: Display  element: SVGElement  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) &#123;     <span class="hljs-keyword">this</span>.element = <span class="hljs-keyword">this</span>.createElement() <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>  &#125;  createElement() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'g'</span>)  &#125;  addChild(child: Display) &#123;    child.parent = <span class="hljs-keyword">this</span>    <span class="hljs-keyword">this</span>.element.appendChild(child.element)  &#125;&#125;<span class="hljs-keyword">class</span> Rect <span class="hljs-keyword">extends</span> Display &#123;  createElement() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'rect'</span>)  &#125;&#125;</code></pre><p>此时有</p><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> r1 = <span class="hljs-keyword">new</span> Rect(&#123;  name: <span class="hljs-string">"r1"</span>,  x: <span class="hljs-number">10</span>,  y: <span class="hljs-number">10</span>,  width: <span class="hljs-number">100</span>,  height: <span class="hljs-number">50</span>,&#125;)<span class="hljs-keyword">const</span> r2 = <span class="hljs-keyword">new</span> Rect(&#123;  name: <span class="hljs-string">"r2"</span>,  x: <span class="hljs-number">10</span>,  y: <span class="hljs-number">10</span>,  width: <span class="hljs-number">100</span>,  height: <span class="hljs-number">50</span>,  scale: [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>],&#125;)</code></pre><p>经过简单的属性到 dom 的操作，得到</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">rect</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"r1"</span> <span class="hljs-attr">transform</span>=<span class="hljs-string">"translate(10,10)"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"100"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"50"</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">"blue"</span> <span class="hljs-attr">opacity</span>=<span class="hljs-string">"0.8"</span> /&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">rect</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"r2"</span> <span class="hljs-attr">transform</span>=<span class="hljs-string">"translate(10,10) scale(2,2)"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"100"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"50"</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">"red"</span> <span class="hljs-attr">opacity</span>=<span class="hljs-string">"0.8"</span> /&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span></code></pre><svg style="background: #CCC">&lt;rect name="r1" transform="translate(10,10)" width="100" height="50" fill="blue" opacity="0.8" /&gt; <rect name="r2" transform="translate(10,10) scale(2,2)" width="100" height="50" fill="red" opacity="0.8"/></svg><p>r2 的变换，先平移再缩放，平移的结果就是缩放的原点。</p><p>此处将 x/y 转为 translate 而不是 <code>x</code> 和 <code>y</code> 属性，是为了以统一的方式做坐标系的转换和运算，且考虑到许多元素没有 <code>x</code> 和 <code>y</code> 属性（如 <code>circle</code> 就只有 <code>cx</code> 和 <code>cy</code> ），但所有 SVG 元素都支持 transform 。</p><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formTransform</span>(<span class="hljs-params">d: Display</span>) </span>&#123;  <span class="hljs-keyword">const</span> scales = d.scale  <span class="hljs-keyword">const</span> scaleX = scales[<span class="hljs-number">0</span>]  <span class="hljs-keyword">const</span> scaleY = scales[<span class="hljs-number">1</span>]  <span class="hljs-keyword">return</span> <span class="hljs-string">`translate(<span class="hljs-subst">$&#123;d.x&#125;</span>,<span class="hljs-subst">$&#123;d.y&#125;</span>) scale(<span class="hljs-subst">$&#123;scaleX&#125;</span>,<span class="hljs-subst">$&#123;scaleY&#125;</span>)`</span>&#125;</code></pre><h2 id="带位移补偿的缩放">带位移补偿的缩放</h2><p>计算缩放的位移补偿值，使得缩放再位移后效果就与以变换原点为中心缩放一样。</p><p>假设在缩放系数为 S 时，我们需要的 translate 为 <span class="math inline"><em>T</em><em>R</em></span>，变换完的结果：</p><p><br><span class="math display">$$x'=(x+TR_x)\times S_x\\\\y'=(y+TR_y)\times S_y$$</span><br></p><p>当以变换原点为特征点时，方程易于构建与求解。</p><p>令 <span class="math inline"><em>T</em><sub><em>x</em></sub></span> 和 <span class="math inline"><em>T</em><sub><em>y</em></sub></span> 为变换原点相对于原坐标系左上角的坐标，当 <span class="math inline"><em>x</em> = <em>T</em><sub><em>x</em></sub>, <em>y</em> = <em>T</em><sub><em>y</em></sub></span> 时，代入得到：</p><p><br><span class="math display">$$TO_{x} \ \ =\ ( TO_{x} \ +TR_{x}) \times S_{x}\\\\TO_{y} \ \ =\ ( TO_{y} \ +TR_{y}) \times S_{y}$$</span><br></p><p>所以：</p><p><br><span class="math display">$$TR_{x} \ =\frac{( 1-S_{x}) \times TO_{x}}{S_{x}}\\\\\\\\TR_{y} \ =\frac{( 1-S_{y}) \times TO_{y}}{S_{y}}$$</span><br></p><p>带缩放修正值的 transform 计算方法改为：</p><pre><code class="hljs diff">   const scales = d.scale   const scaleX = scales[0]   const scaleY = scales[1]<span class="hljs-deletion">-  return `translate($&#123;d.x&#125;,$&#123;d.y&#125;) scale($&#123;scaleX&#125;,$&#123;scaleY&#125;)`</span><span class="hljs-addition">+</span><span class="hljs-addition">+  let xToOrigin = d.width / 2</span><span class="hljs-addition">+  let yToOrigin = d.height / 2</span><span class="hljs-addition">+  if (d.transformOrigin) &#123;</span><span class="hljs-addition">+    xToOrigin = d.transformOrigin[0]</span><span class="hljs-addition">+    yToOrigin = d.transformOrigin[1]</span><span class="hljs-addition">+  &#125;</span><span class="hljs-addition">+  const revisedX = (1 - scaleX) * xToOrigin</span><span class="hljs-addition">+  const revisedY = (1 - scaleY) * yToOrigin</span><span class="hljs-addition">+</span><span class="hljs-addition">+  return `translate($&#123;d.x&#125;,$&#123;d.y&#125;) scale($&#123;scaleX&#125;,$&#123;scaleY&#125;) translate($&#123;revisedX&#125;,$&#123;revisedY&#125;)`</span> &#125;</code></pre><p>例如一个缩放为2倍，</p><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> r3 = <span class="hljs-keyword">new</span> Rect(&#123;  x: <span class="hljs-number">50</span>,  y: <span class="hljs-number">50</span>,  width: <span class="hljs-number">100</span>,  height: <span class="hljs-number">50</span>,  scale: [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>],  transformOrigin: [<span class="hljs-number">50</span>, <span class="hljs-number">25</span>],&#125;)</code></pre><p>对应于缩放的变换应该是 <code>scale(2,2) translate(-25,-12.5)</code>，再加上元素本身的位移，最后得到：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">rect</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"r3"</span> <span class="hljs-attr">transform</span>=<span class="hljs-string">"translate(50,50) scale(2,2) translate(-25,-12.5)"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"100"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"50"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span></code></pre><p>变换过程示意:</p><img src="//images-hikerpig.oss-cn-beijing.aliyuncs.com/image/trans-demo-1.svg" alt="变换过程示意" title="变换过程示意"><h2 id="参考">参考</h2><ul><li><a href="https://www.sarasoueidan.com/blog/svg-coordinate-systems/" target="_blank" rel="noopener">svg-coordinate-systems</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;不要使用-transform-origin-属性&quot;&gt;不要使用 transform-origin 属性&lt;/h2&gt;
&lt;p&gt;SVG 支持 &lt;code&gt;transform&lt;/code&gt;，而且写法似乎与 CSS 中相同，但是它的&lt;a href=&quot;https://www.w3
      
    
    </summary>
    
      <category term="前端" scheme="http://hikerpig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="SVG" scheme="http://hikerpig.github.io/tags/SVG/"/>
    
  </entry>
  
  <entry>
    <title>Goodbye My Santa Monica Dream 🎵</title>
    <link href="http://hikerpig.github.io/2018/07/31/2018-07-31-Goodbye%20My%20Santa%20Monica%20Dream/"/>
    <id>http://hikerpig.github.io/2018/07/31/2018-07-31-Goodbye My Santa Monica Dream/</id>
    <published>2018-07-30T16:00:00.000Z</published>
    <updated>2018-08-26T08:49:59.529Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&amp;id=30496500&amp;auto=1&amp;height=66"></iframe><p>从《Life is strange》的原声带中发现的瑰宝，来自澳大利亚的兄妹组合 <a href="https://music.douban.com/musician/100215/" target="_blank" rel="noopener">Angus &amp; Julia Stone</a> 的一首略显忧伤的曲子，他俩前几年的曲风，小清新中带着些许迷幻。妹妹声音空灵慵懒，像加州的海风，棕榈叶间斑驳的阳光，和歌词特别配。</p><p>原曲使用 Open D 调弦，变调夹 3 品，感谢 <a href="http://www.goliathguitartutorials.com" target="_blank" rel="noopener">Goliath Guitar</a> 在 <a href="https://www.youtube.com/watch?v=sOJMMpdWScM" target="_blank" rel="noopener">Youtube 上的教程</a>，讲解详细，也给出了还原度几乎 100% 的伴奏谱子，而且非常好弹。pdf 谱例可以<a href="http://www.goliathguitartutorials.com/santa-monica-dream.html" target="_blank" rel="noopener">去这里下载</a>。</p><img src="//images-hikerpig.oss-cn-beijing.aliyuncs.com/image/tabs/santa_monica_dream_-_angus_and_julia.jpg" alt="undefined" title="undefined">]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;amp
      
    
    </summary>
    
      <category term="杂记" scheme="http://hikerpig.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="吉他" scheme="http://hikerpig.github.io/tags/%E5%90%89%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>Vuex 模块动态注册的一些实践经验</title>
    <link href="http://hikerpig.github.io/2018/07/03/2018-07-03-Vuex-Dynamic-Module-Hints/"/>
    <id>http://hikerpig.github.io/2018/07/03/2018-07-03-Vuex-Dynamic-Module-Hints/</id>
    <published>2018-07-02T16:00:00.000Z</published>
    <updated>2019-01-07T05:50:06.415Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>构建大型 SPA 应用时，代码分割和懒加载是比较常用的优化手段，在 Vue 生态下，使用 vue-router 很容易实现组件的懒加载。</p><p>但应用里除了组件，还有庞大的业务逻辑，这部分如何分割和懒加载比较合适呢？</p><p>使用 Vuex 管理状态的话，其提供了方法 <code>registerModule</code> 用于<a href="https://vuex.vuejs.org/guide/modules.html#dynamic-module-registration" target="_blank" rel="noopener">动态注册</a> Module。</p><p>因此某个页面独有的业务逻辑和状态管理，在初始化全局 store 的时候可以不用引入，之后在该页面路由组件中再引入和注册 Vuex 模块。</p><h1 id="简单的示例">简单的示例</h1><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> PageA = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./views/PageA.js'</span>)<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;  <span class="hljs-attr">routes</span>: [    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'/page-a'</span>, <span class="hljs-attr">component</span>: PageA &#125;  ]&#125;)</code></pre><p>简单的 Vuex 模块：</p><pre><code class="hljs javascript"><span class="hljs-comment">// store/modules/page-a.js</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> VUEX_NS = <span class="hljs-string">'page-a'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-attr">namespaced</span>: <span class="hljs-literal">true</span>,  state() &#123;    <span class="hljs-keyword">return</span> &#123;      <span class="hljs-attr">inventory</span>: &#123;        <span class="hljs-attr">list</span>: []      &#125;    &#125;  &#125;,  <span class="hljs-attr">getters</span>: &#123;    inventoryList(state) &#123;      <span class="hljs-keyword">return</span> state.inventory.list    &#125;  &#125;&#125;</code></pre><p>实践时遭遇了几个问题：</p><h2 id="问题-1服务器客户端-在尚未注册-module-时调用其下的-actionmutation-vuex-因找不到对应函数而出错">问题 1：服务器/客户端 在尚未注册 Module 时，调用其下的 action/mutation ，Vuex 因找不到对应函数而出错</h2><pre><code class="hljs javascript"><span class="hljs-comment">// views/PageA.js</span><span class="hljs-keyword">import</span> PAGE_A_MODULE, &#123; VUEX_NS &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'store/modules/page-a'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">'PageA'</span>,  beforeCreate() &#123;    <span class="hljs-keyword">this</span>.$store.registerModule(VUEX_NS, PAGE_A_MODULE)    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.$store.dispatch(<span class="hljs-string">`<span class="hljs-subst">$&#123;VUEX_NS&#125;</span>/fetchInventory`</span>)  &#125;,&#125;</code></pre><h3 id="考虑服务器端预取数据注入给客户端的时候">考虑服务器端预取数据注入给客户端的时候</h3><p>客户（浏览器）端初始化代码，在初始化 router 之前，给 Vuex 全局 store 注入数据：</p><pre><code class="hljs js"><span class="hljs-comment">// entry-client.js</span>store.replaceState(<span class="hljs-built_in">window</span>.__INITIAL_STATE__)</code></pre><p>此处的 <code>__INITIAL_STATE__</code> 是 Vue SSR 提供的一个功能，使得浏览器端可以复用服务器端已经预取过的数据。</p><pre><code class="hljs js"><span class="hljs-comment">// 在所有预取钩子(preFetch hook) resolve 后，</span><span class="hljs-comment">// 我们的 store 现在已经填充入渲染应用程序所需的状态。</span><span class="hljs-comment">// 当我们将状态附加到上下文，</span><span class="hljs-comment">// 并且 `template` 选项用于 renderer 时，</span><span class="hljs-comment">// 状态将自动序列化为 `window.__INITIAL_STATE__`，并注入 HTML。</span>context.state = store.state</code></pre><p>此处的 <code>asyncData</code> 与 <a href="https://ssr.vuejs.org/zh/guide/data.html#%E6%95%B0%E6%8D%AE%E9%A2%84%E5%8F%96%E5%AD%98%E5%82%A8%E5%AE%B9%E5%99%A8-data-store" target="_blank" rel="noopener">Vue SSR 文档中的例子</a>类似，与 Nuxt.js 中的同名函数用法略有不同。</p><p><code>prepareVuex</code> 为自定义的组件钩子函数，会先于 asyncData 调用，具体过程之后探讨。</p><pre><code class="hljs diff"> export default &#123;   name: 'PageA',<span class="hljs-deletion">-  beforeCreate() &#123;</span><span class="hljs-deletion">-    this.$store.registerModule(VUEX_NS, PAGE_A_MODULE)</span><span class="hljs-deletion">-    return this.$store.dispatch(`$&#123;VUEX_NS&#125;/fetchInventory`)</span><span class="hljs-addition">+  prepareVuex(&#123; store &#125;) &#123;</span><span class="hljs-addition">+    store.registerModule(VUEX_NS, PAGE_A_MODULE)</span><span class="hljs-addition">+  &#125;,</span><span class="hljs-addition">+  asyncData(&#123; store &#125;) &#123;</span><span class="hljs-addition">+    return store.dispatch(`$&#123;VUEX_NS&#125;/fetchInventory`)</span>   &#125;, &#125;</code></pre><p>此时会遇见</p><h2 id="问题2-客户端没有用上服务器端预取的数据">问题2: 客户端没有用上服务器端预取的数据</h2><p>解决方式：</p><pre><code class="hljs diff"> export default &#123;   name: 'PageA',<span class="hljs-deletion">-  prepareVuex(&#123; store &#125;) &#123;</span><span class="hljs-deletion">-    store.registerModule(VUEX_NS, PAGE_A_MODULE)</span><span class="hljs-addition">+  prepareVuex(&#123; store, isClientInitialRoute &#125;) &#123;</span><span class="hljs-addition">+    store.registerModule(VUEX_NS, PAGE_A_MODULE, &#123; preserveState: isClientInitialRoute &#125;)</span>   &#125;,   asyncData(&#123; store &#125;) &#123;     return store.dispatch(`$&#123;VUEX_NS&#125;/fetchInventory`)   &#125;,<span class="hljs-addition">+  beforeDestroy() &#123;</span><span class="hljs-addition">+    // 销毁该模块</span><span class="hljs-addition">+    this.$store.unregisterModule(VUEX_NS)</span><span class="hljs-addition">+  &#125;</span> &#125;</code></pre><p>注册 Vuex 模块的时候使用了 <code>preserveState</code> ，若启用此选项，注册 Module 时若 <code>store.state[namespace]</code> 下已存在数据，便不会使用声明 vuex 模块时的初始 state 覆盖已有数据。但需要注意，若 state 中没有 namespace 相应数据却开启了此选项，Vuex 还是会报错。因此此处添加了一个输入参数 <code>isClientInitialRoute</code> ， 只有在客户端初次进入页面（可以使用服务器预取数据）时才开启 <code>preserveState</code> 选项。</p><h2 id="问题3-组件热更新时vuex-模块被销毁">问题3: 组件热更新时，Vuex 模块被销毁</h2><p>开发期间使用 HotModuleReplacementPlugin 和 vue-loader，若改变了 PageA.js 中的代码，会触发热更新。在 <a href="https://github.com/vuejs/vue-hot-reload-api/blob/master/src/index.js" target="_blank" rel="noopener">vue-hot-reload-api</a> 中，当使用 vue-hot-reload-api 的 <code>reload</code> 方法处理组件实例时，该实例会被销毁而后重新创建。<code>beforeDestroy</code> 中销毁了 Vuex 的 <code>page-a</code> 模块，却没有调用 <code>prepareVuex</code> 方法重新注册，因此热更新之后，使用该模块也会报错。</p><p>解决方案：</p><pre><code class="hljs diff">   asyncData(&#123; store &#125;) &#123;     return store.dispatch(`$&#123;VUEX_NS&#125;/fetchInventory`)   &#125;,<span class="hljs-deletion">-  beforeDestroy() &#123;</span><span class="hljs-deletion">-    // 销毁该模块</span><span class="hljs-deletion">-    this.$store.unregisterModule(VUEX_NS)</span><span class="hljs-addition">+  beforeRouteLeave(to, from, next) &#123;</span><span class="hljs-addition">+    this.$once('hook:beforeDestroy', () =&gt; &#123;</span><span class="hljs-addition">+      // 销毁该模块</span><span class="hljs-addition">+      this.$store.unregisterModule(VUEX_NS)</span><span class="hljs-addition">+    &#125;)</span><span class="hljs-addition">+    next()</span>   &#125; &#125;</code></pre><p>仔细想想，注册模块的时机是与路由相关的（进入页面之前），那么销毁的时机也可以与路由相关。不过并不适合在 <code>beforeRouteLeave</code> 钩子中立刻销毁模块。因为根据以下 vue-router 文档内容，在此钩子被调用完成时，整个页面还是在正常工作的（第2步到第11步中间），仍未进入组件的 destroy 过程，此时销毁模块会导致依赖其的所有组件异常。</p><blockquote><p><cite><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%AF%BC%E8%88%AA%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B" target="_blank" rel="noopener">vue-router 文档中关于导航解析流程的部分</a></cite></p><ol type="1"><li>导航被触发。</li><li>在失活的组件里调用离开守卫。</li><li>调用全局的 beforeEach 守卫。</li><li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li><li>在路由配置里调用 beforeEnter。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 beforeRouteEnter。</li><li>调用全局的 beforeResolve 守卫 (2.5+)。</li><li>导航被确认。</li><li>调用全局的 afterEach 钩子。</li><li>触发 DOM 更新。</li><li>用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</li></ol></blockquote><p>因此安全的模块销毁时机需要在 DOM 更新中或后，旧的页面组件实例销毁过程调用时。</p><h1 id="相关代码">相关代码</h1><p>最后的 PageA.js：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> PAGE_A_MODULE, &#123; VUEX_NS &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'store/modules/page-a'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">'PageA'</span>,  prepareVuex(&#123; store, isClientInitialRoute &#125;) &#123;    store.registerModule(VUEX_NS, PAGE_A_MODULE, &#123; <span class="hljs-attr">preserveState</span>: isClientInitialRoute &#125;)  &#125;,  asyncData(&#123; store &#125;) &#123;    <span class="hljs-keyword">return</span> store.dispatch(<span class="hljs-string">`<span class="hljs-subst">$&#123;VUEX_NS&#125;</span>/fetchInventory`</span>)  &#125;,  beforeRouteLeave(to, <span class="hljs-keyword">from</span>, next) &#123;    <span class="hljs-keyword">this</span>.$once(<span class="hljs-string">'hook:beforeDestroy'</span>, () =&gt; &#123;      <span class="hljs-comment">// 销毁该模块</span>      <span class="hljs-keyword">this</span>.$store.unregisterModule(VUEX_NS)    &#125;)    next()  &#125;&#125;</code></pre><p>两端的入口文件中相关代码如下：</p><pre><code class="hljs typescript"><span class="hljs-comment">// router-util.ts</span><span class="hljs-keyword">import</span> Vue, &#123; VueConstructor &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><span class="hljs-keyword">type</span> VueCtor = VueConstructor&lt;<span class="hljs-built_in">any</span>&gt;<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getHookFromComponent</span>(<span class="hljs-params">compo: <span class="hljs-built_in">any</span>, name: <span class="hljs-built_in">string</span></span>) </span>&#123;  <span class="hljs-keyword">return</span> compo[name] || (compo.options &amp;&amp; compo.options[name])&#125;<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callComponentsHookWith</span>(<span class="hljs-params">compoList: VueCtor[], hookName: <span class="hljs-built_in">string</span>, context: <span class="hljs-built_in">any</span></span>) </span>&#123;  <span class="hljs-keyword">return</span> compoList.map(<span class="hljs-function">(<span class="hljs-params">component</span>) =&gt;</span> &#123;    <span class="hljs-keyword">const</span> hook = getHookFromComponent(component, hookName)    <span class="hljs-keyword">if</span> (hook) &#123;      <span class="hljs-keyword">return</span> hook(context)    &#125;  &#125;).filter(_ =&gt; _)&#125;</code></pre><pre><code class="hljs js"><span class="hljs-comment">// entry-server.js</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> context =&gt; &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-comment">// set router's location</span>    router.push(context.url)    router.onReady(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      <span class="hljs-keyword">const</span> matchedComponents = router.getMatchedComponents()      <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 加上 try/catch 避免此 block 内抛出的错误造成 promise unhandledRejection</span>        callComponentsHookWith(matchedComponents, <span class="hljs-string">'prepareVuex'</span>, &#123; store &#125;)        <span class="hljs-keyword">const</span> asyncDataResults = callComponentsHookWith(matchedComponents, <span class="hljs-string">'asyncData'</span>,          &#123;            store,            <span class="hljs-attr">route</span>: router.currentRoute,          &#125;        )        <span class="hljs-built_in">Promise</span>.all(asyncDataResults).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;          context.state = store.state          resolve(app)        &#125;).catch(reject)      &#125; <span class="hljs-keyword">catch</span>(err) &#123;        reject(err)      &#125;    &#125;, reject)  &#125;)&#125;</code></pre><pre><code class="hljs js"><span class="hljs-comment">// entry-client.js</span>router.onReady(<span class="hljs-function">(<span class="hljs-params">initialRoute</span>) =&gt;</span> &#123;  <span class="hljs-keyword">const</span> initialMatched = router.getMatchedComponents(initialRoute)  callComponentsHookWith(initialMatched, <span class="hljs-string">'prepareVuex'</span>, &#123; store, <span class="hljs-attr">isClientInitialRoute</span>: <span class="hljs-literal">true</span> &#125;)  router.beforeResolve(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;    <span class="hljs-keyword">const</span> matched = router.getMatchedComponents(to)    callComponentsHookWith(matched, <span class="hljs-string">'prepareVuex'</span>, &#123; store &#125;)    <span class="hljs-built_in">Promise</span>.all(callComponentsHookWith(activated, <span class="hljs-string">'asyncData'</span>, &#123; store, <span class="hljs-attr">route</span>: to &#125;))      .then(next)      .catch(next)  &#125;)  <span class="hljs-comment">// actually mount to DOM</span>  app.$mount(<span class="hljs-string">'#app'</span>)&#125;)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;构建大型 SPA 应用时，代码分割和懒加载是比较常用的优化手段，在 Vue 生态下，使用 vue-router 很容易实现组件的懒加载。&lt;/p&gt;
&lt;p&gt;但应用里除了组件，还有庞大的业务逻辑，这部分如何分割和懒加载比较合适呢？&lt;/p&gt;

      
    
    </summary>
    
      <category term="前端" scheme="http://hikerpig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://hikerpig.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Try Rust WebAssembly</title>
    <link href="http://hikerpig.github.io/2018/05/03/2018-05-03-Try-Rust-Webassemly/"/>
    <id>http://hikerpig.github.io/2018/05/03/2018-05-03-Try-Rust-Webassemly/</id>
    <published>2018-05-02T16:00:00.000Z</published>
    <updated>2018-08-26T08:50:19.060Z</updated>
    
    <content type="html"><![CDATA[<p>在公司项目里的一个小角落，尝试使用 Rust + WebAssembly 加速应用里部分计算</p><h2 id="选择">选择</h2><p>首先要分清项目里 WebAssembly 的定位</p><ol type="1"><li>应用主体：完成绝大多数逻辑，JS 只作为加载入口和少部分事件绑定桥梁</li><li>工具库：分担一些复杂和耗时的计算，由 JS 决定什么时候调用 wasm 模块函数，通常情况下，由 JS 管理 wasm 的线性内存</li></ol><p>此次小 Demo 属于第 2 种情况</p><h3 id="选择-rust-target">选择 Rust Target</h3><p>rust 支持 <code>wasm32-unknown-unknown</code> 和 <code>wasm32-unknown-emscripten</code> 两种编译目标，后者除了wasm 外，还生成了 emscripten 风格的 JS 作为入口，与 asm.js 的调用风格统一。不过会添加好些运行时代码，与 wasm 之间也隔着一层封装。基于上一项的选择，我们选择前者</p><pre><code class="hljs bash">rustup target add wasm32-unknown-unknown</code></pre><h1 id="webassembly-考量">WebAssembly 考量</h1><h2 id="数据类型问题">数据类型问题</h2><p>WebAssembly 当前只支持几种<a href="https://developer.mozilla.org/en-US/docs/WebAssembly/Understanding_the_text_format#Signatures_and_parameters" target="_blank" rel="noopener">有限的数字类型</a>，i32/i64/f32/f64，JS 与之交互时，除了 number 以外的值都要有序列化/反序列化处理。</p><h3 id="字符串">字符串</h3><p>可使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/TextEncoder" target="_blank" rel="noopener">TextEncoder/TextDecoder</a> 将 JS 字符串序列化为 utf-8 字节流，在 Rust 端先将字节流解析为字符串，再使用。</p><h3 id="数组">数组</h3><p>JS 直接操作 wasm 示例的内存，将数组数据写入，调用 wasm 方法时，将数组起始的指针以及数组长度作为参数。</p><pre><code class="hljs rust"><span class="hljs-comment">// rust 部分</span><span class="hljs-keyword">pub</span> <span class="hljs-keyword">unsafe</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">load_image_data</span></span>(in_image_ptr: *<span class="hljs-keyword">mut</span> <span class="hljs-built_in">u8</span>, width: <span class="hljs-built_in">i32</span>, height: <span class="hljs-built_in">i32</span>) -\&gt; *<span class="hljs-keyword">const</span> <span class="hljs-built_in">u8</span> &#123;  <span class="hljs-keyword">let</span> arr_len = (width * height * <span class="hljs-number">4</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;  <span class="hljs-keyword">let</span> in_image_data = <span class="hljs-built_in">Vec</span>::from_raw_parts(in_image_ptr, arr_len, arr_len);  <span class="hljs-keyword">return</span> in_image_data.as_ptr();&#125;</code></pre><pre><code class="hljs ts"><span class="hljs-comment">// js 部分</span><span class="hljs-keyword">const</span> ctx = canvas.getContext(<span class="hljs-string">'2d'</span>)<span class="hljs-keyword">const</span> imageData = ctx.getImageData(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>)<span class="hljs-keyword">const</span> imgDataVecPtr = copyJsArrayToRust(<span class="hljs-keyword">this</span>.instanceExports, imageData.data)wasmExports.load_image_data(imgDataVecPtr, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>)<span class="hljs-string">`</span></code></pre><h2 id="上代码">上代码</h2><h3 id="rust-端">Rust 端</h3><pre><code class="hljs rust"><span class="hljs-comment">// main.rs</span><span class="hljs-keyword">use</span> std::&#123;mem&#125;;<span class="hljs-keyword">use</span> std::ffi::CString;<span class="hljs-keyword">use</span> std::os::raw::&#123;c_char&#125;;<span class="hljs-keyword">extern</span> &#123;  <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">clog</span></span>(ptr: *<span class="hljs-keyword">const</span> <span class="hljs-built_in">u8</span>, number: <span class="hljs-built_in">usize</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">js_log</span></span>(s: <span class="hljs-built_in">String</span>) &#123;  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> _s = s.clone();  <span class="hljs-keyword">unsafe</span> &#123;  <span class="hljs-keyword">let</span> m = _s.as_mut_vec().as_mut_ptr();  clog(m <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-built_in">u8</span>, _s.len());  &#125;&#125;<span class="hljs-meta">#[no_mangle]</span><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">alloc</span></span>(size: <span class="hljs-built_in">usize</span>) -&gt; *<span class="hljs-keyword">const</span> <span class="hljs-built_in">u8</span> &#123;  <span class="hljs-keyword">let</span> buf = <span class="hljs-built_in">Vec</span>::with_capacity(size);  <span class="hljs-keyword">let</span> ptr = buf.as_ptr();  mem::forget(buf); <span class="hljs-comment">// 让 rust 放弃对此段内存的控制权，此函数结束后该段内存对于 rust 来说是泄漏的状态，分配和管理权交给 JS</span>  <span class="hljs-keyword">return</span> ptr;&#125;<span class="hljs-meta">#[no_mangle]</span><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">log_something</span></span>(text_ptr: *<span class="hljs-keyword">mut</span> c_char) -&gt; *<span class="hljs-keyword">const</span> <span class="hljs-built_in">u8</span> &#123;  <span class="hljs-keyword">let</span> text = CString::from_raw(text_ptr).into_string().unwrap();  js_log(text);&#125;<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;&#125;  <span class="hljs-comment">// 留一个 main 确保 rust 能正常编译</span></code></pre><h3 id="js-端">JS 端</h3><pre><code class="hljs ts"><span class="hljs-comment">// wasm-util.ts</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> ModuleExports &#123;  memory: WebAssembly.Memory  alloc(len: <span class="hljs-built_in">number</span>): WasmMemPtr  log_something(text_ptr: <span class="hljs-built_in">number</span>)&#125;<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadWebAssembly</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">ModuleExports</span>&gt;(<span class="hljs-params">input: <span class="hljs-built_in">string</span>, imports: <span class="hljs-built_in">any</span></span>) </span>&#123;  <span class="hljs-comment">// Fetch the file and compile it</span>  <span class="hljs-keyword">return</span> fetch(input).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.arrayBuffer())  .then(<span class="hljs-function"><span class="hljs-params">buffer</span> =&gt;</span> &#123;    <span class="hljs-comment">// Create the imports for the module, including the</span>    <span class="hljs-comment">// standard dynamic library imports</span>    imports = imports || &#123;&#125;    imports.env = imports.env || &#123;&#125;    <span class="hljs-keyword">if</span> (!imports.env.memory) &#123;  imports.env.memory = <span class="hljs-keyword">new</span> WebAssembly.Memory(&#123; initial: <span class="hljs-number">1</span> &#125;)    &#125;    <span class="hljs-comment">// Create the instance.</span>    <span class="hljs-keyword">return</span> WebAssembly.instantiate(buffer, imports)  &#125;)&#125;<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copyJsStringToRust</span>(<span class="hljs-params"><span class="hljs-built_in">module</span>: ModuleExports, str: <span class="hljs-built_in">string</span></span>) </span>&#123;  <span class="hljs-keyword">const</span> utf8Encoder = <span class="hljs-keyword">new</span> TextEncoder()  <span class="hljs-keyword">const</span> string_buffer = utf8Encoder.encode(str)  <span class="hljs-keyword">const</span> len = string_buffer.length  <span class="hljs-keyword">const</span> ptr = <span class="hljs-built_in">module</span>.alloc(len + <span class="hljs-number">1</span>)  <span class="hljs-keyword">const</span> memory = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(<span class="hljs-built_in">module</span>.memory.buffer, ptr)  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;    memory[i] = string_buffer[i]  &#125;  memory[len] = <span class="hljs-number">0</span> <span class="hljs-comment">// cstring end</span>  <span class="hljs-keyword">return</span> ptr&#125;<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">decodeRustString</span>(<span class="hljs-params"><span class="hljs-built_in">module</span>: ModuleExports, ptr: WasmMemPtr</span>) </span>&#123;  <span class="hljs-keyword">const</span> collectCString = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">const</span> memory = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(<span class="hljs-built_in">module</span>.memory.buffer)  <span class="hljs-keyword">while</span> (memory[ptr] !== <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">if</span> (memory[ptr] === <span class="hljs-literal">undefined</span>) &#123;  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Tried to read undef mem'</span>)    &#125;    <span class="hljs-keyword">yield</span> memory[ptr]    ptr += <span class="hljs-number">1</span>  &#125;  &#125;  <span class="hljs-keyword">const</span> buffer_as_u8 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(collectCString())  <span class="hljs-keyword">const</span> utf8Decoder = <span class="hljs-keyword">new</span> TextDecoder()  <span class="hljs-keyword">const</span> buffer_as_utf8 = utf8Decoder.decode(buffer_as_u8)  <span class="hljs-keyword">return</span> buffer_as_utf8&#125;<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copyJsArrayToRust</span>(<span class="hljs-params">exports: ModuleExports, arr: <span class="hljs-built_in">number</span>[] | <span class="hljs-built_in">Uint8ClampedArray</span></span>) </span>&#123;  <span class="hljs-keyword">const</span> &#123; memory, alloc &#125; = exports  <span class="hljs-keyword">const</span> rVecPtr = alloc(arr.length)  <span class="hljs-keyword">const</span> asBytes = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(memory.buffer, rVecPtr, arr.length)  asBytes.set(arr)  <span class="hljs-keyword">return</span> rVecPtr&#125;</code></pre><p>demo.ts</p><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123;copyJsStringToRust, decodeRustString&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./wasm-util'</span><span class="hljs-keyword">const</span> importObj = &#123;  env: &#123;    clog: <span class="hljs-function">(<span class="hljs-params">ptr: WasmMemPtr, <span class="hljs-built_in">number</span>: <span class="hljs-built_in">number</span></span>) =&gt;</span> &#123;    <span class="hljs-keyword">const</span> str = decodeRustString(<span class="hljs-keyword">this</span>.rut.instanceExports, ptr)    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"[rust] "</span> + str)    &#125;,  &#125;&#125;loadWebAssembly(<span class="hljs-string">'demo.wasm'</span>).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-keyword">const</span> strPtr = copyJsStringToRust(wasmExports, <span class="hljs-string">'Heyhey you you'</span>)  wasmExports.log_something(strPtr)&#125;)<span class="hljs-comment">// '[rust] Heyhey you you'</span></code></pre><h2 id="编译-wasm">编译 WASM</h2><pre><code class="hljs bash">cargo rustc --release --target=wasm32-unknown-unknown</code></pre><h2 id="wasm-瘦身">WASM 瘦身</h2><p>参见<a href="https://rust-lang-nursery.github.io/rust-wasm/game-of-life/code-size.html" title="WASM 瘦身" target="_blank" rel="noopener">此文</a></p><h3 id="cargo.toml-中一些设定">Cargo.toml 中一些设定</h3><pre><code class="hljs undefined">[profile.release]debug = falselto = true</code></pre><h1 id="例子">例子</h1><ul><li><a href="https://www.hellorust.com/demos/" target="_blank" rel="noopener">Hello Rust</a></li><li>https://arkada38.github.io/2017/12/04/rust-wasm-string-to-uppercase/</li><li>https://stackoverflow.com/questions/49014610/passing-a-javascript-string-to-a-rust-function-compiled-to-webassembly</li><li><a href="https://kripken.github.io/blog/binaryen/2018/04/18/rust-emscripten.html" target="_blank" rel="noopener">Small WebAssembly Binaries with Rust + Emscripten</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在公司项目里的一个小角落，尝试使用 Rust + WebAssembly 加速应用里部分计算&lt;/p&gt;
&lt;h2 id=&quot;选择&quot;&gt;选择&lt;/h2&gt;
&lt;p&gt;首先要分清项目里 WebAssembly 的定位&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;应用主体：完成绝大多数逻辑，JS
      
    
    </summary>
    
      <category term="前端" scheme="http://hikerpig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="WebAssembly" scheme="http://hikerpig.github.io/tags/WebAssembly/"/>
    
      <category term="Rust" scheme="http://hikerpig.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>用 Jest 单元测试基于 Vue 的项目</title>
    <link href="http://hikerpig.github.io/2018/04/06/2018-04-06-Write-Vue-Tests-in-Jest/"/>
    <id>http://hikerpig.github.io/2018/04/06/2018-04-06-Write-Vue-Tests-in-Jest/</id>
    <published>2018-04-05T16:00:00.000Z</published>
    <updated>2018-08-26T08:50:26.662Z</updated>
    
    <content type="html"><![CDATA[<p>为一个基于 Vue 的项目搭建测试框架，有两个比较成熟的选择，Mocha + Webpack + Karma，或是 Jest。</p><p>前者也是 vue-cli 默认脚手架里的测试方案，我们之前的项目也用了它，实际使用起来，感觉成也 Karma，败也 Karma，配置起来不是很顺手，导致测试必须在完整打包后才能进行，测试时间随着用例增加飞速增长。而且调试单个测试用例的时候冷启动时间太长。</p><p>最后采用了功能强大的 Jest。</p><h2 id="写测试">写测试</h2><h3 id="测试-vue-组件">测试 Vue 组件</h3><p>参见 Vue Cookbook 中关于<a href="https://vuejs.org/v2/cookbook/unit-testing-vue-components.html" target="_blank" rel="noopener">单元测试</a>的一章，以及 <a href="https://vue-test-utils.vuejs.org/en/" target="_blank" rel="noopener">vue test-utils 的文档</a> 。</p><h3 id="拦截网络请求">拦截网络请求</h3><p>由于目前请求都通过 axios，可以简单地通过对 axios 对象的劫持来实现这一需求，考虑 <a href="https://github.com/ctimmerm/axios-mock-adapter" target="_blank" rel="noopener">axios-mock-adapter</a> 插件。</p><h3 id="拦截定时器">拦截定时器</h3><p>看Jest 文档的 <a href="https://facebook.github.io/jest/docs/en/timer-mocks.html" target="_blank" rel="noopener">Timer Mocks</a> 一章。</p><h3 id="自定义-mock">自定义 Mock</h3><p>采用 Jest 一方面是因为它具有很方便的 Mock 方案，框架会自动探测 <code>__mocks__</code> 文件夹中的文件，例如如果新建 <code>__mocks__/axios.js</code>，测试中所有源码的 <code>require('axios')</code> 返回的对象都会是该文件的导出内容。详见文档中的 <a href="https://facebook.github.io/jest/docs/en/manual-mocks.html" target="_blank" rel="noopener">Manual Mocks</a> 一章。</p><h2 id="调试测试">调试测试</h2><p>以在 VSCode 中 Debug 的配置为例，以下为 <code>.vscode/launch.json</code> 示例，参考文章<a href="https://segmentfault.com/a/1190000011852541" target="_blank" rel="noopener">《在VS Code中调试Jest单元测试》</a>：</p><pre><code class="hljs json">&#123;  <span class="hljs-attr">"version"</span>: <span class="hljs-string">"0.2.0"</span>,  <span class="hljs-attr">"configurations"</span>: [    &#123;      <span class="hljs-attr">"type"</span>: <span class="hljs-string">"node"</span>,      <span class="hljs-attr">"request"</span>: <span class="hljs-string">"launch"</span>,      <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Debug Current Jest Test"</span>,      <span class="hljs-attr">"program"</span>: <span class="hljs-string">"$&#123;workspaceRoot&#125;/node_modules/jest/bin/jest"</span>,      <span class="hljs-attr">"cwd"</span>: <span class="hljs-string">"$&#123;workspaceRoot&#125;"</span>,      <span class="hljs-attr">"env"</span>: &#123;        <span class="hljs-attr">"NODE_ENV"</span>: <span class="hljs-string">"test"</span>      &#125;,      <span class="hljs-attr">"args"</span>: [<span class="hljs-string">"--runInBand"</span>, <span class="hljs-string">"--env=jsdom"</span>, <span class="hljs-string">"$&#123;fileBasename&#125;"</span>],      <span class="hljs-attr">"runtimeArgs"</span>: [        <span class="hljs-string">"--inspect-brk"</span>,      ],      <span class="hljs-attr">"sourceMaps"</span>: <span class="hljs-literal">true</span>,      <span class="hljs-attr">"console"</span>: <span class="hljs-string">"integratedTerminal"</span>,      <span class="hljs-attr">"internalConsoleOptions"</span>: <span class="hljs-string">"neverOpen"</span>,    &#125;,    &#123;      <span class="hljs-attr">"type"</span>: <span class="hljs-string">"node"</span>,      <span class="hljs-attr">"request"</span>: <span class="hljs-string">"attach"</span>,      <span class="hljs-attr">"stopOnEntry"</span>: <span class="hljs-literal">false</span>,      <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Attach to node inspect-brk"</span>,      <span class="hljs-attr">"port"</span>: <span class="hljs-number">9229</span>    &#125;,  ]&#125;</code></pre><h3 id="使用-vscode-启动测试">使用 VSCode 启动测试</h3><p>args 中的 <code>--runInBand</code> 和 <code>--env=jsdom</code> 都是 Jest 的配置项，详细的可查阅 <a href="https://facebook.github.io/jest/docs/en/cli.html" target="_blank" rel="noopener">jest cli 文档</a></p><p><code>${fileBasename}</code> 为 VSCode 配置提供的变量，在此处表明只让 Jest 运行当前打开文件描述的用例。</p><h3 id="通过调试协议连接进程">通过调试协议连接进程</h3><p>可以不通过 VSCode，而是直接使用命令 <code>node --inspect=9229 --inspect-brk ./node_modules/.bin/jest  --runInBand</code> 运行 jest，</p><p>第二个配置(request 为 'attach')，连接一个开放 9229 为调试端口的已经在运行的 node 进程。</p><p>此种方式可选择其他实现了远程调试协议的IDE（例如 Webstorm）或浏览器（例如 <a href="https://zhuanlan.zhihu.com/p/30264842" target="_blank" rel="noopener">chrome://inspect</a> ）来实现断点调试等功能。</p><p>关于 Inspector 协议可看<a href="https://zhuanlan.zhihu.com/p/30264842" target="_blank" rel="noopener">此文章</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为一个基于 Vue 的项目搭建测试框架，有两个比较成熟的选择，Mocha + Webpack + Karma，或是 Jest。&lt;/p&gt;
&lt;p&gt;前者也是 vue-cli 默认脚手架里的测试方案，我们之前的项目也用了它，实际使用起来，感觉成也 Karma，败也 Karma，配置
      
    
    </summary>
    
      <category term="前端" scheme="http://hikerpig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Test" scheme="http://hikerpig.github.io/tags/Test/"/>
    
      <category term="Vue" scheme="http://hikerpig.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>在 Typescript 中继承 Error 对象</title>
    <link href="http://hikerpig.github.io/2018/04/02/2018-04-02-Customize-Error-in-Typescript/"/>
    <id>http://hikerpig.github.io/2018/04/02/2018-04-02-Customize-Error-in-Typescript/</id>
    <published>2018-04-01T16:00:00.000Z</published>
    <updated>2019-05-25T06:43:08.674Z</updated>
    
    <content type="html"><![CDATA[<p>通过 Typescript class 继承 Error 实现自定义错误类型并编译到 ES5 时，遇到了一个坑。</p><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> MyError <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Error</span> &#123;&#125;</code></pre><p>compilerOptions.target 设为 "es5"。</p><p>但是运行起来：</p><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> err = <span class="hljs-keyword">new</span> MyError()err <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span> <span class="hljs-comment">// true</span>err <span class="hljs-keyword">instanceof</span> MyError  <span class="hljs-comment">// 结果竟然是 false</span></code></pre><h2 id="原因">原因</h2><p>使用 Babel/Typescript 编译出的代码有类似的问题</p><p>Typescript 2.7.2 编译出的代码</p><pre><code class="hljs typescript"><span class="hljs-keyword">var</span> __extends = (<span class="hljs-keyword">this</span> &amp;&amp; <span class="hljs-keyword">this</span>.__extends) || (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> extendStatics = <span class="hljs-built_in">Object</span>.setPrototypeOf ||        (&#123; __proto__: [] &#125; <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span> &amp;&amp; <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">d, b</span>) </span>&#123; d.__proto__ = b; &#125;) ||        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">d, b</span>) </span>&#123; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> p <span class="hljs-keyword">in</span> b) <span class="hljs-keyword">if</span> (b.hasOwnProperty(p)) d[p] = b[p]; &#125;;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">d, b</span>) </span>&#123;        extendStatics(d, b);        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">this</span>.constructor = d; &#125;        d.prototype = b === <span class="hljs-literal">null</span> ? <span class="hljs-built_in">Object</span>.create(b) : (__.prototype = b.prototype, <span class="hljs-keyword">new</span> __());    &#125;;&#125;)();<span class="hljs-keyword">var</span> MyError = <span class="hljs-comment">/** @class */</span> (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_super</span>) </span>&#123;    __extends(MyError, _super);    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyError</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-comment">// 问题关键在这里</span>        <span class="hljs-keyword">return</span> _super !== <span class="hljs-literal">null</span> &amp;&amp; _super.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>) || <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-keyword">return</span> MyError;&#125;(<span class="hljs-built_in">Error</span>));</code></pre><p>原因在于，Error 是一个特殊的存在，即是一个构造函数，也是一个普通函数。以下两种调用皆可返回 error object。</p><pre><code class="hljs js"><span class="hljs-built_in">Error</span>(<span class="hljs-string">'message'</span>)<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'message'</span>)</code></pre><p>那么在调用以下函数时，_super 为 Error，返回的即是 <code>Error(this, arguments)</code>，而不是 <code>this</code> 。</p><pre><code class="hljs typescript">_super !== <span class="hljs-literal">null</span> &amp;&amp; _super.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>) || <span class="hljs-keyword">this</span>;</code></pre><h2 id="在-typescript-中">在 Typescript 中</h2><p>翻了翻文档，Typescript 2.1 的一些 <a href="https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work" target="_blank" rel="noopener">breaking change</a> 导致对于一些原生对象(Error/Array/Map)的继承无法正常工作，应该就是由 generated code 的改变造成的。官方给出的一个建议是：</p><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> FooError <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Error</span> &#123;  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">m: <span class="hljs-built_in">string</span></span>) &#123;    <span class="hljs-keyword">super</span>(m)    <span class="hljs-comment">// 在 super 之后立刻调用，改变实例的 prototype.</span>    <span class="hljs-built_in">Object</span>.setPrototypeOf(<span class="hljs-keyword">this</span>, FooError.prototype)  &#125;&#125;</code></pre><p>但是这个写法其实相当的傻，因为对于每一个子类的构建函数来说，在改变原型之前，是无法拿到正确的子类实例 'this.constructor' 的，所以 <code>Object.setPrototypeOf</code> 需要出现在所有子类的构建函数中。</p><h2 id="解决方案">解决方案</h2><p>只好把原型继承拿回来了，最终解决方案：</p><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ExtensibleError <span class="hljs-keyword">implements</span> <span class="hljs-built_in">Error</span> &#123;  message: <span class="hljs-built_in">string</span>  name: <span class="hljs-built_in">string</span>  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">message?: <span class="hljs-built_in">string</span></span>) &#123;    <span class="hljs-built_in">Error</span>.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>)    <span class="hljs-keyword">this</span>.message = message || <span class="hljs-string">''</span>    <span class="hljs-keyword">this</span>.name = <span class="hljs-keyword">this</span>.constructor.name    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Error</span>.captureStackTrace === <span class="hljs-string">'function'</span>) &#123;      <span class="hljs-built_in">Error</span>.captureStackTrace(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.constructor)    &#125;  &#125;&#125;ExtensibleError.prototype = <span class="hljs-built_in">Object</span>.create(<span class="hljs-built_in">Error</span>.prototype)</code></pre><p>构建一个中间的辅助类，并不直接采用 class 继承 Error，而只实现 Error 接口，采用原型继承，此类的示例可经过 <code>instanceOf</code> 的检验。通过 <code>Error.captureStackTrac</code> 在初始化此类实例时能够捕获调用栈。</p><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> MyError <span class="hljs-keyword">extends</span> ExtensibleError &#123;&#125;<span class="hljs-keyword">const</span> err = <span class="hljs-keyword">new</span> MyError()err <span class="hljs-keyword">instanceof</span> ExtensibleError  <span class="hljs-comment">// true</span>err <span class="hljs-keyword">instanceof</span> MyError  <span class="hljs-comment">// true</span>err <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span> <span class="hljs-comment">// true</span></code></pre><h3 id="如果编译目标为-es6-以上呢">如果编译目标为 ES6 以上呢？</h3><p>此时编译器就不需要去帮你转化 class 的实现了，会把你的代码原样输出:</p><p>之前的解决方案在 nodejs 中运行会报错：</p><pre><code class="hljs undefined">ExtensibleError.prototype = <span class="hljs-keyword">Object</span>.create(Error.prototype);                          ^TypeError: Cannot assign <span class="hljs-keyword">to</span> <span class="hljs-keyword">read</span> only <span class="hljs-keyword">property</span> <span class="hljs-string">'prototype'</span> <span class="hljs-keyword">of</span> <span class="hljs-function"><span class="hljs-keyword">function</span> '<span class="hljs-title">class</span> <span class="hljs-title">ExtensibleError</span>...</span></code></pre><p>因为使用 <code>class</code> 关键字声明的 <code>ExtensibleError</code> 是一个叫做类构造器（class constructor）的特殊函数，它的 prototype 是只读的，试图去改变它的话，只有报错（nodejs）和不生效两种可能。</p><p>以下的代码在现在的 chrome(V8) 和 firefox(SpiderMonkey) 引擎中执行结果都是一样。</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExtensibleError</span> </span>&#123;&#125;ExtensibleError.prototype = <span class="hljs-built_in">Object</span>.create(<span class="hljs-built_in">Error</span>.prototype);<span class="hljs-keyword">const</span> e = <span class="hljs-keyword">new</span> ExtensibleError;e <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span> <span class="hljs-comment">// false</span></code></pre><p>如果 target 是 ES6 以上的，简简单单写 <code>class ExtensibleError extends Error {}</code> 就行了。</p><p>参考</p><ul><li><a href="https://github.com/thundernet8/Blog/issues/1" target="_blank" rel="noopener">Error继承踩坑记</a></li><li><a href="https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work" target="_blank" rel="noopener">breaking change</a></li><li><a href="https://stackoverflow.com/questions/12915412/how-do-i-extend-a-host-object-e-g-error-in-typescript" target="_blank" rel="noopener">so 上的一个答案</a></li></ul>]]></content>
    
    <summary type="html">
    
      跨过 Error 继承的坑
    
    </summary>
    
      <category term="前端" scheme="http://hikerpig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://hikerpig.github.io/tags/Javascript/"/>
    
      <category term="Typescript" scheme="http://hikerpig.github.io/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>在 Typescript 中使用可被复用的 Vue Mixin</title>
    <link href="http://hikerpig.github.io/2018/01/21/2018-01-21-typed-vue-mixins/"/>
    <id>http://hikerpig.github.io/2018/01/21/2018-01-21-typed-vue-mixins/</id>
    <published>2018-01-20T16:00:00.000Z</published>
    <updated>2018-09-07T03:01:14.276Z</updated>
    
    <content type="html"><![CDATA[<p>转到用 Typescript 写 Vue 应用以后，经过一轮工具链和依赖的洗礼，总算蹒跚地能走起来了，不过有一个很常用的功能 mixin，似乎还没有官方的解决方案。</p><p>既想享受 mixin 的灵活和方便，又想收获 ts 的类型系统带来的安全保障和开发时使用 IntelliSense 的顺滑体验。</p><p>vuejs 官方组织里有一个 'vue-class-component' 以及连带推荐的 'vue-property-decorator'，都没有相应实现。翻了下前者的 issue，有一条挂了好些时间的待做 feature 就是 mixin 的支持。</p><p>也不是什么复杂的事，自己写一个吧。</p><blockquote><p>后注：vue-class-component 6.2.0 开始提供 <a href="https://github.com/vuejs/vue-class-component/commit/cdcbfe5bb1a4c9d59a4b3066477f49c9aae8e2fc" target="_blank" rel="noopener">mixins</a> 方法，和本文的实现思路相似。</p></blockquote><h1 id="实现">实现</h1><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> Vue, &#123; VueConstructor &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> VClass&lt;T&gt; = &#123;  <span class="hljs-keyword">new</span>(): T&#125; &amp; Pick&lt;VueConstructor, keyof VueConstructor&gt;<span class="hljs-comment">/** * mixins for class style vue component */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Mixins</span>&lt;<span class="hljs-title">A</span>&gt;(<span class="hljs-params">c: VClass&lt;A&gt;</span>): <span class="hljs-title">VClass</span>&lt;<span class="hljs-title">A</span>&gt;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Mixins</span>&lt;<span class="hljs-title">A</span>, <span class="hljs-title">B</span>&gt;(<span class="hljs-params">c: VClass&lt;A&gt;, c1: VClass&lt;B&gt;</span>): <span class="hljs-title">VClass</span>&lt;<span class="hljs-title">A</span>&amp;<span class="hljs-title">B</span>&gt;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Mixins</span>&lt;<span class="hljs-title">A</span>, <span class="hljs-title">B</span>, <span class="hljs-title">C</span>&gt;(<span class="hljs-params">c: VClass&lt;A&gt;, c1: VClass&lt;B&gt;, c2: VClass&lt;C&gt;</span>): <span class="hljs-title">VClass</span>&lt;<span class="hljs-title">A</span>&amp;<span class="hljs-title">B</span>&amp;<span class="hljs-title">C</span>&gt;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Mixins</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">c: VClass&lt;T&gt;, ...traits: <span class="hljs-built_in">Array</span>&lt;VClass&lt;T&gt;&gt;</span>): <span class="hljs-title">VClass</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;  <span class="hljs-title">return</span> <span class="hljs-title">c</span>.<span class="hljs-title">extend</span>(<span class="hljs-params">&#123;    mixins: traits  &#125;</span>)&#125;</span></span></span></code></pre><p>声明 <code>VClass&lt;T&gt;</code> 可作为 T 的类构造器。同时通过 <code>Pick</code> 拿到 Vue 的构造器上的静态方法（extend/mixin 之类），如此才能够支持下面这段中的真正实现，通过调用一个 Vue 的子类构造器上的 <code>extend</code> 方法生成新的子类构造器。</p><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Mixins</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">c: VClass&lt;T&gt;, ...traits: <span class="hljs-built_in">Array</span>&lt;VClass&lt;T&gt;&gt;</span>): <span class="hljs-title">VClass</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;  <span class="hljs-keyword">return</span> c.extend(&#123;    mixins: traits  &#125;)&#125;</code></pre><p>至于 ABC 这个纯粹是类型声明的体力活了。</p><h1 id="使用">使用</h1><p>实际使用时:</p><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; Component, Vue &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-property-decorator'</span><span class="hljs-keyword">import</span> &#123; Mixins &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'../../util/mixins'</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">class</span> PageMixin <span class="hljs-keyword">extends</span> Vue &#123;  title = <span class="hljs-string">'Test Page'</span>  redirectTo(path: <span class="hljs-built_in">string</span>) &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'calling reidrectTo'</span>, path)    <span class="hljs-keyword">this</span>.$router.push(&#123; path &#125;)  &#125;&#125;<span class="hljs-keyword">interface</span> IDisposable &#123;  dispose(...args: <span class="hljs-built_in">any</span>[]): <span class="hljs-built_in">any</span>&#125;<span class="hljs-meta">@Component</span><span class="hljs-keyword">class</span> DisposableMixin <span class="hljs-keyword">extends</span> Vue &#123;  _disposables: IDisposable[]  created() &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'disposable mixin created'</span>);    <span class="hljs-keyword">this</span>._disposables = []  &#125;  beforeDestroy() &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'about to clear disposables'</span>)    <span class="hljs-keyword">this</span>._disposables.map(<span class="hljs-function">(<span class="hljs-params">d</span>) =&gt;</span> &#123;      d.dispose()    &#125;)    <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._disposables  &#125;  registerDisposable(d: IDisposable) &#123;    <span class="hljs-keyword">this</span>._disposables.push(d)  &#125;&#125;<span class="hljs-meta">@Component</span>(&#123;  template: <span class="hljs-string">`  &lt;div&gt;    &lt;h1&gt;&#123;&#123; title &#125;&#125;&lt;/h1&gt;    &lt;p&gt;Counted: &#123;&#123; counter &#125;&#125;&lt;/p&gt;  &lt;/div&gt;  `</span>&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> TimerPage <span class="hljs-keyword">extends</span> Mixins(PageMixin, DisposableMixin) &#123;  counter = <span class="hljs-number">0</span>  mounted() &#123;    <span class="hljs-keyword">const</span> timer = setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.counter++ &gt;= <span class="hljs-number">3</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.redirectTo(<span class="hljs-string">'/otherpage'</span>)      &#125;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'count to'</span>, <span class="hljs-keyword">this</span>.counter);    &#125;, <span class="hljs-number">1000</span>)    <span class="hljs-keyword">this</span>.registerDisposable(&#123;      dispose() &#123;        clearInterval(timer)      &#125;    &#125;)  &#125;&#125;</code></pre><pre><code class="hljs undefined">count to 1count to 2count to 3calling reidrectTo /otherpageabout to clear disposables</code></pre><p>注意到直接 <code>extends Vue</code> 的 <code>DisposableMixin</code> 并不是一个有效的 Vue 组件，也不可以直接在 <code>mixins</code> 选项里使用，如果要被以 <code>Vue.extend</code> 方式扩展的自定义组件使用，记住使用 <code>Component</code> 包装一层。</p><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> ExtendedComponent = Vue.extend(&#123;  name: <span class="hljs-string">'ExtendedComponent'</span>,  mixins: [Component(DisposableMixin)],&#125;)</code></pre><h1 id="abstract-class">Abstract class</h1><p>在业务系统中，多数情况需求下会更复杂，提供一些基础功能，但有些部分需要留给继承者自行实现，这个时候使用抽象类就很合适。</p><h2 id="直接继承">直接继承</h2><pre><code class="hljs typescript"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> AbstractMusicPlayer <span class="hljs-keyword">extends</span> Vue &#123;  <span class="hljs-keyword">abstract</span> audioSrc: <span class="hljs-built_in">string</span>    playing = <span class="hljs-literal">false</span>    togglePlay() &#123;    <span class="hljs-keyword">this</span>.playing = !<span class="hljs-keyword">this</span>.playing  &#125;&#125;<span class="hljs-meta">@Component</span><span class="hljs-keyword">class</span> MusicPlayerA <span class="hljs-keyword">extends</span> AbstractMusicPlayer &#123;  audioSrc = <span class="hljs-string">'/audio-a.mp3'</span>&#125;<span class="hljs-meta">@Component</span><span class="hljs-keyword">class</span> MusicPlayerB <span class="hljs-keyword">extends</span> AbstractMusicPlayer &#123;  staticBase = <span class="hljs-string">'/statics'</span>  <span class="hljs-keyword">get</span> audioSrc() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;this.staticBase&#125;</span>/audio-b.mp3`</span>  &#125;&#125;</code></pre><h2 id="使用-mixins">使用 Mixins</h2><h3 id="坏方法欺骗以及注释">坏方法：欺骗，以及注释</h3><p>但抽象类是无法被实例化的，并不满足 <code>{ new(): T }</code> 这个要求，因此只能被继承，而<strong>不能</strong>被混入，由于同样的原因，抽象类也无法被 'vue-class-component' 的 <code>Component</code> 函数装饰。</p><p>这时候只好将实现了的功能写入 Mixin 中，待实现的功能放到接口里，让具体类来实现。</p><pre><code class="hljs typescriptvue-class-component">interface IMusicSourceProvider &#123;  audioSrc: string&#125;/** * 需要实现 IPlayerImplementation */@Componentclass PlayerMixin extends Vue &#123;  /** @abstract 必须实现 */  audioSrc: string  logSrc() &#123;    console.log(this.audioSrc)  &#125;&#125;interface IPlayerImplementation extends IMusicSourceProvider &#123;&#125;@Componentclass OtherMixin extends Vue &#123;  description = &apos;另一个 Mixin&apos;&#125;@Componentclass RealPlayer extends Mixins(PlayerMixin, OtherMixin) implements IPlayerImplementation &#123;  audioSrc = &apos;/audio-c.mp3&apos;&#125;// 无法正常工作@Componentclass BrokenPlayer extends Mixins(PlayerMixin, OtherMixin) &#123;&#125;</code></pre><p>鉴于 <code>@Component</code> 装饰器的实现方式，这种欺骗编译器的方式其实还是比较拙劣的。</p><p>如果一个具体类继承了 <code>PlayerMixin</code>，却没有使用 getter 或 property initializer 实现 <code>audioSrc</code> 这个属性，编译器无法告诉你这个错误（不开启严格模式的情况下），但实际使用中 <code>audioSrc</code> 其实是没有被初始化的，你会发现 <code>BrokenPlayer</code> 的实例当中 <code>_data</code> 里并不包含 <code>audioSrc</code>，即便在实例化后手动设置该值，Vue 也无法监听到该值的变化，会造成一些比较隐秘的 bug。</p><p>我们只能在代码里小心翼翼写上注释，期待使用者不要忘了这件事。</p><p>也可以执行一些开发时候的额外检查，如下：</p><h4 id="自定义装饰器-abstractproperty">自定义装饰器 AbstractProperty</h4><p>vue-class-component 提供了 <a href="https://github.com/vuejs/vue-class-component#create-custom-decorators" target="_blank" rel="noopener">createDecorator</a> 方法来创建其体系下的自定义装饰器，我们可以这么用：</p><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; createDecorator &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-class-component'</span><span class="hljs-comment">// 一个什么都不做的装饰器，在 production 环境下启用。不使用 createDecorator</span><span class="hljs-keyword">const</span> HolderDecorator = <span class="hljs-function">(<span class="hljs-params">ctor: <span class="hljs-built_in">any</span></span>) =&gt;</span> ctor<span class="hljs-comment">/** * Only for vue-class-component decorated class */</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> AbstractProperty = isProduction ? HolderDecorator:createDecorator(<span class="hljs-function">(<span class="hljs-params">options, key</span>) =&gt;</span> &#123;  <span class="hljs-keyword">const</span> originCreated = options.created  options.created = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">if</span> (originCreated) originCreated.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>)    <span class="hljs-keyword">if</span> (!(key <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>)) &#123;      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">`未实现 AbstractProperty '<span class="hljs-subst">$&#123;key&#125;</span>'`</span>)    &#125;  &#125;&#125;)<span class="hljs-meta">@Component</span><span class="hljs-keyword">class</span> PlayerMixin <span class="hljs-keyword">extends</span> Vue &#123;  <span class="hljs-meta">@AbstractProperty</span>  audioSrc: <span class="hljs-built_in">string</span>  logSrc() &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.audioSrc)  &#125;&#125;<span class="hljs-meta">@Component</span><span class="hljs-keyword">class</span> BrokenPlayer <span class="hljs-keyword">extends</span> Mixins(PlayerMixin, OtherMixin) &#123;&#125;<span class="hljs-keyword">const</span> player = <span class="hljs-keyword">new</span> BrokenPlayer<span class="hljs-comment">// 未实现 AbstractProperty 'audioSrc'</span></code></pre><h3 id="没那么坏的方法中间类">没那么坏的方法：中间类</h3><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span><span class="hljs-keyword">class</span> _PlayerImpl <span class="hljs-keyword">extends</span> AbstractMusicPlayer &#123;  audioSrc = <span class="hljs-string">'/audio-d.mp3'</span>&#125;<span class="hljs-meta">@Component</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> RealPlayer2 <span class="hljs-keyword">extends</span> Mixins(_PlayerImpl, OtherMixin) &#123;&#125;</code></pre><p>使用中间类 <code>_PlayerImpl</code> 来实现抽象类的抽象部分，然后再被真正的使用者 <code>RealPlayer2</code> 使用。啰嗦了一点，但是类型安全。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转到用 Typescript 写 Vue 应用以后，经过一轮工具链和依赖的洗礼，总算蹒跚地能走起来了，不过有一个很常用的功能 mixin，似乎还没有官方的解决方案。&lt;/p&gt;
&lt;p&gt;既想享受 mixin 的灵活和方便，又想收获 ts 的类型系统带来的安全保障和开发时使用 In
      
    
    </summary>
    
      <category term="前端" scheme="http://hikerpig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Typescript" scheme="http://hikerpig.github.io/tags/Typescript/"/>
    
      <category term="Vue" scheme="http://hikerpig.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>ES6 Class 和 Babel 6 在 IE &lt;= 10 时候的一个坑</title>
    <link href="http://hikerpig.github.io/2017/09/25/2017-09-25-ES6+Babel-little-bug-under-IE11/"/>
    <id>http://hikerpig.github.io/2017/09/25/2017-09-25-ES6+Babel-little-bug-under-IE11/</id>
    <published>2017-09-24T16:00:00.000Z</published>
    <updated>2018-08-26T08:51:33.168Z</updated>
    
    <content type="html"><![CDATA[<p>写 ES6+ 一定逃不开 babel，也避不开调试 babel 生成的一些代码。</p><p>当输入一段 ES6 Class 代码时:</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;  <span class="hljs-keyword">static</span> baseName = <span class="hljs-string">'Person'</span>  <span class="hljs-keyword">static</span> speakForAll() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.baseName  &#125;  speak() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello'</span>  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Developer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;&#125;<span class="hljs-keyword">const</span> myself = <span class="hljs-keyword">new</span> Developer()<span class="hljs-built_in">console</span>.log(myself.speak() === <span class="hljs-string">'Hello'</span>) <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(Person.speakForAll() === <span class="hljs-string">'Person'</span>) <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(Developer.speakForAll() === <span class="hljs-string">'Person'</span>) <span class="hljs-comment">// true</span></code></pre><h1 id="问题">问题</h1><p>在开发常用的浏览器 Chrome 和 Firefox 里正常工作，但是在 IE10 下会报错 <code>Uncaught TypeError: Developer.speakForAll is not a function</code></p><h2 id="刨根问底">刨根问底</h2><p><code>.babelrc</code> 配置如下:</p><pre><code class="hljs json">&#123;  <span class="hljs-attr">"presets"</span>: [<span class="hljs-string">"es2015"</span>, <span class="hljs-string">"stage-2"</span>],&#125;</code></pre><p>看 babel 编译出的一串代码 blahblah， 重点下面说:</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> _class, _temp<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_possibleConstructorReturn</span>(<span class="hljs-params">self, call</span>) </span>&#123;  <span class="hljs-keyword">if</span> (!self) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ReferenceError</span>(      <span class="hljs-string">"this hasn't been initialised - super() hasn't been called"</span>,    )  &#125;  <span class="hljs-keyword">return</span> call &amp;&amp; (<span class="hljs-keyword">typeof</span> call === <span class="hljs-string">'object'</span> || <span class="hljs-keyword">typeof</span> call === <span class="hljs-string">'function'</span>)    ? call    : self&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_inherits</span>(<span class="hljs-params">subClass, superClass</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> superClass !== <span class="hljs-string">'function'</span> &amp;&amp; superClass !== <span class="hljs-literal">null</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(      <span class="hljs-string">'Super expression must either be null or a function, not '</span> +        <span class="hljs-keyword">typeof</span> superClass,    )  &#125;  subClass.prototype = <span class="hljs-built_in">Object</span>.create(superClass &amp;&amp; superClass.prototype, &#123;    <span class="hljs-attr">constructor</span>: &#123;      <span class="hljs-attr">value</span>: subClass,      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,      <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,      <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,    &#125;,  &#125;)  <span class="hljs-keyword">if</span> (superClass)    <span class="hljs-built_in">Object</span>.setPrototypeOf      ? <span class="hljs-built_in">Object</span>.setPrototypeOf(subClass, superClass)      : (subClass.__proto__ = superClass)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_classCallCheck</span>(<span class="hljs-params">instance, Constructor</span>) </span>&#123;  <span class="hljs-keyword">if</span> (!(instance <span class="hljs-keyword">instanceof</span> Constructor)) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'Cannot call a class as a function'</span>)  &#125;&#125;<span class="hljs-keyword">var</span> Person = ((_temp = _class = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;    _classCallCheck(<span class="hljs-keyword">this</span>, Person)  &#125;  Person.speakForAll = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">speakForAll</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.baseName  &#125;  Person.prototype.speak = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">speak</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello'</span>  &#125;  <span class="hljs-keyword">return</span> Person&#125;)()),(_class.baseName = <span class="hljs-string">'Person'</span>),_temp)<span class="hljs-keyword">var</span> Developer = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">_Person</span>) </span>&#123;  _inherits(Developer, _Person)  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Developer</span>(<span class="hljs-params"></span>) </span>&#123;    _classCallCheck(<span class="hljs-keyword">this</span>, Developer)    <span class="hljs-keyword">return</span> _possibleConstructorReturn(<span class="hljs-keyword">this</span>, _Person.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>))  &#125;  <span class="hljs-keyword">return</span> Developer&#125;)(Person)<span class="hljs-keyword">var</span> myself = <span class="hljs-keyword">new</span> Developer()<span class="hljs-built_in">console</span>.log(myself.speak() === <span class="hljs-string">'Hello'</span>)<span class="hljs-built_in">console</span>.log(Person.speakForAll() === <span class="hljs-string">'Person'</span>)<span class="hljs-built_in">console</span>.log(Developer.speakForAll() === <span class="hljs-string">'Person'</span>)</code></pre><p>关键是此段实现继承的部分:</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_inherits</span>(<span class="hljs-params">subClass, superClass</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> superClass !== <span class="hljs-string">'function'</span> &amp;&amp; superClass !== <span class="hljs-literal">null</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(      <span class="hljs-string">'Super expression must either be null or a function, not '</span> +        <span class="hljs-keyword">typeof</span> superClass,    )  &#125;  subClass.prototype = <span class="hljs-built_in">Object</span>.create(superClass &amp;&amp; superClass.prototype, &#123;    <span class="hljs-attr">constructor</span>: &#123;      <span class="hljs-attr">value</span>: subClass,      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,      <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,      <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,    &#125;,  &#125;)  <span class="hljs-keyword">if</span> (superClass)    <span class="hljs-built_in">Object</span>.setPrototypeOf      ? <span class="hljs-built_in">Object</span>.setPrototypeOf(subClass, superClass)      : (subClass.__proto__ = superClass)&#125;</code></pre><p><code>subClass.prototype</code> 这一段比较简单，操作原型链来实现实例方法和属性的继承。顺带还用 object descriptor 重写了 <code>constructor</code> 这一属性，调用 <code>myself.constructor</code> 时才会拿到正确的值 <code>Developer</code>，而不是 <code>Person</code>。</p><p>接下来的一段比较有趣。</p><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.setPrototypeOf(subClass, superClass)</code></pre><p>这个写法还是比较讨巧的，将父类的构造函数 <code>superClass</code> 作为子类构造函数 <code>subClass</code> 的原型。</p><h1 id="知识回顾">知识回顾</h1><h2 id="object.setprototypeof">Object.setPrototypeOf</h2><p>这是个 <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-object.setprototypeof" target="_blank" rel="noopener">ES2015</a> 新提出的函数，函数签名：</p><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.setPrototypeOf(obj, prototype)</code></pre><p>对比 <code>Object.create</code>，可以在对象创建出来之后替换其原型。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = &#123;&#125;<span class="hljs-built_in">Object</span>.setPrototypeOf(p1, Person.prototype)<span class="hljs-built_in">console</span>.log(p1.speak()) <span class="hljs-comment">// 为'Hello'</span></code></pre><p>浏览器兼容性</p><table><thead><tr class="header"><th>Feature</th><th>Chrome</th><th>Edge</th><th>Firefox</th><th>IE</th><th>Opera</th><th>Safari</th></tr></thead><tbody><tr class="odd"><td>Basic Support</td><td>34</td><td>(Yes)</td><td>31</td><td>11</td><td>(Yes)</td><td>9</td></tr></tbody></table><p>注意到从 IE11 才开始支持此方法。</p><p>既然第一条路行不通，那就第二条呗。</p><h2 id="proto__"><code>__proto__</code></h2><p><code>_inherits</code> 函数中回退到 <code>subClass.__proto__ = superClass</code>。<code>__proto__</code> 指向的是对象构造函数的 <code>prototype</code>，通过重设 <code>subClass</code> 的原型来使其获得父类构造函数上的方法(此例中是 class 上的静态方法)。</p><p>关键在于，<code>__proto__</code> 是个非标准的属性，根据<a href="https://docs.microsoft.com/en-us/scripting/javascript/reference/proto-property-object-javascript" target="_blank" rel="noopener">微软的文档</a>，IE10 及其以下都没有支持。</p><blockquote><p>Not supported in the following document modes: Quirks, Internet Explorer 6 standards, Internet Explorer 7 standards, Internet Explorer 8 standards, Internet Explorer 9 standards, Internet Explorer 10 standards. Not supported in Windows 8.</p></blockquote><p><a href="https://github.com/babel/babel/issues/3041" target="_blank" rel="noopener">Babel 的一个 issue</a> 中有人提过类似问题，回答是：babel 6 不考虑兼容 IE。没碰上问题算幸运，碰上问题只好自己解决。</p><h1 id="解决方案">解决方案</h1><p>就这个事情来说，添加一个 polyfill 能够解决。以 <a href="https://github.com/wesleytodd/setprototypeof" target="_blank" rel="noopener">这个实现</a> 来说:</p><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">Object</span>.setPrototypeOf || (&#123;<span class="hljs-attr">__proto__</span>:[]&#125; <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span> ? setProtoOf : mixinProperties);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setProtoOf</span>(<span class="hljs-params">obj, proto</span>) </span>&#123;  obj.__proto__ = proto;  <span class="hljs-keyword">return</span> obj;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mixinProperties</span>(<span class="hljs-params">obj, proto</span>) </span>&#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> prop <span class="hljs-keyword">in</span> proto) &#123;    <span class="hljs-keyword">if</span> (!obj.hasOwnProperty(prop)) &#123;      obj[prop] = proto[prop];    &#125;  &#125;  <span class="hljs-keyword">return</span> obj;&#125;</code></pre><p>先探测 Object 上是否原生支持，然后检测更改 <code>__proto__</code> 是否有作用，最后回退到简单暴力的遍历赋值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写 ES6+ 一定逃不开 babel，也避不开调试 babel 生成的一些代码。&lt;/p&gt;
&lt;p&gt;当输入一段 ES6 Class 代码时:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs js&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="Javascript" scheme="http://hikerpig.github.io/tags/Javascript/"/>
    
      <category term="Babel" scheme="http://hikerpig.github.io/tags/Babel/"/>
    
  </entry>
  
  <entry>
    <title>使用 Object.create(null) 创建空对象</title>
    <link href="http://hikerpig.github.io/2017/09/07/2017-09-07-Using-Object.create/"/>
    <id>http://hikerpig.github.io/2017/09/07/2017-09-07-Using-Object.create/</id>
    <published>2017-09-06T16:00:00.000Z</published>
    <updated>2018-08-26T08:51:38.530Z</updated>
    
    <content type="html"><![CDATA[<p>使用对象字面量形式时，隐式地创建了一个以 <code>Object.prototype</code> 作为原型的对象。</p><p>以下两种方式等同。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> o1 = &#123;&#125;<span class="hljs-keyword">var</span> o2 = <span class="hljs-built_in">Object</span>.create(<span class="hljs-built_in">Object</span>.prototype)</code></pre><h2 id="更省事的方法">更省事的方法</h2><pre><code class="hljs js"><span class="hljs-keyword">var</span> o3 = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>)</code></pre><p>创建一个不继承任何原型的对象。</p><p>如果需要创建一个简单的 map 性质的对象，使用此种方式，在对 <code>o3</code> 进行遍历的时候，就可以躲开充满恶意的世界在 <code>Object.prototype</code> 上添加的方法或属性。</p><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> k <span class="hljs-keyword">in</span> o1) &#123;  <span class="hljs-keyword">if</span> (o1.hasOwnProperty(k)) &#123;  &#125;&#125;<span class="hljs-comment">// 遍历时不需要判断 hasOwnProperty</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> k <span class="hljs-keyword">in</span> o3) &#123;&#125;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用对象字面量形式时，隐式地创建了一个以 &lt;code&gt;Object.prototype&lt;/code&gt; 作为原型的对象。&lt;/p&gt;
&lt;p&gt;以下两种方式等同。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs js&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;va
      
    
    </summary>
    
      <category term="前端" scheme="http://hikerpig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://hikerpig.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>给开发减压的 gulp.watch 配置</title>
    <link href="http://hikerpig.github.io/2017/08/22/2017-08-22-gulp-watch-for-poor-cpu/"/>
    <id>http://hikerpig.github.io/2017/08/22/2017-08-22-gulp-watch-for-poor-cpu/</id>
    <published>2017-08-21T16:00:00.000Z</published>
    <updated>2018-08-26T08:51:43.865Z</updated>
    
    <content type="html"><![CDATA[<p>Gulp 的文件监听使用了 <a href="https://github.com/shama/gaze" target="_blank" rel="noopener">gaze</a>，如果只看了 Gulp 的 API 文档可能会漏掉一些参数。</p><p><a href="https://github.com/gulpjs/gulp/blob/master/docs/API.md" target="_blank" rel="noopener">Gulp 文档</a> 中提到:</p><p><code>gulp.watch(glob[, opts], tasks)</code></p><pre><code class="hljs undefined">optsType: ObjectOptions, that are passed to gaze.</code></pre><p>options 包括:</p><ul><li><code>interval</code> {integer} Interval to pass to fs.watchFile</li><li><code>debounceDelay</code> {integer} Delay for events called in succession for the same file/event in milliseconds</li><li><code>mode</code> {string} Force the watch mode. Either 'auto' (default), 'watch' (force native events), or 'poll' (force stat polling).</li><li><code>cwd</code> {string} The current working directory to base file patterns from. Default is process.cwd()</li></ul><p>gaze 的设置参数中，感觉最有用却被遗漏的就是 <code>interval</code> 了，好多人提到 <a href="https://github.com/gulpjs/gulp/issues/634" target="_blank" rel="noopener">gulp.watch CPU 占用太高</a>，因为 gaze 默认 100ms 检查监听的文件状态。</p><p>如果监听文件太多导致 CPU 占用居高不下的话，可以考虑加大 <code>interval</code>:</p><pre><code class="hljs js">gulp.watch(blob, &#123;<span class="hljs-attr">interval</span>: <span class="hljs-number">500</span>&#125;, tasks)</code></pre><p>笔记本就不会呼呼乱叫了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Gulp 的文件监听使用了 &lt;a href=&quot;https://github.com/shama/gaze&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gaze&lt;/a&gt;，如果只看了 Gulp 的 API 文档可能会漏掉一些参数。&lt;/p&gt;
&lt;p&gt;&lt;a hre
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Holy Awesome Spacemacs</title>
    <link href="http://hikerpig.github.io/2017/08/05/2017-08-05-Holy-Awesome-Spacemacs/"/>
    <id>http://hikerpig.github.io/2017/08/05/2017-08-05-Holy-Awesome-Spacemacs/</id>
    <published>2017-08-04T16:00:00.000Z</published>
    <updated>2018-08-26T08:51:51.720Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://spacemacs.org/img/logo.svg"></p><p>很久以前看 SICP 的时候尝试在 windows 下使用 emacs 时受到了惊吓，那刀耕火种一般的界面啊。后来在 Ubuntu 终端中打开，诶？怎么关不掉？不掉？掉？（其实 Vim 也一样，小白终结者）</p><p>但是看完<a href="https://www.zhihu.com/question/29692328" target="_blank" rel="noopener">如何评价 Emacs 的配置文件 Spacemacs？</a>以及身边多人的安利后，心痒痒地尝试了下，从一个外行人眼里看来，简直是 Emacs 界的一股清流，史诗级的配置工程。</p><h1 id="安装">安装</h1><p>鉴于有 Every thing in Emacs 的传统，选择了可以不光在终端里使用，便安装了带有 Mac GUI 系统支持的 Emacs：</p><pre><code class="hljs undefined">brew install emacs --with-cocoa</code></pre><h2 id="spacemacs">Spacemacs</h2><p>完全没有历史的 <code>.emacs.d</code> 包袱，一键安装</p><pre><code class="hljs undefined">git clone https://github.com/syl20bnr/spacemacs ~/.emacs.d</code></pre><h1 id="开始使用">开始使用</h1><p>还想说打开速度果然比 Vim 慢了不少，但是慢慢使用着发现，考虑到这些巨量的功能以及超棒的体验来说，等得太值了。重点是，<strong>开箱即用</strong>。</p><p>选择了 Setup Guile 中提示了相对较重的 <code>helm</code> layer，以及开了其他七八个 layer。不考虑首次安装插件的时间，之后平均启动时间在15秒内。</p><p>然后开始领教 Emacs 的能量：</p><h1 id="org-mode">org-mode</h1><p>江湖相传能用于<a href="http://docs.huihoo.com/open-source/guide/ch32.html" target="_blank" rel="noopener">组织你的意念</a>的“文档/知识/日程/<del>人生</del>管理工具”，神级插件。</p><p>在这之前，使用 <a href="http://vimwiki.github.io" target="_blank" rel="noopener">Vimwiki</a> 管理个人知识，在 Vim 里的表现也是很棒的，但是折腾起来总有几点不甚满意，但在 org-mode 下找到了完美的解决方案。</p><h2 id="文档转换">文档转换</h2><p>在 Markdown 大行其道的今天，还需要单独去记忆 Vimwiki 自己的语法，有时候转不过弯来。还有，有时候一些收集性质的笔记，需要从 html 转换过来，Vimwiki 在这方面相关工具比较匮乏。</p><p><code>org-mode</code> 虽说也是自成一派的语法，但是相关工具链非常完善，与各种文档格式互转毫无压力，例如 <a href="https://github.com/fasheng/vimwiki2org" target="_blank" rel="noopener">vimwiki2org</a>。</p><p>当需要集成现有工具到编辑器里时，一边是定义清晰、文档完善、继承了 Lisp 系美感的 Emacs Lisp ，和时常让人呼唤神兽的 Vim Script。</p><h2 id="代码块支持">代码块支持</h2><p>在 Vimwiki 里插入和查阅代码块的体验，纯粹而贫乏。</p><p>同样一个 python 代码块，在 Vimwiki 里：</p><img src="//images-hikerpig.oss-cn-beijing.aliyuncs.com/image/emacs/vimwiki-code.png" alt="undefined" title="undefined"><p>而在 org-mode 当中一切都很行云流水</p><img src="//images-hikerpig.oss-cn-beijing.aliyuncs.com/image/emacs/org-mode-code.png" alt="undefined" title="undefined"><h2 id="其他优点">其他优点</h2><p>包括但不限于：</p><ul><li>所见即所得，默认情况下 live preview，不会生成多余文件</li><li>强大的链接系统，直接跳转至多种形式的内外链接</li><li>强大的<a href="http://orgmode.org/manual/Agenda-Views.html" target="_blank" rel="noopener">日程规划功能</a></li><li>强大的<a href="http://www.cnblogs.com/holbrook/archive/2012/04/12/2444992.html" target="_blank" rel="noopener">表格编辑功能</a></li></ul><h3 id="一些收集">一些收集</h3><ul><li><a href="http://doc.norang.ca/org-mode.htm" target="_blank" rel="noopener">Organize Your Life In Plain Text!</a></li></ul><h1 id="helm">helm</h1><p><a href="http://tuhdo.github.io/helm-intro.html" target="_blank" rel="noopener">A Package in a league of its own: Helm</a></p><p>交互形式让我想起了 Vim 下的 <code>ctrlp</code> 和 <code>unite</code>，但是能做的事情更多，而且扩展性更好。</p><p>除了能找到任何文件外，还能找个任何一个命令，再也不用记那么多 <code>M-x</code> 命令了，再也不用担心小拇指受伤了。</p><figure><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201601/15/103214s4z77zo4pimefccm.jpg" alt="From linux.cn"><figcaption>From linux.cn</figcaption></figure><h1 id="scala-mode-以及-ensime">scala-mode 以及 ensime</h1><p>在做 Coursera 上 Scala 课程作业的时候试了一下。<a href="http://ensime.org/" target="_blank" rel="noopener">Ensime</a> 的 Emacs 插件完成度<a href="http://ensime.org/editors/" target="_blank" rel="noopener">非常的高</a>。</p><h1 id="artist-mode">artist-mode</h1><p>无比炫酷的 ACSII Art 工具，写注释和文档有时一图胜千言。配合 org-mode，感觉自己从未如此热爱写文档。</p><p>看<a href="http://emacser.com/artist-mode.htm" target="_blank" rel="noopener">emacser 上的一篇介绍</a>。</p><p>Vim 上有个类似的插件 <a href="http://www.vim.org/scripts/script.php?script_id=40" target="_blank" rel="noopener">Drawit.vim</a>，不知二者谁先谁后，都挺好用的。</p><h1 id="imenu-list">imenu-list</h1><p>在右边新建一个 buffer 显示 imenu 的结果，接近于 Vim 的 Tagbar 使用体验。</p><figure><img src="https://github.com/bmag/imenu-list/raw/master/images/imenu-list-dark.png" alt="github imenu-list"><figcaption>github imenu-list</figcaption></figure><h1 id="可以使用但不准备替换现有主力编辑器atomvim的">可以使用，但不准备替换现有主力编辑器（Atom/Vim）的</h1><h2 id="coffee-mode">coffee-mode</h2><p><a href="https://github.com/defunkt/coffee-mode" target="_blank" rel="noopener">coffee-mode</a> 支持 coffeescript 文件的语法高亮、编译和 watch 等功能，配合 etags 使用还不错。</p><p>与 evil 一起使用的时候需要一些额外配置，否则用 <code>o</code> 换行的时候发现缩进不对。</p><p>官方 README 给出了解决方案：</p><pre><code class="hljs elisp">(custom-set-variables &apos;(coffee-indent-like-python-mode t))</code></pre><h1 id="放弃折腾的部分">放弃折腾的部分</h1><h2 id="javascript-和-eslint">Javascript 和 Eslint</h2><p>作为一个前端，还是有点小遗憾的。</p><p>没有找到开箱即用的插件，<code>flycheck</code> 似乎很是强大，但是要支持 eslint 还有改许多配置。当然了，前端开发还是看 VS Code 和 Atom 吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://spacemacs.org/img/logo.svg&quot;&gt;&lt;/p&gt;
&lt;p&gt;很久以前看 SICP 的时候尝试在 windows 下使用 emacs 时受到了惊吓，那刀耕火种一般的界面啊。后来在 Ubuntu 终端中打开，诶？怎么关不掉？不掉？掉
      
    
    </summary>
    
    
      <category term="emacs" scheme="http://hikerpig.github.io/tags/emacs/"/>
    
      <category term="editor" scheme="http://hikerpig.github.io/tags/editor/"/>
    
      <category term="productivity" scheme="http://hikerpig.github.io/tags/productivity/"/>
    
  </entry>
  
  <entry>
    <title>前端 Log 小记</title>
    <link href="http://hikerpig.github.io/2016/12/21/2016-12-21-Enhanced-Client-Side-Console/"/>
    <id>http://hikerpig.github.io/2016/12/21/2016-12-21-Enhanced-Client-Side-Console/</id>
    <published>2016-12-20T16:00:00.000Z</published>
    <updated>2018-08-26T08:52:02.072Z</updated>
    
    <content type="html"><![CDATA[<p>相信各位前端工程师们都经历过一个黑暗的场景。</p><img src="//images-hikerpig.oss-cn-beijing.aliyuncs.com/image/stack-or-gtfo.jpg" alt="undefined" title="undefined"><p>(哎哟哎哟测试大人我什么也没说)</p><p>曾经有一个出现bug的页面出现在我面前，我没有珍惜，直到用户关掉页面了，才后悔莫及。</p><p>而且错误不能等到用户反馈了才去探究，最好有完备的收集和响应系统，积极的错误日志分析，使我们防患于未然。</p><h2 id="成熟的-saas-服务">成熟的 SaaS 服务</h2><p>选择还是挺多的，例如 <a href="http://trackjs.com/" target="_blank" rel="noopener">track.js</a>，<a href="https://sentry.io" target="_blank" rel="noopener">Sentry</a>，<a href="https://errorception.com/" target="_blank" rel="noopener">ErrorCeption</a>，<a href="https://www.loggly.com/" target="_blank" rel="noopener">Loggly</a>，<a href="https://airbrake.io/" target="_blank" rel="noopener">Airbrke</a>。都比较成熟，各家各有特色，集成相对简单。</p><h3 id="track.jstrackjs"><a href="http://trackjs.com/" target="_blank" rel="noopener">{track.js}</a></h3><p>鄙公司在使用的服务，十分好用，比起其他几个选项，只专注在前端错误日志，除了基本的记录、sourcemap支持以及错误栈追踪以外，提供的事件记录和时间轴功能，记录了所有网络请求以及用户操作(皆可配置开关)，能让你更好地重现异常发生的过程。十分推荐大家试试，试用期有30天，在自己的项目里先试试吧。</p><h3 id="sentrysentry"><a href="https://sentry.io" target="_blank" rel="noopener">Sentry</a></h3><p>有跨语言和多框架集成支持，前后端皆可用，有免费的社区版本。</p><p>值得一说的是浏览器端的库名字是<code>raven</code>，看了不得不为这个梗点个赞。</p><figure><img src="http://www.30play.com/manage/editor/UploadFile/2014108143616129.jpg" alt="X-Men"><figcaption>X-Men</figcaption></figure><h2 id="错误栈追踪stack-trace">错误栈追踪(Stack Trace)</h2><p>如果不使用自带 parser 的服务而是自己实现前后功能，可能在发送到服务器之前，最好做一些处理，例如生成更可读的错误栈，会让你工作更加轻松。栈信息对于定位和调试错误是十分重要的。</p><h3 id="第三方库">第三方库</h3><h4 id="tracekit"><a href="https://github.com/csnover/TraceKit" target="_blank" rel="noopener">TraceKit</a></h4><pre><code class="hljs javascript"><span class="hljs-comment">// 先注册一下报告的行为回调</span>TraceKit.report.subscribe(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">yourLogger</span>(<span class="hljs-params">errorReport</span>) </span>&#123;  <span class="hljs-comment">// 发送ajax请求到服务器端</span>  <span class="hljs-comment">// 在 https://gist.github.com/4491219 上有个好例子</span>&#125;;<span class="hljs-comment">// 开始写程序</span><span class="hljs-keyword">try</span> &#123;  <span class="hljs-comment">/*   * your application code here   *   */</span>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'oops'</span>);&#125; <span class="hljs-keyword">catch</span> (e) &#123;  TraceKit.report(e); <span class="hljs-comment">//error with stack trace gets normalized and sent to subscriber</span>&#125;</code></pre><h4 id="stacktrace.js"><a href="http://stacktracejs.com/" target="_blank" rel="noopener">stacktrace.js</a></h4><p>解析错误栈并且给出结构化表示，api 设计满足 Promise 规范。</p><p>官方给出的例子:</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> callback = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stackframes</span>) </span>&#123;  <span class="hljs-keyword">var</span> stringifiedStack = stackframes.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">sf</span>) </span>&#123;    <span class="hljs-keyword">return</span> sf.toString();  &#125;).join(<span class="hljs-string">'\n'</span>);  <span class="hljs-built_in">console</span>.log(stringifiedStack);&#125;;<span class="hljs-keyword">var</span> errback = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>&#123; <span class="hljs-built_in">console</span>.log(err.message); &#125;;<span class="hljs-built_in">window</span>.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">msg, file, line, col, error</span>) </span>&#123;  <span class="hljs-comment">// callback is called with an Array[StackFrame]</span>  StackTrace.fromError(error).then(callback).catch(errback);&#125;;</code></pre><h3 id="提升开发时console-log体验的轻量第三方库">提升开发时Console log体验的轻量第三方库</h3><h4 id="logdown"><a href="https://github.com/caiogondim/logdown.js" target="_blank" rel="noopener">Logdown</a></h4><p>node和浏览器端都可以使用的一个工具。</p><p>提供命名空间，并能分别开关各命名空间的log:</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> uiLogger = <span class="hljs-keyword">new</span> Logdown(&#123;<span class="hljs-attr">prefix</span>: <span class="hljs-string">'MyApp:UI'</span>&#125;);<span class="hljs-keyword">var</span> networkServiceLogger = <span class="hljs-keyword">new</span> Logdown(&#123;<span class="hljs-attr">prefix</span>: <span class="hljs-string">'MyApp:Network'</span>&#125;);Logdown.disable(<span class="hljs-string">'MyApp:UI'</span>);Logdown.enable(<span class="hljs-string">'MyApp:Network'</span>);Logdown.disable(<span class="hljs-string">'MyApp:*'</span>); <span class="hljs-comment">// 支持通配符</span></code></pre><p>还支持 markdown 语法:</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> logger = <span class="hljs-keyword">new</span> Logdown(&#123;<span class="hljs-attr">markdown</span>: <span class="hljs-literal">true</span>&#125;);logger.warn(<span class="hljs-string">'Log is *Awesome*'</span>);</code></pre><p>可以看看作者给的<a href="https://caiogondim.github.io/logdown.js/" target="_blank" rel="noopener">例子</a></p><img src="//images-hikerpig.oss-cn-beijing.aliyuncs.com/image/logdown.js.png" alt="undefined" title="undefined"><h1 id="最后">最后</h1><p>错误日志收集完了记住要去看哟。</p><h1 id="参考">参考</h1><ul><li><a href="https://www.sitepoint.com/logging-errors-client-side-apps/" target="_blank" rel="noopener">Logging Errors in Client-Side Applications</a>: 基本上是原文</li><li>题图来自<a href="https://github.com/csnover/TraceKit" target="_blank" rel="noopener">TraceKit</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;相信各位前端工程师们都经历过一个黑暗的场景。&lt;/p&gt;
&lt;img src=&quot;//images-hikerpig.oss-cn-beijing.aliyuncs.com/image/stack-or-gtfo.jpg&quot; alt=&quot;undefined&quot; title=&quot;undefi
      
    
    </summary>
    
      <category term="前端" scheme="http://hikerpig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://hikerpig.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Engineering" scheme="http://hikerpig.github.io/tags/Engineering/"/>
    
  </entry>
  
</feed>
