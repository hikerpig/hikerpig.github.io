<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HP goes FE</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hikerpig.github.io/"/>
  <updated>2019-04-02T13:07:16.131Z</updated>
  <id>http://hikerpig.github.io/</id>
  
  <author>
    <name>Hikerpig</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Handy Video Analyze Tool</title>
    <link href="http://hikerpig.github.io/2019/03/14/2019-03-13-Handy-Video-Analyze-Tool/"/>
    <id>http://hikerpig.github.io/2019/03/14/2019-03-13-Handy-Video-Analyze-Tool/</id>
    <published>2019-03-13T16:00:00.000Z</published>
    <updated>2019-04-02T13:07:16.131Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写一些跟视频解码相关的简单程序，学习 avcodec 技术时有一些强大的分析工具，分享一下。</p><h1 id="码流与封装容器相关">码流与封装容器相关</h1><h2 id="bento4">bento4</h2><p><a href="https://www.bento4.com/" target="_blank" rel="noopener">bento4</a> 是一套专用于 mp4 格式文件分析和编辑的 SDK，支持的功能非常多。</p><table><colgroup><col style="width: 11%"><col style="width: 88%"></colgroup><thead><tr class="header"><th>工具</th><th>用途</th></tr></thead><tbody><tr class="odd"><td>mp4info</td><td>displays high level info about an MP4 file, including all tracks and codec details</td></tr><tr class="even"><td>mp4dump</td><td>displays the entire atom/box structure of an MP4 file</td></tr><tr class="odd"><td>mp4edit</td><td>add/insert/remove/replace atom/box items of an MP4 file</td></tr><tr class="even"><td>mp4extract</td><td>extracts an atom/box from an MP4 file</td></tr><tr class="odd"><td>mp4encrypt</td><td>encrypts an MP4 file (multiple encryption schemes are supported)</td></tr><tr class="even"><td>mp4decrypt</td><td>decrypts an MP4 file (multiple encryption schemes are supported)</td></tr><tr class="odd"><td>mp4dcfpackager</td><td>encrypts a media file into an OMA DCF file</td></tr><tr class="even"><td>mp4compact</td><td>converts ‘stsz’ tables into ‘stz2’ tables to create more compact MP4 files</td></tr><tr class="odd"><td>mp4fragment</td><td>creates a fragmented MP4 file from a non-fragmented one.</td></tr><tr class="even"><td>mp4split</td><td>splits a fragmented MP4 file into discrete files</td></tr><tr class="odd"><td>mp4tag</td><td>show/edit MP4 metadata (iTunes-style and others)</td></tr><tr class="even"><td>mp4mux</td><td>multiplexes one or more elementary streams (H264/AVC, H265/HEVC, AAC) into an MP4 file</td></tr><tr class="odd"><td>mp42aac</td><td>extract a raw AAC elementary stream from an MP4 file</td></tr><tr class="even"><td>mp42avc</td><td>extract a raw AVC/H.264 elementary stream from an MP4 file</td></tr><tr class="odd"><td>mp42hls</td><td>converts an MP4 file to an HLS (HTTP Live Streaming) presentation, including the generation of the segments and .m3u8 playlist as well as AES-128 and SAMPLE-AES (for Fairplay) encryption. This can be used as a replacement for Apple’s mediafilesegmenter tool.</td></tr><tr class="even"><td>mp42ts</td><td>converts an MP4 file to an MPEG2-TS file.</td></tr><tr class="odd"><td>mp4dash</td><td>creates an MPEG DASH output from one or more MP4 files, including encryption. This is a full-featured MPEG DASH packager.</td></tr><tr class="even"><td>mp4dashclone</td><td>creates a local clone of a remote or local MPEG DASH presentation, optionally encrypting the segments as they are cloned.</td></tr><tr class="odd"><td>mp4hls</td><td>creates a multi-bitrate HLS master playlist from one or more MP4 files, including support for encryption and I-frame-only playlists. This tool uses the ‘mp42hls’ low level tool internally, so all the options supported by that low level tool are also available. This can be used as a replacement for Apple’s variantplaylistcreator tool.</td></tr></tbody></table><h2 id="gpac">GPAC</h2><p><a href="https://gpac.wp.imt.fr/" target="_blank" rel="noopener">GPAC</a> 是一个为科研和学术领域开发的多媒体的框架，包括几个视频分析和码流编辑的 CLI 工具。官网主要 feature 如下:</p><blockquote><p>GPAC features encoders and multiplexers, publishing and content distribution tools for MP4 and 3GPP or 3GPP2 files and many tools for scene descriptions (BIFS/VRML/X3D converters, SWF/BIFS, SVG/BIFS, etc…). MP4Box provides all these tools in a single command-line application. An exhaustive list of packaging features is available here but a good summary of what MP4Box can do for you is the following:</p><ul><li>MP4/3GP Conversion from MP3, AVI, MEPG-2 TS, MPEG-PS, AAC, H263, H264, AMR, and many others,</li><li>3GPP DIMS Packaging from SVG files,</li><li>File layout: fragmentation or interleaving, and cleaning,</li><li>File hinting for RTP/RTSP and QTSS/DSS servers (MPEG-4 / ISMA / 3GP / 3GP2 files),</li><li>File splitting by size or time, extraction from file and file concatenation,</li><li>XML information dumping for MP4 and RTP hint tracks,</li><li>Media Track extractions,</li><li>ISMA E&amp;A encryption and decryption,</li><li>3GPP timed text tools (SUB/SRT/TTXT/TeXML), VobSub import/export,</li><li>BIFS codec and scene conversion between MP4, BT and XMT-A,</li><li>LASeR codec and scene conversion between MP4, SAF, SVG and XSR (XML LASeR),</li><li>XML scene statistics for BIFS scene (BT, XMT-A and MP4),</li><li>Conversion to and from BT, XMT-A, WRL, X3D and X3DV with support for gzip.</li><li>Preparing MP4,3GP and MPEG-2 TS files for DASH streaming</li></ul></blockquote><p>主要使用的可能是 <code>MP4Box</code> 工具，功能很多，几个例子:</p><pre><code class="hljs bash">MP4Box -add file.av1 file_av1.mp4 <span class="hljs-comment"># 将 av1 码流封装写入 mp4 文件</span></code></pre><h2 id="iso-viewer">ISO Viewer</h2><p><a href="https://github.com/sannies/isoviewer" target="_blank" rel="noopener">isoviewer</a> 是 Mac 下一个检查 mp4 文件构成的 GUI 程序，能直观地看到各个 box 的数据。</p>{% qimage image/iso-viewer.png %}<h2 id="ffprobe">ffprobe</h2><p>大名鼎鼎的 ffmpeg 项目一员，一身<a href="https://ffmpeg.org/ffprobe.html" target="_blank" rel="noopener">技能和 API 参数</a>。</p><p>其中一个用法是 dump 出所有的 frame:</p><pre><code class="hljs undefined"><span class="hljs-selector-tag">ffprobe</span> <span class="hljs-selector-tag">-show_frames</span> <span class="hljs-selector-tag">some</span><span class="hljs-selector-class">.mp4</span> &gt; <span class="hljs-selector-tag">probe-mp4</span><span class="hljs-selector-class">.txt</span></code></pre><pre><code class="hljs undefined"><span class="hljs-section">[FRAME]</span><span class="hljs-attr">media_type</span>=video<span class="hljs-attr">stream_index</span>=<span class="hljs-number">0</span><span class="hljs-attr">key_frame</span>=<span class="hljs-number">1</span><span class="hljs-attr">pkt_pts</span>=<span class="hljs-number">0</span><span class="hljs-attr">pkt_pts_time</span>=<span class="hljs-number">0.000000</span><span class="hljs-attr">pkt_dts</span>=<span class="hljs-number">0</span><span class="hljs-attr">pkt_dts_time</span>=<span class="hljs-number">0.000000</span><span class="hljs-attr">best_effort_timestamp</span>=<span class="hljs-number">0</span><span class="hljs-attr">best_effort_timestamp_time</span>=<span class="hljs-number">0.000000</span><span class="hljs-attr">pkt_duration</span>=<span class="hljs-number">512</span><span class="hljs-attr">pkt_duration_time</span>=<span class="hljs-number">0.040000</span><span class="hljs-attr">pkt_pos</span>=<span class="hljs-number">48</span><span class="hljs-attr">pkt_size</span>=<span class="hljs-number">27979</span><span class="hljs-attr">width</span>=<span class="hljs-number">320</span><span class="hljs-attr">height</span>=<span class="hljs-number">564</span><span class="hljs-attr">pix_fmt</span>=yuv420p<span class="hljs-attr">sample_aspect_ratio</span>=N/A<span class="hljs-attr">pict_type</span>=I<span class="hljs-attr">coded_picture_number</span>=<span class="hljs-number">0</span><span class="hljs-attr">display_picture_number</span>=<span class="hljs-number">0</span><span class="hljs-attr">interlaced_frame</span>=<span class="hljs-number">0</span><span class="hljs-attr">top_field_first</span>=<span class="hljs-number">0</span><span class="hljs-attr">repeat_pict</span>=<span class="hljs-number">0</span><span class="hljs-attr">color_range</span>=unknown<span class="hljs-attr">color_space</span>=unknown<span class="hljs-attr">color_primaries</span>=unknown<span class="hljs-attr">color_transfer</span>=unknown<span class="hljs-attr">chroma_location</span>=left<span class="hljs-section">[/FRAME]</span><span class="hljs-section">[FRAME]</span><span class="hljs-attr">media_type</span>=audio<span class="hljs-attr">stream_index</span>=<span class="hljs-number">1</span><span class="hljs-attr">key_frame</span>=<span class="hljs-number">1</span><span class="hljs-attr">pkt_pts</span>=<span class="hljs-number">0</span><span class="hljs-attr">pkt_pts_time</span>=<span class="hljs-number">0.000000</span><span class="hljs-attr">pkt_dts</span>=<span class="hljs-number">0</span><span class="hljs-attr">pkt_dts_time</span>=<span class="hljs-number">0.000000</span><span class="hljs-attr">best_effort_timestamp</span>=<span class="hljs-number">0</span><span class="hljs-attr">best_effort_timestamp_time</span>=<span class="hljs-number">0.000000</span><span class="hljs-attr">pkt_duration</span>=<span class="hljs-number">1024</span><span class="hljs-attr">pkt_duration_time</span>=<span class="hljs-number">0.021333</span><span class="hljs-attr">pkt_pos</span>=<span class="hljs-number">28243</span><span class="hljs-attr">pkt_size</span>=<span class="hljs-number">6</span><span class="hljs-attr">sample_fmt</span>=fltp<span class="hljs-attr">nb_samples</span>=<span class="hljs-number">1024</span><span class="hljs-attr">channels</span>=<span class="hljs-number">2</span><span class="hljs-attr">channel_layout</span>=stereo<span class="hljs-section">[/FRAME]</span></code></pre><h1 id="二进制显示编辑">二进制显示/编辑</h1><h2 id="hex-fiend">Hex Fiend</h2><p><a href="https://github.com/ridiculousfish/HexFiend" target="_blank" rel="noopener">Hex Fiend</a>, Mac 下的 hex 编辑 GUI 工具，支持按文本或hex搜索/编辑/diff，功能强大。</p><figure><img src="https://raw.githubusercontent.com/ridiculousfish/HexFiend/master/docs/screenshot.png" alt="HexFiend"><figcaption>HexFiend</figcaption></figure><h2 id="hexyl">hexyl</h2><p><a href="https://github.com/sharkdp/hexyl" target="_blank" rel="noopener">hexyl</a> ，一个轻量 CLI 查看二进制数据的工具，用 rust 编写。优点是快速，好看。</p><figure><img src="https://camo.githubusercontent.com/1f71ee7031e1962b23f21c8cc89cb837e1201238/68747470733a2f2f692e696d6775722e636f6d2f4d574f3975534c2e706e67" alt="hexyl 效果图"><figcaption>hexyl 效果图</figcaption></figure>]]></content>
    
    <summary type="html">
    
      分享一些学习 avcodec 技术时好用的分析工具
    
    </summary>
    
      <category term="工具" scheme="http://hikerpig.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="video" scheme="http://hikerpig.github.io/tags/video/"/>
    
  </entry>
  
  <entry>
    <title>Tips On Viewing Logs</title>
    <link href="http://hikerpig.github.io/2019/03/08/2019-03-08-Tips-On-Viewing-Logs/"/>
    <id>http://hikerpig.github.io/2019/03/08/2019-03-08-Tips-On-Viewing-Logs/</id>
    <published>2019-03-08T05:48:27.839Z</published>
    <updated>2019-03-08T06:00:52.239Z</updated>
    
    <content type="html"><![CDATA[<p>面对浩如烟海的 log，在排查错误和查找信息时使用一些趁手的工具，快速定位，关爱视力，有益身心健康。</p><h1 id="高级的工具">高级的工具</h1><h2 id="lnav">lnav</h2><p><a href="http://lnav.org/" target="_blank" rel="noopener">lnav</a> 是一个非常强大的日志查看器，有多种视图和过滤功能，不过最喜欢的其实还是自动的颜色高亮。</p><figure><img src="https://static1.squarespace.com/static/51bd4e13e4b0052d7873ad34/t/551aa43fe4b065952ea849ad/1427809346467/?format=1500w" alt="lnav 官网给出的效果图"><figcaption>lnav 官网给出的效果图</figcaption></figure><h1 id="系统自带工具">系统自带工具</h1><p>不用安装额外的程序，linux 多数发行版都有的基础工具。</p><h2 id="less">less</h2><h3 id="高亮搜索命中内容">高亮搜索命中内容</h3><p><a href="https://unix.stackexchange.com/questions/179173/make-less-highlight-search-patterns-instead-of-italicizing-them" target="_blank" rel="noopener">Make Less highlight search patterns instead of italicizing them</a></p><pre><code class="hljs undefined"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">LESS_TERMCAP_se</span>=$'\E[39;49m'</code></pre>]]></content>
    
    <summary type="html">
    
      一些看 LOG 时方便的工具和技巧
    
    </summary>
    
      <category term="Tips" scheme="http://hikerpig.github.io/categories/Tips/"/>
    
    
      <category term="tip" scheme="http://hikerpig.github.io/tags/tip/"/>
    
  </entry>
  
  <entry>
    <title>Decode Video Using ffmpeg In Browser</title>
    <link href="http://hikerpig.github.io/2019/03/06/2019-03-06-Decode-Video-Using-FFMpeg-In-Browser/"/>
    <id>http://hikerpig.github.io/2019/03/06/2019-03-06-Decode-Video-Using-FFMpeg-In-Browser/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2019-04-02T13:29:30.755Z</updated>
    
    <content type="html"><![CDATA[<p>音视频开发入门，可能绕不开 ffmpeg 这个项目，最近看了篇 <a href="https://zhuanlan.zhihu.com/p/40786748" target="_blank" rel="noopener">知乎专栏</a>，觉得这个事情很有意思。</p><p>比起直接编辑整个 ffmpeg 项目的 CLI 到前端，更符合实际需求的方式，是先基于 ffmpeg 各种 lib二次开发出合适的功能，然后再使用 Emscripten 编译到 Webassembly。</p><p>跟着教程实现一个功能：解析出视频任意一帧的图像并绘制到 canvas 上。</p><h2 id="web-demo-应用流程">Web demo 应用流程</h2><p>demo 页的简单流程</p><pre><code class="hljs mermaid">graph TD    P1[获取视频 buffer 并写入wasm将要使用的线性内存空间] -- 进入wasm调用 --&gt; Asubgraph C 程序转成的 wasm    A[avcodec 解析视频文件 buffer] --&gt; B[解出指定时间的图像并转成 RGB 格式数据]    B --&gt; C[将图像等数据写入内存, 并将指针返给 js 端]end    C  -- 回到 js --&gt;  D[根据指针读出数据, 构建 ImageData, 绘制到 canvas 上]</code></pre><h2 id="从源码编译-ffmpeg">从源码编译 ffmpeg</h2><p>本文写就的时候使用的是 ffmpeg <code>n4.2-dev</code> 版，将其源码置于项目相对目录 <code>lib/ffmpeg</code> 下。</p><p>ffmpeg 是一个很大的项目，包含的很多功能对于我们的需求来说，都用不上，可以通过 <a href="https://github.com/FFmpeg/FFmpeg/blob/master/configure" target="_blank" rel="noopener">configure</a> 配置留下合适的功能集。以前用 c 写的比较复杂的项目，通常在实际编译之前，可以使用 configure 根据参数和环境生成实际编译过程需要的 Makefile。</p><h3 id="项目-makefile">项目 Makefile</h3><p>参考 <a href="https://github.com/Kagami/ffmpeg.js/" target="_blank" rel="noopener">ffmpeg.js</a> 项目的一些配置</p><pre><code class="hljs makefile">COMMON_FILTERS = scale crop overlayCOMMON_DEMUXERS = matroska ogg avi mov flv mpegps image2 mp3 concatCOMMON_DECODERS = \mpeg2video mpeg4 h264 hevc \png mjpeg \mp3 ac3 aacMUXERS = mp4 null image2ENCODERS = mjpegFFMPEG_CONFIGURE_ARGS = \--cc=emcc \--ar=emar \--enable-cross-compile \--target-os=none \--cpu=generic \--arch=x86 \--disable-runtime-cpudetect \--disable-asm \--disable-fast-unaligned \--disable-pthreads \--disable-w32threads \--disable-os2threads \--disable-debug \--disable-stripping \\--disable-all \--enable-avcodec \--enable-avformat \--enable-avutil \--enable-swscale \--enable-shared \--enable-protocol=file \<span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> --enable-decoder=,<span class="hljs-variable">$(COMMON_DECODERS)</span>)</span> \<span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> --enable-demuxer=,<span class="hljs-variable">$(COMMON_DEMUXERS)</span>)</span> \<span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> --enable-encoder=,<span class="hljs-variable">$(ENCODERS)</span>)</span> \<span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> --enable-muxer=,<span class="hljs-variable">$(MUXERS)</span>)</span> \<span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> --enable-<span class="hljs-built_in">filter</span>=,<span class="hljs-variable">$(COMMON_FILTERS)</span>)</span> <span class="hljs-comment"># to run ffmpeg configure and emmake</span><span class="hljs-section">lib/ffmpeg/libavcodec/libavcodec.a:</span>cd lib/ffmpeg &amp;&amp; \patch -p1 &lt; ../swscale.c.patch &amp;&amp; \emconfigure ./configure \<span class="hljs-variable">$(FFMPEG_CONFIGURE_ARGS)</span> \&amp;&amp; \emmake make</code></pre><p>说下 <code>lib/ffmpeg/libavcodec/libavcodec.a</code> 这个目标，分成几步:</p><ul><li><code>emconfigure</code> 是 emsdk 提供的工具，执行完这一步之后，会生成 <code>lib/ffmpeg/Makefile</code></li><li><code>emmake make</code> 便是开始编译了，由于我们在前一步 configure 的时候有 <code>--enable-avcodec</code>，所以用这个 Makefile 编译，会生成 <code>lib/ffmpeg/libavcodec/libavcodec.a</code> 这个静态库文件</li><li>编译原本的 ffmpeg 代码会报错，定位到 <code>libswscale/swscale.c</code> 文件里，为了编译通过，在编译前加了个不影响主要功能的简单的 patch</li></ul><p>运行 <code>make lib/ffmpeg/libavcodec/libavcodec.a</code>，等待大约一两分钟，emscripten 编译 ffmpeg 静态库完成，闪过了一堆 warning 可以优雅地无视掉。接下来就是编写我们的应用接口代码并编译到 WebAssembly 了。</p><h2 id="编译和使用">编译和使用</h2><h3 id="生成-js-和-wasm-文件">生成 JS 和 WASM 文件</h3><pre><code class="hljs makefile"><span class="hljs-section">dist/vidy-standalone.js:</span>    emcc transcoder/web.c transcoder/process.c \                lib/ffmpeg/libavformat/libavformat.a \                lib/ffmpeg/libavcodec/libavcodec.a \                lib/ffmpeg/libswscale/libswscale.a \                lib/ffmpeg/libavutil/libavutil.a \                -s TOTAL_MEMORY=33554432 \                -s MODULARIZE=1 \                -O1 -s WASM=1 -s EXTRA_EXPORTED_RUNTIME_METHODS='[<span class="hljs-string">"ccall"</span>, <span class="hljs-string">"cwrap"</span>]' -s ALLOW_MEMORY_GROWTH=1  \                -Ilib/ffmpeg \                --post-js transcoder/js/post.js \                -o dist/vidy-standalone.js</code></pre><p>使用 <code>emcc</code> 编译：</p><ul><li>存放暴露给浏览器的相关接口的 <code>web.c</code></li><li>存放通用的 ffmpeg 方法调用的 <code>process.c</code></li><li>以及之前生成个几个静态库文件 <code>.a</code></li></ul><p>一起生成目标文件 <code>dist/vidy-standalone.js</code>，由于传递了 <code>-s WASM=1</code>，还会生成同名的 <code>dist/vidy-standalone.wasm</code> 文件。JS 是一个一千来行的胶水代码，负责 WASM 模块的初始化和调用适配。WASM 文件大概 4.7M。</p><p>查看 <a href="%5Bhttps://emscripten.org/docs/tools_reference/emcc.html">emcc文档</a> 和 <a href="https://github.com/emscripten-core/emscripten/blob/master/src/settings.js" target="_blank" rel="noopener">关于 <code>-s</code> 的全部可选 setting</a>。</p><h3 id="使用方法">使用方法</h3><h4 id="简单的例子">简单的例子</h4><pre><code class="hljs js"><span class="hljs-keyword">import</span> Module <span class="hljs-keyword">from</span> <span class="hljs-string">'../dist/vidy-standalone'</span><span class="hljs-keyword">let</span> vidyModulefetch(<span class="hljs-string">'//path/to/dist/vidy-standalone.wasm'</span>)    .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.arrayBuffer())    .then(<span class="hljs-function">(<span class="hljs-params">arrayBuffer</span>) =&gt;</span> &#123;        vidyModule = Module(&#123;            <span class="hljs-attr">wasmBinary</span>: arrayBuffer        &#125;)        decodeVideoFrameImage(<span class="hljs-string">'some.mp4'</span>, <span class="hljs-number">1.2</span>)    &#125;)<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">decodeVideoFrameImage</span>(<span class="hljs-params">videoPath, timeStamp</span>) </span>&#123;    fetch(videoPath).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.arrayBuffer())        .then(<span class="hljs-function">(<span class="hljs-params">videoBuffer</span>) =&gt;</span> &#123;            <span class="hljs-keyword">const</span> imageResult = vidyModule.getImage(<span class="hljs-keyword">this</span>.result, <span class="hljs-built_in">parseFloat</span>(timeStamp))            <span class="hljs-comment">// ...</span>        &#125;)&#125;</code></pre><h4 id="稍微复杂点的例子">稍微复杂点的例子</h4><p>为了将模块更好地整合到前端工程中，有必要考虑在使用 webpack 的情况下如何引入。</p><p>参考 <a href="https://github.com/GoogleChromeLabs/squoosh/" target="_blank" rel="noopener">GoogleChromeLabs/squoosh</a> 项目中的一些经验，首先看下 webpack 配置。webpack 团队在 v4 以后做了很多努力，想要让 WASM 模块的引入和使用与 js 文件一样方便，但实际实用中有很多边边角角<a href="https://github.com/webpack/webpack/issues/6725" target="_blank" rel="noopener">奇怪的问题和报错</a>，而且处理一个好几兆的 wasm 文件拖慢 webpack 冷启动许多，我们可以用一下配置让 webpack 不去读取 WASM 文件。使用 file-loader 也可以简单地配置带哈希的文件名，比起在项目中硬编码 WASM 文件路径，少去一些缓存问题。</p><pre><code class="hljs js"><span class="hljs-comment">// webpack config</span>    rules: [    ...      &#123;        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.wasm$/</span>,        <span class="hljs-comment">// This is needed to make webpack NOT process wasm files.</span>        type: <span class="hljs-string">'javascript/auto'</span>,        <span class="hljs-attr">loader</span>: <span class="hljs-string">'file-loader'</span>,        <span class="hljs-attr">options</span>: &#123;          <span class="hljs-attr">name</span>: <span class="hljs-string">'[name].[hash:5].[ext]'</span>,        &#125;,      &#125;,    ...    ]</code></pre><p>跟上面简单例子里效果相似的写法可以变成这样:</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> Module <span class="hljs-keyword">from</span> <span class="hljs-string">'../dist/vidy-standalone'</span><span class="hljs-keyword">import</span> vidyWasmUrl <span class="hljs-keyword">from</span> <span class="hljs-string">'../dist/vidy-standalone.wasm'</span> <span class="hljs-comment">// 会被 file-loader 处理成一个静态文件的 url</span><span class="hljs-keyword">const</span> vidyModule = Module(&#123;    locateFile(url) &#123;        <span class="hljs-comment">// Redirect the request for the wasm binary to whatever webpack gave us.</span>        <span class="hljs-keyword">if</span> (url.endsWith(<span class="hljs-string">'.wasm'</span>)) <span class="hljs-keyword">return</span> vidyWasmUrl;        <span class="hljs-keyword">return</span> url;    &#125;,&#125;)</code></pre><p>emcc 生成的胶水代码里，默认请求的 WASM 文件路径是 <code>vidy-standalone.wasm</code>，但看看 <a href="https://github.com/emscripten-core/emscripten/blob/master/emcc.py#L2800" target="_blank" rel="noopener">emcc 这一部分实现</a> 知道，如果给模块工厂函数 Module 传递了 <code>locateFile</code> 函数，就可以改写其内部会去请求的 WASM 文件路径。使用模块工厂函数的话，也不用自己去调用 <code>fetch</code> 了。</p><h2 id="一些具体实现的代码">一些具体实现的代码</h2><p>首先看看 <code>web.c</code> 里暴露出的方法签名：</p><pre><code class="hljs c"><span class="hljs-function">EMSCRIPTEN_KEEPALIVE MyImageData *<span class="hljs-title">seek_video_to</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *buff, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> buff_length, <span class="hljs-keyword">float</span> time_stamp)</span></span></code></pre><p>buffer 数组头指针 <code>buff</code>，buffer 长度 <code>buff_length</code>，以及用单精度浮点数表示的需要提取图像的时间。返回数据为我们自定义的结构。</p><h3 id="js-将视频数据写入-wasm-线性内存">[JS] 将视频数据写入 WASM 线性内存</h3><p>在 <code>post.js</code> 里，添加的一部分代码。</p><ul><li>根据 C 的方法签名，使用 emscripten 的胶水代码工具函数 <code>Module.cwrap</code> 包装一个 JS 的调用方法</li><li>给 emscripten 模块加上了 <code>Module.getImage</code> 方法，供外部调用</li></ul><pre><code class="hljs js"><span class="hljs-keyword">let</span> seek_video_to = <span class="hljs-literal">null</span>Module.onRuntimeInitialized = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  seek_video_to = Module.cwrap(<span class="hljs-string">'seek_video_to'</span>, <span class="hljs-string">'number'</span>, [<span class="hljs-string">'number'</span>, <span class="hljs-string">'number'</span>, <span class="hljs-string">'number'</span>]);&#125;;Module.getImage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">buffer, timeStamp</span>) </span>&#123;  <span class="hljs-keyword">if</span> (!seek_video_to) &#123;    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">errcode</span>: <span class="hljs-number">1</span> &#125;  &#125;  <span class="hljs-keyword">let</span> ptr = <span class="hljs-number">0</span>;  <span class="hljs-keyword">let</span> offset = <span class="hljs-number">0</span>;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">const</span> before = <span class="hljs-built_in">Date</span>.now()    <span class="hljs-keyword">let</span> data_arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(buffer);    offset = Module._malloc(data_arr.length);    Module.HEAP8.set(data_arr, offset);    ptr = seek_video_to(offset, data_arr.length, timeStamp);    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'seek_video_to costs'</span>, <span class="hljs-built_in">Date</span>.now() - before)  &#125; <span class="hljs-keyword">catch</span> (e) &#123;    <span class="hljs-keyword">throw</span> e;  &#125;  ...</code></pre><h3 id="c-程序头部">[C] 程序头部</h3><p>首先声明一些方便数据读取的全局变量:</p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span>    <span class="hljs-keyword">uint8_t</span> *ptr;    <span class="hljs-keyword">size_t</span> size;&#125; BufferData;<span class="hljs-comment">/** * some global variables */</span>BufferData global_buffer_data;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-keyword">uint32_t</span> width;    <span class="hljs-keyword">uint32_t</span> height;    <span class="hljs-keyword">uint8_t</span> *data;&#125; MyImageData;</code></pre><p>全局变量 <code>global_buffer_data</code> 留作存放原始视频数据的结构，它所在的内存区域会被 JS 直接写入。</p><h3 id="c-avcodec-解析视频文件">[C] avcodec 解析视频文件</h3><p>我们需要让 ffmpeg 能够从内存（而不是文件）中读取视频数据。</p><pre><code class="hljs c">...  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *avio_ctx_buffer = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 对于普通的mp4文件，这个size只要1MB就够了，但是对于mov/m4v需要和buff一样大</span>  <span class="hljs-keyword">size_t</span> avio_ctx_buffer_size = buff_length;  global_buffer_data.ptr = buff;         <span class="hljs-comment">/* will be grown as needed by the realloc above */</span>  global_buffer_data.size = buff_length; <span class="hljs-comment">/* no data at this point */</span>  AVFormatContext *pFormatCtx = avformat_alloc_context();  <span class="hljs-keyword">uint8_t</span> *avio_ctx_buffer = (<span class="hljs-keyword">uint8_t</span> *)av_malloc(avio_ctx_buffer_size);  <span class="hljs-comment">/* 读内存数据 */</span>  AVIOContext *avio_ctx = avio_alloc_context(avio_ctx_buffer, avio_ctx_buffer_size, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, read_packet, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);  pFormatCtx-&gt;pb = avio_ctx;  pFormatCtx-&gt;flags = AVFMT_FLAG_CUSTOM_IO;...</code></pre><p>新建 <code>AVIOContext *avio_ctx</code>，指定目标 buffer 指针，目标 buffer 大小，以及我们提供的读取数据的 <code>read_packet</code> 函数，该 iocontext 需要读下一段数据时， <code>read_packet</code> 函数就将 <code>global_buffer_data</code> 中指定大小的数据写入目标 <code>*buf</code> 位置</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read_packet</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *opaque, <span class="hljs-keyword">uint8_t</span> *buf, <span class="hljs-keyword">int</span> buf_size)</span></span>&#123;    buf_size = FFMIN(buf_size, global_buffer_data.size);    <span class="hljs-comment">/* copy internal buffer data to buf */</span>    <span class="hljs-built_in">memcpy</span>(buf, global_buffer_data.ptr, buf_size);    global_buffer_data.ptr += buf_size;    global_buffer_data.size -= buf_size;    <span class="hljs-keyword">return</span> buf_size;&#125;</code></pre><h3 id="c-获取图片rgb数据">[C] 获取图片rgb数据</h3><p>这里内容太多，主要涉及 FFMpeg 的接口和视频编解码的知识，准备另写一篇。</p><h3 id="c-将图像等数据写入内存">[C] 将图像等数据写入内存</h3><p>当拿到包含 RGB 格式图像数据的 <code>AVFrame pFrameRGB</code> 后，是时候将其中的颜色信息取出，转化为线性存储的，利于 JS 中 Canvas 元素使用的数据格式。</p><pre><code class="hljs c"><span class="hljs-keyword">uint8_t</span> *get_image_frame_buffer(AVFrame *pFrame, AVCodecContext *pCodecCtx)&#123;    <span class="hljs-keyword">int</span> width = pCodecCtx-&gt;width;    <span class="hljs-keyword">int</span> height = pCodecCtx-&gt;height;    <span class="hljs-keyword">int</span> buffer_size = height * width * <span class="hljs-number">3</span>;    <span class="hljs-keyword">uint8_t</span> *buffer = (<span class="hljs-keyword">uint8_t</span> *)<span class="hljs-built_in">malloc</span>(buffer_size);    <span class="hljs-comment">// Write pixel data</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; height; y++)    &#123;        <span class="hljs-built_in">memcpy</span>(buffer + y * pFrame-&gt;linesize[<span class="hljs-number">0</span>], pFrame-&gt;data[<span class="hljs-number">0</span>] + y * pFrame-&gt;linesize[<span class="hljs-number">0</span>], width * <span class="hljs-number">3</span>);    &#125;    <span class="hljs-keyword">return</span> buffer;&#125;</code></pre><p>此函数返回的 <code>buffer</code> 指针指向的内存区域，会按照 <code>rgbrgb...</code> 的顺序存储图像颜色数据。每个像素需要 3 个存储单元，所以整个的 <code>buffer_size</code> 会是 <code>height * width * 3</code>。</p><p>接下来我们回到 JS 端。</p><h3 id="js-根据指针读出数据-构建-imagedata">[JS] 根据指针读出数据, 构建 ImageData</h3><p>WASM 返回的只是一个内存偏移量，此时我们手上有整个 WASM 实例的内存区域，得想办法把有用的数据读取出来。</p><p>首先我们知道 <code>MyImageData</code> 结构体宽和高都是用 <code>uint32_t</code>，紧接着存放颜色信息的数组单元类型为 <code>uint8_t</code>。</p><p>Emscripten 的胶水代码有提供 HEAPU(8/16/32/64) 几种步长的 dataviewer，可以按照以下方法读出数字和颜色数组。</p><pre><code class="hljs ts"><span class="hljs-comment">// ...</span>  <span class="hljs-keyword">let</span> heap32Start = ptr / <span class="hljs-number">4</span>  <span class="hljs-keyword">let</span> width = Module.HEAPU32[heap32Start]  <span class="hljs-keyword">let</span> height = Module.HEAPU32[heap32Start + <span class="hljs-number">1</span>],    imgBufferPtr = Module.HEAPU32[heap32Start + <span class="hljs-number">2</span>],    imageBuffer = Module.HEAP.subarray(imgBufferPtr, imgBufferPtr + width * height * <span class="hljs-number">3</span>)  <span class="hljs-keyword">let</span> imageInfo = &#123; width, height, imageDataArr: imageBuffer &#125;  <span class="hljs-keyword">let</span> imageData = imageInfoToImageData(imageInfo)<span class="hljs-comment">// ...</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">imageInfoToImageData</span>(<span class="hljs-params">imageInfo: VidyImageInfo</span>) </span>&#123;  <span class="hljs-keyword">const</span> &#123; width, height, imageDataArr &#125; = imageInfo  <span class="hljs-keyword">const</span> imageData = <span class="hljs-keyword">new</span> ImageData(width, height)  <span class="hljs-comment">// 目前只返回 RGB24 格式的数据, 不处理透明度</span>  <span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; imageDataArr.length; i++) &#123;    <span class="hljs-keyword">if</span> (i &amp;&amp; i % <span class="hljs-number">3</span> === <span class="hljs-number">0</span>) &#123;      imageData.data[k++] = <span class="hljs-number">255</span>    &#125;    imageData.data[k++] = imageDataArr[i]  &#125;  imageData.data[k] = <span class="hljs-number">255</span>  <span class="hljs-keyword">return</span> imageData&#125;</code></pre><p>绘制到 canvas 上就很简单了</p><pre><code class="hljs ts">canvas.width = widthcanvas.height = height<span class="hljs-keyword">let</span> ctx = canvas.getContext(<span class="hljs-string">'2d'</span>)ctx.drawImage(imageData, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</code></pre><h2 id="总结">总结</h2><p>跟着别人的文章思路，小小修改，跑通了一个 demo，大致熟悉一下 C 项目使用 Emscripten 转化为前端可用模块的方案。</p><p>不是很熟悉 C 语言，同时在 JS 和 C 端手动管理内存虽然对于入门者来说很容易操作，但稍显繁琐。</p><p>Emscripten 多用于翻译现有的 C/C++ 库代码，对于 Web API 和前端生态的支持，明显没有隔壁 Mozilla 的 Rust 社区积极。不过音视频技术实现，的确是 C 的传统强项领域，若想少造轮子，还是要好好学习的。</p><h2 id="参考">参考</h2><p>https://zhuanlan.zhihu.com/p/40786748</p>]]></content>
    
    <summary type="html">
    
      借助 Emscripten，基于 ffmpeg 二次开发前端音视频功能
    
    </summary>
    
      <category term="前端" scheme="http://hikerpig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Avtech" scheme="http://hikerpig.github.io/tags/Avtech/"/>
    
      <category term="Webassembly" scheme="http://hikerpig.github.io/tags/Webassembly/"/>
    
      <category term="Emscripten" scheme="http://hikerpig.github.io/tags/Emscripten/"/>
    
  </entry>
  
  <entry>
    <title>使用 docker 构造前端构建环境</title>
    <link href="http://hikerpig.github.io/2019/02/15/2019-02-14-Setup-CI-in-docker/"/>
    <id>http://hikerpig.github.io/2019/02/15/2019-02-14-Setup-CI-in-docker/</id>
    <published>2019-02-14T16:00:00.000Z</published>
    <updated>2019-02-18T11:52:23.883Z</updated>
    
    <content type="html"><![CDATA[<p>托管在公司 gitlab 上的一个前端项目，最近在尝试 docker 化。</p><h1 id="准备阶段">准备阶段</h1><h2 id="gitlab-上的一些问题">Gitlab 上的一些问题</h2><p>如果项目不是公开的，从 docker 环境中拉取代码会有些许权限问题，可一一解决。</p><h3 id="clone-with-deploy-token">clone with deploy token</h3><p>到 Gitlab 中对应项目的 settings/repository 页面，生成 Deploy Tokens, 便可以使用 https clone 项目，不用输入用户密码，也不必使用设置相对比较麻烦的 ssh deploy key 方式。</p><p>克隆项目的命令为</p><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://&lt;name&gt;:&lt;token&gt;@gitlab.com/&lt;USER&gt;/&lt;REPO&gt;.git</code></pre><p>此处的 <code>name</code> 是 token name, 不是用户名。只对此项目生效，避免使用权限较高的用户 token。</p><h3 id="git-lfs-拉取文件出错">git-lfs 拉取文件出错</h3><p>即便使用了 deploy token 可以克隆项目文件，但其中使用 git-lfs 追踪的一些文件会失败：</p><pre><code class="hljs txt">Error downloading object: some/filename/blah: Smudge error: https://&lt;name&gt;:&lt;token&gt;@gitlab.com/some/repo.git/info/lfs/objects/batch</code></pre><p>应该是权限问题，可以越过 git-lfs 的 smudge 步骤来规避此问题。</p><pre><code class="hljs bash">GIT_LFS_SKIP_SMUDGE=1 git <span class="hljs-built_in">clone</span> &lt;SERVER-REPOSITORY&gt;</code></pre><p>参考: https://stackoverflow.com/questions/42019529/how-to-clone-pull-a-git-repository-ignoring-lfs</p><h1 id="开始">开始</h1><h2 id="dockerfile">Dockerfile</h2><pre><code class="hljs undefined"><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">8.15</span>.<span class="hljs-number">0</span>-slim<span class="hljs-comment"># install git-lfs</span><span class="hljs-keyword">RUN</span><span class="bash"> curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh |  bash</span><span class="hljs-keyword">RUN</span><span class="bash"> apt-get install -y git-lfs</span><span class="hljs-keyword">WORKDIR</span><span class="bash"> /app</span><span class="hljs-keyword">RUN</span><span class="bash"> GIT_LFS_SKIP_SMUDGE=1 git <span class="hljs-built_in">clone</span> https://&lt;name&gt;:&lt;token&gt;@gitlab.com/&lt;USER&gt;/&lt;REPO&gt;.git myrepo</span><span class="hljs-keyword">WORKDIR</span><span class="bash"> /app/myrepo</span><span class="hljs-keyword">RUN</span><span class="bash"> yarn</span></code></pre><h2 id="构建镜像">构建镜像</h2><p>在 Dockerfile 所在目录下:</p><pre><code class="hljs bash">docker build -t my-app .</code></pre><p>等待几分钟，构建完成便可使用 <code>docker inspect my-app</code> 命令看看新添加的镜像。</p><p>若 package.json 依赖较多，且可以接受在 docker host 和 vm 之间共享文件，可以去掉 <code>RUN yarn</code> 这一步，然后使用 <a href="https://docs.docker.com/storage/volumes/" target="_blank" rel="noopener">docker volume</a> 共享宿主环境中已经提前安装好的 node_modules 文件夹。</p><h2 id="启动容器">启动容器</h2><p>启动一个带 tty 的 interactive 容器并运行 bash，可以在容器里转一转，看看有什么东西:</p><pre><code class="hljs bash">docker run -v /path/to/current/node_modules:/app/myrepo/node_modules -it my-app  --name app-tty /bin/bash</code></pre><p>或是直接跑测试:</p><pre><code class="hljs bash">docker run -v /path/to/current/node_modules:/app/myrepo/node_modules -it my-app  --name <span class="hljs-built_in">test</span>-container /bin/bash -c <span class="hljs-string">'cd /app/myrepo &amp;&amp; npm run test'</span></code></pre>]]></content>
    
    <summary type="html">
    
      使用 docker 构造前端构建环境
    
    </summary>
    
      <category term="运维" scheme="http://hikerpig.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="git" scheme="http://hikerpig.github.io/tags/git/"/>
    
      <category term="前端" scheme="http://hikerpig.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="docker" scheme="http://hikerpig.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>CSS 中的两种模糊半径</title>
    <link href="http://hikerpig.github.io/2018/12/22/2018-12-22-svg-blur-and-css-text-shadow/"/>
    <id>http://hikerpig.github.io/2018/12/22/2018-12-22-svg-blur-and-css-text-shadow/</id>
    <published>2018-12-22T05:52:02.288Z</published>
    <updated>2018-12-30T04:23:40.503Z</updated>
    
    <content type="html"><![CDATA[<p>CSS 中两种实现阴影的方式</p><ol type="1"><li>text-shadow 和 box-shadow</li><li>filter: drop-shadow</li></ol><p>前者的 blur-radius 指的是阴影的最外延半径，后者的 blur-radius 指的是高斯模糊中的标准差($σ)</p><p><a href="https://drafts.csswg.org/css-backgrounds/#shadow-blur" target="_blank" rel="noopener">W3C 的 CSS 标准此处</a> 说到将 stdDeviation 设为 blur-radius 的一半可以得到近似的效果</p><blockquote><p>A non-zero blur radius indicates that the resulting shadow should be blurred, such as by a Gaussian filter. The exact algorithm is not defined; however the resulting shadow must approximate (with each pixel being within 5% of its expected value) the image that would be generated by applying to the shadow a Gaussian blur with a standard deviation equal to half the blur radius</p></blockquote><h2 id="一个实验">一个实验</h2><script async src="//jsfiddle.net/hikerpig/1wq70fgn/embed/result,html,js,css/"></script><p>相同的数值，在不同浏览器中效果不同。总体来说 drop-shadow 的结果会比 text-shadow/box-shadow 的效果更加发散和柔和。</p><h2 id="参考">参考</h2><ul><li><a href="https://dbaron.org/log/20110225-blur-radius" target="_blank" rel="noopener">What does a blur radius mean?</a></li><li><a href="https://drafts.csswg.org/css-backgrounds/#blur-radius" target="_blank" rel="noopener">Blurring Shadow Edges</a></li><li>https://github.com/w3c/fxtf-drafts/issues/102</li><li>https://bugs.chromium.org/p/chromium/issues/detail?id=677689</li><li>https://developer.mozilla.org/en-US/docs/Web/CSS/filter</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CSS 中两种实现阴影的方式&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;text-shadow 和 box-shadow&lt;/li&gt;
&lt;li&gt;filter: drop-shadow&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;前者的 blur-radius 指的是阴影的最外延半径，后者的 
      
    
    </summary>
    
      <category term="前端" scheme="http://hikerpig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="http://hikerpig.github.io/tags/CSS/"/>
    
      <category term="SVG" scheme="http://hikerpig.github.io/tags/SVG/"/>
    
  </entry>
  
  <entry>
    <title>浏览器中的字体信息测量</title>
    <link href="http://hikerpig.github.io/2018/11/15/2018-11-15-font-metrics-in-browser/"/>
    <id>http://hikerpig.github.io/2018/11/15/2018-11-15-font-metrics-in-browser/</id>
    <published>2018-11-14T16:00:00.000Z</published>
    <updated>2019-01-06T02:58:47.755Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题图来自 http://iamvdo.me/en/blog/css-font-metrics-line-height-and-vertical-align</p></blockquote><h1 id="为什么同样的-font-size-文字高度不一样">为什么同样的 font-size ，文字高度不一样？</h1><p>每个字体在设计的时候，都是基于一个 <a href="http://designwithfontforge.com/zh-CN/The_EM_Square.html" target="_blank" rel="noopener">EM Square</a>，这是活字印刷中字模的高度。</p><blockquote><p>在数字化字体中，em 是空间的数字化定义总量。在OpenType字体中，UPM或em大小通常是1000单位。在TrueType字体中，UPM约定是2的幂，通常是1024或2048。</p></blockquote><p>实际情况中，许多字体的内容高度其实是比 em box 要大的。</p><p>同是 <code>font-size: 30px</code> 情况下，此处的 Noto Sans JP 的字体空间就比 Kosugi Maru 要高。而且在字体框内，垂直方向上还有留白。</p><img src="//images-hikerpig.oss-cn-beijing.aliyuncs.com/image/fonts/noto-sans-jp-1.jpg" alt="undefined" title="undefined"><img src="//images-hikerpig.oss-cn-beijing.aliyuncs.com//image/fonts/kosugi-maru-1.jpg" alt="undefined" title="undefined"><p>垂直方向留白大小的计算公式，可以由字体文件中的定义得到：</p><blockquote><p>internal leading = ascent - descent - EM_size</p></blockquote><h1 id="代码片段">代码片段</h1><p>可以在<a href="https://jsfiddle.net/hikerpig/xkt3o4sd/4/" target="_blank" rel="noopener">这个 fiddle</a> 里看到结果。</p><h2 id="使用-canvas-度量文字宽度">使用 canvas 度量文字宽度</h2><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMetricsByCanvas</span>(<span class="hljs-params">canvas, str, font</span>) </span>&#123;  <span class="hljs-keyword">const</span> ctx = canvas.getContext(<span class="hljs-string">'2d'</span>)  ctx.font = font  <span class="hljs-built_in">console</span>.log(str, font, ctx.measureText(str))&#125;<span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">const</span> canvas = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'canvas'</span>)  <span class="hljs-built_in">document</span>.body.appendChild(canvas)  <span class="hljs-built_in">window</span>.canvas = canvas  getMetricsByCanvas(canvas, <span class="hljs-string">'字'</span>, <span class="hljs-string">'30px  Noto Sans JP'</span>) <span class="hljs-comment">// 字 30px  Noto Sans JP TextMetrics &#123;width: 30&#125;</span>&#125;</code></pre><p>不过此 API 是拿不到字符的高度的。就有一些比较黑的方法来估算字体的内容高度，例如使用大写字母 ‘M’ 的宽度作为内功高度的近似。这些技巧其实都与字形设计的惯例有关，在拉丁字母中，‘M’ 是字形最为饱满和方正的字符，高度与宽度近似。</p><p>不过明显这个惯例对于以上两个日文字体<em>并不适用</em>。</p><p>汉字因为字形多数为饱满的方块字，用宽度去估计内容高度其实更容易，例如 ‘人’ 和 ‘口’ 就很好用。</p><h2 id="创建临时-dom-元素用于度量高度">创建临时 dom 元素用于度量高度</h2><p>能拿到更全的字形盒信息</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMetricsBySpan</span>(<span class="hljs-params">str, font</span>) </span>&#123;  <span class="hljs-keyword">var</span> d = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"span"</span>);  d.style.font = font;  d.textContent = str;  <span class="hljs-built_in">document</span>.body.appendChild(d);  <span class="hljs-keyword">const</span> emHeight = d.offsetHeight;  <span class="hljs-keyword">const</span> emWidth = d.offsetWidth;  <span class="hljs-built_in">console</span>.log(str, font, &#123; emWidth, emHeight &#125;)  <span class="hljs-built_in">document</span>.body.removeChild(d);&#125;getMetricsBySpan(<span class="hljs-string">'字'</span>, <span class="hljs-string">'30px  Noto Sans JP'</span>) <span class="hljs-comment">// 字 30px  Noto Sans JP &#123;emWidth: 30, emHeight: 45&#125;</span></code></pre><h1 id="稍微不那么简单但准确的方法">稍微不那么简单但准确的方法</h1><h2 id="基于-canvas-的-fontmetrics">基于 canvas 的 FontMetrics</h2><p><a href="https://github.com/soulwire/FontMetrics" target="_blank" rel="noopener">FontMetrics</a> 这个库，先清空 canvas，将文字渲染至 canvas 上，然后逐行统计 canvas 上的像素，由此可以知道文字的上下内容边界，再与 font size 换算，便可以得到字符的高度。</p><h2 id="opentype.js">opentype.js</h2><figure><img src="https://camo.githubusercontent.com/2eae816a7d7ec3155c6136a50cc7a939eee608ca/68747470733a2f2f7261772e6769746875622e636f6d2f6f70656e747970656a732f6f70656e747970652e6a732f6d61737465722f672f68656c6c6f2d776f726c642e706e67" alt="opentype.js"><figcaption>opentype.js</figcaption></figure><p><a href="https://opentype.js.org/" target="_blank" rel="noopener">opentype.js</a> 是一个优秀的解析 OpenType 字体的 js 库。以 ArrayBuffer 传入字体的数据，解析出所有 OpenType 标准数据，完全可以基于此写出符合自己需求的排版引擎。</p><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> font = parse(buffer)<span class="hljs-keyword">const</span> g = font.charToGlyph(<span class="hljs-string">'字'</span>)<span class="hljs-keyword">const</span> bb = g.getBoundingBox()  <span class="hljs-comment">// 得出 &#123; x1, x2 , y1, y2 &#125;</span></code></pre><h1 id="参考">参考</h1><p><a href="https://stackoverflow.com/questions/1134586/how-can-you-find-the-height-of-text-on-an-html-canvas" target="_blank" rel="noopener">SO 上的一个问题</a></p><p><a href="https://www.freetype.org/freetype2/docs/glyphs/glyphs-3.html" target="_blank" rel="noopener">FreeType Glyph Metrics</a></p><p><a href="https://www.html5rocks.com/en/tutorials/canvas/texteffects/#toc-text-shadow-clipping" target="_blank" rel="noopener">Typographic effects in canvas</a></p><p><a href="http://iamvdo.me/en/blog/css-font-metrics-line-height-and-vertical-align" target="_blank" rel="noopener">Deep dive CSS: font metrics, line-height and vertical-align</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;题图来自 http://iamvdo.me/en/blog/css-font-metrics-line-height-and-vertical-align&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;为什么同样的-font-size-文字高
      
    
    </summary>
    
      <category term="前端" scheme="http://hikerpig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="浏览器" scheme="http://hikerpig.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="字体" scheme="http://hikerpig.github.io/tags/%E5%AD%97%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>SVG 元素的自定义  transform origin</title>
    <link href="http://hikerpig.github.io/2018/08/26/2018-08-26-beware-of-svg-transform/"/>
    <id>http://hikerpig.github.io/2018/08/26/2018-08-26-beware-of-svg-transform/</id>
    <published>2018-08-25T16:00:00.000Z</published>
    <updated>2018-09-26T06:07:34.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不要使用-transform-origin-属性">不要使用 transform-origin 属性</h2><p>SVG 支持 <code>transform</code>，而且写法似乎与 CSS 中相同，但是它的<a href="https://www.w3.org/TR/SVG11/coords.html" target="_blank" rel="noopener">标准</a>里并不支持 <code>transform-origin</code> 属性。虽然在部分浏览器中，给 SVG 元素指定 <code>transform-origin</code> 似乎是有效果的（写法和结果也与 CSS 一样），但是无法指望这个行为在所有浏览器里都有效。</p><h1 id="自行解释-transformorigin">自行解释 transformOrigin</h1><p>既然不能通过 attribute 来指定变换原点，我们只好通过对其他 transform 值的变动来实现想要的效果了。</p><p>首先建立一个对象系统</p><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> Display &#123;  x: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>  y: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>  width: <span class="hljs-built_in">number</span>  height: <span class="hljs-built_in">number</span>  scale: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]  transformOrigin?: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>]  parent?: Display  element: SVGElement  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) &#123;     <span class="hljs-keyword">this</span>.element = <span class="hljs-keyword">this</span>.createElement() <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>  &#125;  createElement() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'g'</span>)  &#125;  addChild(child: Display) &#123;    child.parent = <span class="hljs-keyword">this</span>    <span class="hljs-keyword">this</span>.element.appendChild(child.element)  &#125;&#125;<span class="hljs-keyword">class</span> Rect <span class="hljs-keyword">extends</span> Display &#123;  createElement() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'rect'</span>)  &#125;&#125;</code></pre><p>此时有</p><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> r1 = <span class="hljs-keyword">new</span> Rect(&#123;  name: <span class="hljs-string">"r1"</span>,  x: <span class="hljs-number">10</span>,  y: <span class="hljs-number">10</span>,  width: <span class="hljs-number">100</span>,  height: <span class="hljs-number">50</span>,&#125;)<span class="hljs-keyword">const</span> r2 = <span class="hljs-keyword">new</span> Rect(&#123;  name: <span class="hljs-string">"r2"</span>,  x: <span class="hljs-number">10</span>,  y: <span class="hljs-number">10</span>,  width: <span class="hljs-number">100</span>,  height: <span class="hljs-number">50</span>,  scale: [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>],&#125;)</code></pre><p>经过简单的属性到 dom 的操作，得到</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">rect</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"r1"</span> <span class="hljs-attr">transform</span>=<span class="hljs-string">"translate(10,10)"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"100"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"50"</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">"blue"</span> <span class="hljs-attr">opacity</span>=<span class="hljs-string">"0.8"</span> /&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">rect</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"r2"</span> <span class="hljs-attr">transform</span>=<span class="hljs-string">"translate(10,10) scale(2,2)"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"100"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"50"</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">"red"</span> <span class="hljs-attr">opacity</span>=<span class="hljs-string">"0.8"</span> /&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span></code></pre><svg style="background: #CCC">&lt;rect name=“r1” transform=“translate(10,10)” width=“100” height=“50” fill=“blue” opacity=“0.8” /&gt; <rect name="r2" transform="translate(10,10) scale(2,2)" width="100" height="50" fill="red" opacity="0.8"/></svg><p>r2 的变换，先平移再缩放，平移的结果就是缩放的原点。</p><p>此处将 x/y 转为 translate 而不是 <code>x</code> 和 <code>y</code> 属性，是为了以统一的方式做坐标系的转换和运算，且考虑到许多元素没有 <code>x</code> 和 <code>y</code> 属性（如 <code>circle</code> 就只有 <code>cx</code> 和 <code>cy</code> ），但所有 SVG 元素都支持 transform 。</p><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formTransform</span>(<span class="hljs-params">d: Display</span>) </span>&#123;  <span class="hljs-keyword">const</span> scales = d.scale  <span class="hljs-keyword">const</span> scaleX = scales[<span class="hljs-number">0</span>]  <span class="hljs-keyword">const</span> scaleY = scales[<span class="hljs-number">1</span>]  <span class="hljs-keyword">return</span> <span class="hljs-string">`translate(<span class="hljs-subst">$&#123;d.x&#125;</span>,<span class="hljs-subst">$&#123;d.y&#125;</span>) scale(<span class="hljs-subst">$&#123;scaleX&#125;</span>,<span class="hljs-subst">$&#123;scaleY&#125;</span>)`</span>&#125;</code></pre><h2 id="带位移补偿的缩放">带位移补偿的缩放</h2><p>计算缩放的位移补偿值，使得缩放再位移后效果就与以变换原点为中心缩放一样。</p><p>假设在缩放系数为 S 时，我们需要的 translate 为 <span class="math inline">TR</span>，变换完的结果：</p><p><span class="math display">x&#39;=(x+TR_x)\times S_x\\\\y&#39;=(y+TR_y)\times S_y</span></p><p>当以变换原点为特征点时，方程易于构建与求解。</p><p>令 <span class="math inline">T_x</span> 和 <span class="math inline">T_y</span> 为变换原点相对于原坐标系左上角的坐标，当 <span class="math inline">x=T_x,\  y=T_y</span> 时，代入得到：</p><p><span class="math display">TO_{x} \ \ =\ ( TO_{x} \ +TR_{x}) \times S_{x}\\\\TO_{y} \ \ =\ ( TO_{y} \ +TR_{y}) \times S_{y}</span></p><p>所以：</p><p><span class="math display">TR_{x} \ =\frac{( 1-S_{x}) \times TO_{x}}{S_{x}}\\\\\\\\TR_{y} \ =\frac{( 1-S_{y}) \times TO_{y}}{S_{y}}</span></p><p>带缩放修正值的 transform 计算方法改为：</p><pre><code class="hljs diff">   const scales = d.scale   const scaleX = scales[0]   const scaleY = scales[1]<span class="hljs-deletion">-  return `translate($&#123;d.x&#125;,$&#123;d.y&#125;) scale($&#123;scaleX&#125;,$&#123;scaleY&#125;)`</span><span class="hljs-addition">+</span><span class="hljs-addition">+  let xToOrigin = d.width / 2</span><span class="hljs-addition">+  let yToOrigin = d.height / 2</span><span class="hljs-addition">+  if (d.transformOrigin) &#123;</span><span class="hljs-addition">+    xToOrigin = d.transformOrigin[0]</span><span class="hljs-addition">+    yToOrigin = d.transformOrigin[1]</span><span class="hljs-addition">+  &#125;</span><span class="hljs-addition">+  const revisedX = (1 - scaleX) * xToOrigin</span><span class="hljs-addition">+  const revisedY = (1 - scaleY) * yToOrigin</span><span class="hljs-addition">+</span><span class="hljs-addition">+  return `translate($&#123;d.x&#125;,$&#123;d.y&#125;) scale($&#123;scaleX&#125;,$&#123;scaleY&#125;) translate($&#123;revisedX&#125;,$&#123;revisedY&#125;)`</span> &#125;</code></pre><p>例如一个缩放为2倍，</p><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> r3 = <span class="hljs-keyword">new</span> Rect(&#123;  x: <span class="hljs-number">50</span>,  y: <span class="hljs-number">50</span>,  width: <span class="hljs-number">100</span>,  height: <span class="hljs-number">50</span>,  scale: [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>],  transformOrigin: [<span class="hljs-number">50</span>, <span class="hljs-number">25</span>],&#125;)</code></pre><p>对应于缩放的变换应该是 <code>scale(2,2) translate(-25,-12.5)</code>，再加上元素本身的位移，最后得到：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">rect</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"r3"</span> <span class="hljs-attr">transform</span>=<span class="hljs-string">"translate(50,50) scale(2,2) translate(-25,-12.5)"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"100"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"50"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span></code></pre><p>变换过程示意:</p><img src="//images-hikerpig.oss-cn-beijing.aliyuncs.com/image/trans-demo-1.svg" alt="变换过程示意" title="变换过程示意"><h2 id="参考">参考</h2><ul><li><a href="https://www.sarasoueidan.com/blog/svg-coordinate-systems/" target="_blank" rel="noopener">svg-coordinate-systems</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;不要使用-transform-origin-属性&quot;&gt;不要使用 transform-origin 属性&lt;/h2&gt;
&lt;p&gt;SVG 支持 &lt;code&gt;transform&lt;/code&gt;，而且写法似乎与 CSS 中相同，但是它的&lt;a href=&quot;https://www.w3
      
    
    </summary>
    
      <category term="前端" scheme="http://hikerpig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="SVG" scheme="http://hikerpig.github.io/tags/SVG/"/>
    
  </entry>
  
  <entry>
    <title>Goodbye My Santa Monica Dream 🎵</title>
    <link href="http://hikerpig.github.io/2018/07/31/2018-07-31-Goodbye%20My%20Santa%20Monica%20Dream/"/>
    <id>http://hikerpig.github.io/2018/07/31/2018-07-31-Goodbye My Santa Monica Dream/</id>
    <published>2018-07-30T16:00:00.000Z</published>
    <updated>2018-08-26T08:49:59.529Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&amp;id=30496500&amp;auto=1&amp;height=66"></iframe><p>从《Life is strange》的原声带中发现的瑰宝，来自澳大利亚的兄妹组合 <a href="https://music.douban.com/musician/100215/" target="_blank" rel="noopener">Angus &amp; Julia Stone</a> 的一首略显忧伤的曲子，他俩前几年的曲风，小清新中带着些许迷幻。妹妹声音空灵慵懒，像加州的海风，棕榈叶间斑驳的阳光，和歌词特别配。</p><p>原曲使用 Open D 调弦，变调夹 3 品，感谢 <a href="http://www.goliathguitartutorials.com" target="_blank" rel="noopener">Goliath Guitar</a> 在 <a href="https://www.youtube.com/watch?v=sOJMMpdWScM" target="_blank" rel="noopener">Youtube 上的教程</a>，讲解详细，也给出了还原度几乎 100% 的伴奏谱子，而且非常好弹。pdf 谱例可以<a href="http://www.goliathguitartutorials.com/santa-monica-dream.html" target="_blank" rel="noopener">去这里下载</a>。</p><img src="//images-hikerpig.oss-cn-beijing.aliyuncs.com/image/tabs/santa_monica_dream_-_angus_and_julia.jpg" alt="undefined" title="undefined">]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;amp
      
    
    </summary>
    
      <category term="杂记" scheme="http://hikerpig.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="吉他" scheme="http://hikerpig.github.io/tags/%E5%90%89%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>Vuex 模块动态注册的一些实践经验</title>
    <link href="http://hikerpig.github.io/2018/07/03/2018-07-03-Vuex-Dynamic-Module-Hints/"/>
    <id>http://hikerpig.github.io/2018/07/03/2018-07-03-Vuex-Dynamic-Module-Hints/</id>
    <published>2018-07-02T16:00:00.000Z</published>
    <updated>2019-01-07T05:50:06.415Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>构建大型 SPA 应用时，代码分割和懒加载是比较常用的优化手段，在 Vue 生态下，使用 vue-router 很容易实现组件的懒加载。</p><p>但应用里除了组件，还有庞大的业务逻辑，这部分如何分割和懒加载比较合适呢？</p><p>使用 Vuex 管理状态的话，其提供了方法 <code>registerModule</code> 用于<a href="https://vuex.vuejs.org/guide/modules.html#dynamic-module-registration" target="_blank" rel="noopener">动态注册</a> Module。</p><p>因此某个页面独有的业务逻辑和状态管理，在初始化全局 store 的时候可以不用引入，之后在该页面路由组件中再引入和注册 Vuex 模块。</p><h1 id="简单的示例">简单的示例</h1><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> PageA = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./views/PageA.js'</span>)<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;  <span class="hljs-attr">routes</span>: [    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'/page-a'</span>, <span class="hljs-attr">component</span>: PageA &#125;  ]&#125;)</code></pre><p>简单的 Vuex 模块：</p><pre><code class="hljs javascript"><span class="hljs-comment">// store/modules/page-a.js</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> VUEX_NS = <span class="hljs-string">'page-a'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-attr">namespaced</span>: <span class="hljs-literal">true</span>,  state() &#123;    <span class="hljs-keyword">return</span> &#123;      <span class="hljs-attr">inventory</span>: &#123;        <span class="hljs-attr">list</span>: []      &#125;    &#125;  &#125;,  <span class="hljs-attr">getters</span>: &#123;    inventoryList(state) &#123;      <span class="hljs-keyword">return</span> state.inventory.list    &#125;  &#125;&#125;</code></pre><p>实践时遭遇了几个问题：</p><h2 id="问题-1服务器客户端-在尚未注册-module-时调用其下的-actionmutation-vuex-因找不到对应函数而出错">问题 1：服务器/客户端 在尚未注册 Module 时，调用其下的 action/mutation ，Vuex 因找不到对应函数而出错</h2><pre><code class="hljs javascript"><span class="hljs-comment">// views/PageA.js</span><span class="hljs-keyword">import</span> PAGE_A_MODULE, &#123; VUEX_NS &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'store/modules/page-a'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">'PageA'</span>,  beforeCreate() &#123;    <span class="hljs-keyword">this</span>.$store.registerModule(VUEX_NS, PAGE_A_MODULE)    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.$store.dispatch(<span class="hljs-string">`<span class="hljs-subst">$&#123;VUEX_NS&#125;</span>/fetchInventory`</span>)  &#125;,&#125;</code></pre><h3 id="考虑服务器端预取数据注入给客户端的时候">考虑服务器端预取数据注入给客户端的时候</h3><p>客户（浏览器）端初始化代码，在初始化 router 之前，给 Vuex 全局 store 注入数据：</p><pre><code class="hljs js"><span class="hljs-comment">// entry-client.js</span>store.replaceState(<span class="hljs-built_in">window</span>.__INITIAL_STATE__)</code></pre><p>此处的 <code>__INITIAL_STATE__</code> 是 Vue SSR 提供的一个功能，使得浏览器端可以复用服务器端已经预取过的数据。</p><pre><code class="hljs js"><span class="hljs-comment">// 在所有预取钩子(preFetch hook) resolve 后，</span><span class="hljs-comment">// 我们的 store 现在已经填充入渲染应用程序所需的状态。</span><span class="hljs-comment">// 当我们将状态附加到上下文，</span><span class="hljs-comment">// 并且 `template` 选项用于 renderer 时，</span><span class="hljs-comment">// 状态将自动序列化为 `window.__INITIAL_STATE__`，并注入 HTML。</span>context.state = store.state</code></pre><p>此处的 <code>asyncData</code> 与 <a href="https://ssr.vuejs.org/zh/guide/data.html#%E6%95%B0%E6%8D%AE%E9%A2%84%E5%8F%96%E5%AD%98%E5%82%A8%E5%AE%B9%E5%99%A8-data-store" target="_blank" rel="noopener">Vue SSR 文档中的例子</a>类似，与 Nuxt.js 中的同名函数用法略有不同。</p><p><code>prepareVuex</code> 为自定义的组件钩子函数，会先于 asyncData 调用，具体过程之后探讨。</p><pre><code class="hljs diff"> export default &#123;   name: 'PageA',<span class="hljs-deletion">-  beforeCreate() &#123;</span><span class="hljs-deletion">-    this.$store.registerModule(VUEX_NS, PAGE_A_MODULE)</span><span class="hljs-deletion">-    return this.$store.dispatch(`$&#123;VUEX_NS&#125;/fetchInventory`)</span><span class="hljs-addition">+  prepareVuex(&#123; store &#125;) &#123;</span><span class="hljs-addition">+    store.registerModule(VUEX_NS, PAGE_A_MODULE)</span><span class="hljs-addition">+  &#125;,</span><span class="hljs-addition">+  asyncData(&#123; store &#125;) &#123;</span><span class="hljs-addition">+    return store.dispatch(`$&#123;VUEX_NS&#125;/fetchInventory`)</span>   &#125;, &#125;</code></pre><p>此时会遇见</p><h2 id="问题2-客户端没有用上服务器端预取的数据">问题2: 客户端没有用上服务器端预取的数据</h2><p>解决方式：</p><pre><code class="hljs diff"> export default &#123;   name: 'PageA',<span class="hljs-deletion">-  prepareVuex(&#123; store &#125;) &#123;</span><span class="hljs-deletion">-    store.registerModule(VUEX_NS, PAGE_A_MODULE)</span><span class="hljs-addition">+  prepareVuex(&#123; store, isClientInitialRoute &#125;) &#123;</span><span class="hljs-addition">+    store.registerModule(VUEX_NS, PAGE_A_MODULE, &#123; preserveState: isClientInitialRoute &#125;)</span>   &#125;,   asyncData(&#123; store &#125;) &#123;     return store.dispatch(`$&#123;VUEX_NS&#125;/fetchInventory`)   &#125;,<span class="hljs-addition">+  beforeDestroy() &#123;</span><span class="hljs-addition">+    // 销毁该模块</span><span class="hljs-addition">+    this.$store.unregisterModule(VUEX_NS)</span><span class="hljs-addition">+  &#125;</span> &#125;</code></pre><p>注册 Vuex 模块的时候使用了 <code>preserveState</code> ，若启用此选项，注册 Module 时若 <code>store.state[namespace]</code> 下已存在数据，便不会使用声明 vuex 模块时的初始 state 覆盖已有数据。但需要注意，若 state 中没有 namespace 相应数据却开启了此选项，Vuex 还是会报错。因此此处添加了一个输入参数 <code>isClientInitialRoute</code> ， 只有在客户端初次进入页面（可以使用服务器预取数据）时才开启 <code>preserveState</code> 选项。</p><h2 id="问题3-组件热更新时vuex-模块被销毁">问题3: 组件热更新时，Vuex 模块被销毁</h2><p>开发期间使用 HotModuleReplacementPlugin 和 vue-loader，若改变了 PageA.js 中的代码，会触发热更新。在 <a href="https://github.com/vuejs/vue-hot-reload-api/blob/master/src/index.js" target="_blank" rel="noopener">vue-hot-reload-api</a> 中，当使用 vue-hot-reload-api 的 <code>reload</code> 方法处理组件实例时，该实例会被销毁而后重新创建。<code>beforeDestroy</code> 中销毁了 Vuex 的 <code>page-a</code> 模块，却没有调用 <code>prepareVuex</code> 方法重新注册，因此热更新之后，使用该模块也会报错。</p><p>解决方案：</p><pre><code class="hljs diff">   asyncData(&#123; store &#125;) &#123;     return store.dispatch(`$&#123;VUEX_NS&#125;/fetchInventory`)   &#125;,<span class="hljs-deletion">-  beforeDestroy() &#123;</span><span class="hljs-deletion">-    // 销毁该模块</span><span class="hljs-deletion">-    this.$store.unregisterModule(VUEX_NS)</span><span class="hljs-addition">+  beforeRouteLeave(to, from, next) &#123;</span><span class="hljs-addition">+    this.$once('hook:beforeDestroy', () =&gt; &#123;</span><span class="hljs-addition">+      // 销毁该模块</span><span class="hljs-addition">+      this.$store.unregisterModule(VUEX_NS)</span><span class="hljs-addition">+    &#125;)</span><span class="hljs-addition">+    next()</span>   &#125; &#125;</code></pre><p>仔细想想，注册模块的时机是与路由相关的（进入页面之前），那么销毁的时机也可以与路由相关。不过并不适合在 <code>beforeRouteLeave</code> 钩子中立刻销毁模块。因为根据以下 vue-router 文档内容，在此钩子被调用完成时，整个页面还是在正常工作的（第2步到第11步中间），仍未进入组件的 destroy 过程，此时销毁模块会导致依赖其的所有组件异常。</p><blockquote><p><cite><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%AF%BC%E8%88%AA%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B" target="_blank" rel="noopener">vue-router 文档中关于导航解析流程的部分</a></cite></p><ol type="1"><li>导航被触发。</li><li>在失活的组件里调用离开守卫。</li><li>调用全局的 beforeEach 守卫。</li><li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li><li>在路由配置里调用 beforeEnter。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 beforeRouteEnter。</li><li>调用全局的 beforeResolve 守卫 (2.5+)。</li><li>导航被确认。</li><li>调用全局的 afterEach 钩子。</li><li>触发 DOM 更新。</li><li>用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</li></ol></blockquote><p>因此安全的模块销毁时机需要在 DOM 更新中或后，旧的页面组件实例销毁过程调用时。</p><h1 id="相关代码">相关代码</h1><p>最后的 PageA.js：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> PAGE_A_MODULE, &#123; VUEX_NS &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'store/modules/page-a'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">'PageA'</span>,  prepareVuex(&#123; store, isClientInitialRoute &#125;) &#123;    store.registerModule(VUEX_NS, PAGE_A_MODULE, &#123; <span class="hljs-attr">preserveState</span>: isClientInitialRoute &#125;)  &#125;,  asyncData(&#123; store &#125;) &#123;    <span class="hljs-keyword">return</span> store.dispatch(<span class="hljs-string">`<span class="hljs-subst">$&#123;VUEX_NS&#125;</span>/fetchInventory`</span>)  &#125;,  beforeRouteLeave(to, <span class="hljs-keyword">from</span>, next) &#123;    <span class="hljs-keyword">this</span>.$once(<span class="hljs-string">'hook:beforeDestroy'</span>, () =&gt; &#123;      <span class="hljs-comment">// 销毁该模块</span>      <span class="hljs-keyword">this</span>.$store.unregisterModule(VUEX_NS)    &#125;)    next()  &#125;&#125;</code></pre><p>两端的入口文件中相关代码如下：</p><pre><code class="hljs typescript"><span class="hljs-comment">// router-util.ts</span><span class="hljs-keyword">import</span> Vue, &#123; VueConstructor &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><span class="hljs-keyword">type</span> VueCtor = VueConstructor&lt;<span class="hljs-built_in">any</span>&gt;<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getHookFromComponent</span>(<span class="hljs-params">compo: <span class="hljs-built_in">any</span>, name: <span class="hljs-built_in">string</span></span>) </span>&#123;  <span class="hljs-keyword">return</span> compo[name] || (compo.options &amp;&amp; compo.options[name])&#125;<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callComponentsHookWith</span>(<span class="hljs-params">compoList: VueCtor[], hookName: <span class="hljs-built_in">string</span>, context: <span class="hljs-built_in">any</span></span>) </span>&#123;  <span class="hljs-keyword">return</span> compoList.map(<span class="hljs-function">(<span class="hljs-params">component</span>) =&gt;</span> &#123;    <span class="hljs-keyword">const</span> hook = getHookFromComponent(component, hookName)    <span class="hljs-keyword">if</span> (hook) &#123;      <span class="hljs-keyword">return</span> hook(context)    &#125;  &#125;).filter(_ =&gt; _)&#125;</code></pre><pre><code class="hljs js"><span class="hljs-comment">// entry-server.js</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> context =&gt; &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-comment">// set router's location</span>    router.push(context.url)    router.onReady(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      <span class="hljs-keyword">const</span> matchedComponents = router.getMatchedComponents()      <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 加上 try/catch 避免此 block 内抛出的错误造成 promise unhandledRejection</span>        callComponentsHookWith(matchedComponents, <span class="hljs-string">'prepareVuex'</span>, &#123; store &#125;)        <span class="hljs-keyword">const</span> asyncDataResults = callComponentsHookWith(matchedComponents, <span class="hljs-string">'asyncData'</span>,          &#123;            store,            <span class="hljs-attr">route</span>: router.currentRoute,          &#125;        )        <span class="hljs-built_in">Promise</span>.all(asyncDataResults).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;          context.state = store.state          resolve(app)        &#125;).catch(reject)      &#125; <span class="hljs-keyword">catch</span>(err) &#123;        reject(err)      &#125;    &#125;, reject)  &#125;)&#125;</code></pre><pre><code class="hljs js"><span class="hljs-comment">// entry-client.js</span>router.onReady(<span class="hljs-function">(<span class="hljs-params">initialRoute</span>) =&gt;</span> &#123;  <span class="hljs-keyword">const</span> initialMatched = router.getMatchedComponents(initialRoute)  callComponentsHookWith(initialMatched, <span class="hljs-string">'prepareVuex'</span>, &#123; store, <span class="hljs-attr">isClientInitialRoute</span>: <span class="hljs-literal">true</span> &#125;)  router.beforeResolve(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;    <span class="hljs-keyword">const</span> matched = router.getMatchedComponents(to)    callComponentsHookWith(matched, <span class="hljs-string">'prepareVuex'</span>, &#123; store &#125;)    <span class="hljs-built_in">Promise</span>.all(callComponentsHookWith(activated, <span class="hljs-string">'asyncData'</span>, &#123; store, <span class="hljs-attr">route</span>: to &#125;))      .then(next)      .catch(next)  &#125;)  <span class="hljs-comment">// actually mount to DOM</span>  app.$mount(<span class="hljs-string">'#app'</span>)&#125;)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;构建大型 SPA 应用时，代码分割和懒加载是比较常用的优化手段，在 Vue 生态下，使用 vue-router 很容易实现组件的懒加载。&lt;/p&gt;
&lt;p&gt;但应用里除了组件，还有庞大的业务逻辑，这部分如何分割和懒加载比较合适呢？&lt;/p&gt;

      
    
    </summary>
    
      <category term="前端" scheme="http://hikerpig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://hikerpig.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Try Rust WebAssembly</title>
    <link href="http://hikerpig.github.io/2018/05/03/2018-05-03-Try-Rust-Webassemly/"/>
    <id>http://hikerpig.github.io/2018/05/03/2018-05-03-Try-Rust-Webassemly/</id>
    <published>2018-05-02T16:00:00.000Z</published>
    <updated>2018-08-26T08:50:19.060Z</updated>
    
    <content type="html"><![CDATA[<p>在公司项目里的一个小角落，尝试使用 Rust + WebAssembly 加速应用里部分计算</p><h2 id="选择">选择</h2><p>首先要分清项目里 WebAssembly 的定位</p><ol type="1"><li>应用主体：完成绝大多数逻辑，JS 只作为加载入口和少部分事件绑定桥梁</li><li>工具库：分担一些复杂和耗时的计算，由 JS 决定什么时候调用 wasm 模块函数，通常情况下，由 JS 管理 wasm 的线性内存</li></ol><p>此次小 Demo 属于第 2 种情况</p><h3 id="选择-rust-target">选择 Rust Target</h3><p>rust 支持 <code>wasm32-unknown-unknown</code> 和 <code>wasm32-unknown-emscripten</code> 两种编译目标，后者除了wasm 外，还生成了 emscripten 风格的 JS 作为入口，与 asm.js 的调用风格统一。不过会添加好些运行时代码，与 wasm 之间也隔着一层封装。基于上一项的选择，我们选择前者</p><pre><code class="hljs bash">rustup target add wasm32-unknown-unknown</code></pre><h1 id="webassembly-考量">WebAssembly 考量</h1><h2 id="数据类型问题">数据类型问题</h2><p>WebAssembly 当前只支持几种<a href="https://developer.mozilla.org/en-US/docs/WebAssembly/Understanding_the_text_format#Signatures_and_parameters" target="_blank" rel="noopener">有限的数字类型</a>，i32/i64/f32/f64，JS 与之交互时，除了 number 以外的值都要有序列化/反序列化处理。</p><h3 id="字符串">字符串</h3><p>可使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/TextEncoder" target="_blank" rel="noopener">TextEncoder/TextDecoder</a> 将 JS 字符串序列化为 utf-8 字节流，在 Rust 端先将字节流解析为字符串，再使用。</p><h3 id="数组">数组</h3><p>JS 直接操作 wasm 示例的内存，将数组数据写入，调用 wasm 方法时，将数组起始的指针以及数组长度作为参数。</p><pre><code class="hljs rust"><span class="hljs-comment">// rust 部分</span><span class="hljs-keyword">pub</span> <span class="hljs-keyword">unsafe</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">load_image_data</span></span>(in_image_ptr: *<span class="hljs-keyword">mut</span> <span class="hljs-built_in">u8</span>, width: <span class="hljs-built_in">i32</span>, height: <span class="hljs-built_in">i32</span>) -\&gt; *<span class="hljs-keyword">const</span> <span class="hljs-built_in">u8</span> &#123;  <span class="hljs-keyword">let</span> arr_len = (width * height * <span class="hljs-number">4</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;  <span class="hljs-keyword">let</span> in_image_data = <span class="hljs-built_in">Vec</span>::from_raw_parts(in_image_ptr, arr_len, arr_len);  <span class="hljs-keyword">return</span> in_image_data.as_ptr();&#125;</code></pre><pre><code class="hljs ts"><span class="hljs-comment">// js 部分</span><span class="hljs-keyword">const</span> ctx = canvas.getContext(<span class="hljs-string">'2d'</span>)<span class="hljs-keyword">const</span> imageData = ctx.getImageData(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>)<span class="hljs-keyword">const</span> imgDataVecPtr = copyJsArrayToRust(<span class="hljs-keyword">this</span>.instanceExports, imageData.data)wasmExports.load_image_data(imgDataVecPtr, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>)<span class="hljs-string">`</span></code></pre><h2 id="上代码">上代码</h2><h3 id="rust-端">Rust 端</h3><pre><code class="hljs rust"><span class="hljs-comment">// main.rs</span><span class="hljs-keyword">use</span> std::&#123;mem&#125;;<span class="hljs-keyword">use</span> std::ffi::CString;<span class="hljs-keyword">use</span> std::os::raw::&#123;c_char&#125;;<span class="hljs-keyword">extern</span> &#123;  <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">clog</span></span>(ptr: *<span class="hljs-keyword">const</span> <span class="hljs-built_in">u8</span>, number: <span class="hljs-built_in">usize</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">js_log</span></span>(s: <span class="hljs-built_in">String</span>) &#123;  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> _s = s.clone();  <span class="hljs-keyword">unsafe</span> &#123;  <span class="hljs-keyword">let</span> m = _s.as_mut_vec().as_mut_ptr();  clog(m <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-built_in">u8</span>, _s.len());  &#125;&#125;<span class="hljs-meta">#[no_mangle]</span><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">alloc</span></span>(size: <span class="hljs-built_in">usize</span>) -&gt; *<span class="hljs-keyword">const</span> <span class="hljs-built_in">u8</span> &#123;  <span class="hljs-keyword">let</span> buf = <span class="hljs-built_in">Vec</span>::with_capacity(size);  <span class="hljs-keyword">let</span> ptr = buf.as_ptr();  mem::forget(buf); <span class="hljs-comment">// 让 rust 放弃对此段内存的控制权，此函数结束后该段内存对于 rust 来说是泄漏的状态，分配和管理权交给 JS</span>  <span class="hljs-keyword">return</span> ptr;&#125;<span class="hljs-meta">#[no_mangle]</span><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">log_something</span></span>(text_ptr: *<span class="hljs-keyword">mut</span> c_char) -&gt; *<span class="hljs-keyword">const</span> <span class="hljs-built_in">u8</span> &#123;  <span class="hljs-keyword">let</span> text = CString::from_raw(text_ptr).into_string().unwrap();  js_log(text);&#125;<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;&#125;  <span class="hljs-comment">// 留一个 main 确保 rust 能正常编译</span></code></pre><h3 id="js-端">JS 端</h3><pre><code class="hljs ts"><span class="hljs-comment">// wasm-util.ts</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> ModuleExports &#123;  memory: WebAssembly.Memory  alloc(len: <span class="hljs-built_in">number</span>): WasmMemPtr  log_something(text_ptr: <span class="hljs-built_in">number</span>)&#125;<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadWebAssembly</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">ModuleExports</span>&gt;(<span class="hljs-params">input: <span class="hljs-built_in">string</span>, imports: <span class="hljs-built_in">any</span></span>) </span>&#123;  <span class="hljs-comment">// Fetch the file and compile it</span>  <span class="hljs-keyword">return</span> fetch(input).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.arrayBuffer())  .then(<span class="hljs-function"><span class="hljs-params">buffer</span> =&gt;</span> &#123;    <span class="hljs-comment">// Create the imports for the module, including the</span>    <span class="hljs-comment">// standard dynamic library imports</span>    imports = imports || &#123;&#125;    imports.env = imports.env || &#123;&#125;    <span class="hljs-keyword">if</span> (!imports.env.memory) &#123;  imports.env.memory = <span class="hljs-keyword">new</span> WebAssembly.Memory(&#123; initial: <span class="hljs-number">1</span> &#125;)    &#125;    <span class="hljs-comment">// Create the instance.</span>    <span class="hljs-keyword">return</span> WebAssembly.instantiate(buffer, imports)  &#125;)&#125;<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copyJsStringToRust</span>(<span class="hljs-params"><span class="hljs-built_in">module</span>: ModuleExports, str: <span class="hljs-built_in">string</span></span>) </span>&#123;  <span class="hljs-keyword">const</span> utf8Encoder = <span class="hljs-keyword">new</span> TextEncoder()  <span class="hljs-keyword">const</span> string_buffer = utf8Encoder.encode(str)  <span class="hljs-keyword">const</span> len = string_buffer.length  <span class="hljs-keyword">const</span> ptr = <span class="hljs-built_in">module</span>.alloc(len + <span class="hljs-number">1</span>)  <span class="hljs-keyword">const</span> memory = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(<span class="hljs-built_in">module</span>.memory.buffer, ptr)  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;    memory[i] = string_buffer[i]  &#125;  memory[len] = <span class="hljs-number">0</span> <span class="hljs-comment">// cstring end</span>  <span class="hljs-keyword">return</span> ptr&#125;<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">decodeRustString</span>(<span class="hljs-params"><span class="hljs-built_in">module</span>: ModuleExports, ptr: WasmMemPtr</span>) </span>&#123;  <span class="hljs-keyword">const</span> collectCString = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">const</span> memory = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(<span class="hljs-built_in">module</span>.memory.buffer)  <span class="hljs-keyword">while</span> (memory[ptr] !== <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">if</span> (memory[ptr] === <span class="hljs-literal">undefined</span>) &#123;  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Tried to read undef mem'</span>)    &#125;    <span class="hljs-keyword">yield</span> memory[ptr]    ptr += <span class="hljs-number">1</span>  &#125;  &#125;  <span class="hljs-keyword">const</span> buffer_as_u8 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(collectCString())  <span class="hljs-keyword">const</span> utf8Decoder = <span class="hljs-keyword">new</span> TextDecoder()  <span class="hljs-keyword">const</span> buffer_as_utf8 = utf8Decoder.decode(buffer_as_u8)  <span class="hljs-keyword">return</span> buffer_as_utf8&#125;<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copyJsArrayToRust</span>(<span class="hljs-params">exports: ModuleExports, arr: <span class="hljs-built_in">number</span>[] | <span class="hljs-built_in">Uint8ClampedArray</span></span>) </span>&#123;  <span class="hljs-keyword">const</span> &#123; memory, alloc &#125; = exports  <span class="hljs-keyword">const</span> rVecPtr = alloc(arr.length)  <span class="hljs-keyword">const</span> asBytes = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(memory.buffer, rVecPtr, arr.length)  asBytes.set(arr)  <span class="hljs-keyword">return</span> rVecPtr&#125;</code></pre><p>demo.ts</p><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123;copyJsStringToRust, decodeRustString&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./wasm-util'</span><span class="hljs-keyword">const</span> importObj = &#123;  env: &#123;    clog: <span class="hljs-function">(<span class="hljs-params">ptr: WasmMemPtr, <span class="hljs-built_in">number</span>: <span class="hljs-built_in">number</span></span>) =&gt;</span> &#123;    <span class="hljs-keyword">const</span> str = decodeRustString(<span class="hljs-keyword">this</span>.rut.instanceExports, ptr)    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"[rust] "</span> + str)    &#125;,  &#125;&#125;loadWebAssembly(<span class="hljs-string">'demo.wasm'</span>).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-keyword">const</span> strPtr = copyJsStringToRust(wasmExports, <span class="hljs-string">'Heyhey you you'</span>)  wasmExports.log_something(strPtr)&#125;)<span class="hljs-comment">// '[rust] Heyhey you you'</span></code></pre><h2 id="编译-wasm">编译 WASM</h2><pre><code class="hljs bash">cargo rustc --release --target=wasm32-unknown-unknown</code></pre><h2 id="wasm-瘦身">WASM 瘦身</h2><p>参见<a href="https://rust-lang-nursery.github.io/rust-wasm/game-of-life/code-size.html" title="WASM 瘦身" target="_blank" rel="noopener">此文</a></p><h3 id="cargo.toml-中一些设定">Cargo.toml 中一些设定</h3><pre><code class="hljs undefined"><span class="hljs-section">[profile.release]</span><span class="hljs-attr">debug</span> = <span class="hljs-literal">false</span><span class="hljs-attr">lto</span> = <span class="hljs-literal">true</span></code></pre><h1 id="例子">例子</h1><ul><li><a href="https://www.hellorust.com/demos/" target="_blank" rel="noopener">Hello Rust</a></li><li>https://arkada38.github.io/2017/12/04/rust-wasm-string-to-uppercase/</li><li>https://stackoverflow.com/questions/49014610/passing-a-javascript-string-to-a-rust-function-compiled-to-webassembly</li><li><a href="https://kripken.github.io/blog/binaryen/2018/04/18/rust-emscripten.html" target="_blank" rel="noopener">Small WebAssembly Binaries with Rust + Emscripten</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在公司项目里的一个小角落，尝试使用 Rust + WebAssembly 加速应用里部分计算&lt;/p&gt;
&lt;h2 id=&quot;选择&quot;&gt;选择&lt;/h2&gt;
&lt;p&gt;首先要分清项目里 WebAssembly 的定位&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;应用主体：完成绝大多数逻辑，JS
      
    
    </summary>
    
      <category term="前端" scheme="http://hikerpig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="WebAssembly" scheme="http://hikerpig.github.io/tags/WebAssembly/"/>
    
      <category term="Rust" scheme="http://hikerpig.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>用 Jest 单元测试基于 Vue 的项目</title>
    <link href="http://hikerpig.github.io/2018/04/06/2018-04-06-Write-Vue-Tests-in-Jest/"/>
    <id>http://hikerpig.github.io/2018/04/06/2018-04-06-Write-Vue-Tests-in-Jest/</id>
    <published>2018-04-05T16:00:00.000Z</published>
    <updated>2018-08-26T08:50:26.662Z</updated>
    
    <content type="html"><![CDATA[<p>为一个基于 Vue 的项目搭建测试框架，有两个比较成熟的选择，Mocha + Webpack + Karma，或是 Jest。</p><p>前者也是 vue-cli 默认脚手架里的测试方案，我们之前的项目也用了它，实际使用起来，感觉成也 Karma，败也 Karma，配置起来不是很顺手，导致测试必须在完整打包后才能进行，测试时间随着用例增加飞速增长。而且调试单个测试用例的时候冷启动时间太长。</p><p>最后采用了功能强大的 Jest。</p><h2 id="写测试">写测试</h2><h3 id="测试-vue-组件">测试 Vue 组件</h3><p>参见 Vue Cookbook 中关于<a href="https://vuejs.org/v2/cookbook/unit-testing-vue-components.html" target="_blank" rel="noopener">单元测试</a>的一章，以及 <a href="https://vue-test-utils.vuejs.org/en/" target="_blank" rel="noopener">vue test-utils 的文档</a> 。</p><h3 id="拦截网络请求">拦截网络请求</h3><p>由于目前请求都通过 axios，可以简单地通过对 axios 对象的劫持来实现这一需求，考虑 <a href="https://github.com/ctimmerm/axios-mock-adapter" target="_blank" rel="noopener">axios-mock-adapter</a> 插件。</p><h3 id="拦截定时器">拦截定时器</h3><p>看Jest 文档的 <a href="https://facebook.github.io/jest/docs/en/timer-mocks.html" target="_blank" rel="noopener">Timer Mocks</a> 一章。</p><h3 id="自定义-mock">自定义 Mock</h3><p>采用 Jest 一方面是因为它具有很方便的 Mock 方案，框架会自动探测 <code>__mocks__</code> 文件夹中的文件，例如如果新建 <code>__mocks__/axios.js</code>，测试中所有源码的 <code>require('axios')</code> 返回的对象都会是该文件的导出内容。详见文档中的 <a href="https://facebook.github.io/jest/docs/en/manual-mocks.html" target="_blank" rel="noopener">Manual Mocks</a> 一章。</p><h2 id="调试测试">调试测试</h2><p>以在 VSCode 中 Debug 的配置为例，以下为 <code>.vscode/launch.json</code> 示例，参考文章<a href="https://segmentfault.com/a/1190000011852541" target="_blank" rel="noopener">《在VS Code中调试Jest单元测试》</a>：</p><pre><code class="hljs json">&#123;  <span class="hljs-attr">"version"</span>: <span class="hljs-string">"0.2.0"</span>,  <span class="hljs-attr">"configurations"</span>: [    &#123;      <span class="hljs-attr">"type"</span>: <span class="hljs-string">"node"</span>,      <span class="hljs-attr">"request"</span>: <span class="hljs-string">"launch"</span>,      <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Debug Current Jest Test"</span>,      <span class="hljs-attr">"program"</span>: <span class="hljs-string">"$&#123;workspaceRoot&#125;/node_modules/jest/bin/jest"</span>,      <span class="hljs-attr">"cwd"</span>: <span class="hljs-string">"$&#123;workspaceRoot&#125;"</span>,      <span class="hljs-attr">"env"</span>: &#123;        <span class="hljs-attr">"NODE_ENV"</span>: <span class="hljs-string">"test"</span>      &#125;,      <span class="hljs-attr">"args"</span>: [<span class="hljs-string">"--runInBand"</span>, <span class="hljs-string">"--env=jsdom"</span>, <span class="hljs-string">"$&#123;fileBasename&#125;"</span>],      <span class="hljs-attr">"runtimeArgs"</span>: [        <span class="hljs-string">"--inspect-brk"</span>,      ],      <span class="hljs-attr">"sourceMaps"</span>: <span class="hljs-literal">true</span>,      <span class="hljs-attr">"console"</span>: <span class="hljs-string">"integratedTerminal"</span>,      <span class="hljs-attr">"internalConsoleOptions"</span>: <span class="hljs-string">"neverOpen"</span>,    &#125;,    &#123;      <span class="hljs-attr">"type"</span>: <span class="hljs-string">"node"</span>,      <span class="hljs-attr">"request"</span>: <span class="hljs-string">"attach"</span>,      <span class="hljs-attr">"stopOnEntry"</span>: <span class="hljs-literal">false</span>,      <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Attach to node inspect-brk"</span>,      <span class="hljs-attr">"port"</span>: <span class="hljs-number">9229</span>    &#125;,  ]&#125;</code></pre><h3 id="使用-vscode-启动测试">使用 VSCode 启动测试</h3><p>args 中的 <code>--runInBand</code> 和 <code>--env=jsdom</code> 都是 Jest 的配置项，详细的可查阅 <a href="https://facebook.github.io/jest/docs/en/cli.html" target="_blank" rel="noopener">jest cli 文档</a></p><p><code>${fileBasename}</code> 为 VSCode 配置提供的变量，在此处表明只让 Jest 运行当前打开文件描述的用例。</p><h3 id="通过调试协议连接进程">通过调试协议连接进程</h3><p>可以不通过 VSCode，而是直接使用命令 <code>node --inspect=9229 --inspect-brk ./node_modules/.bin/jest  --runInBand</code> 运行 jest，</p><p>第二个配置(request 为 ‘attach’)，连接一个开放 9229 为调试端口的已经在运行的 node 进程。</p><p>此种方式可选择其他实现了远程调试协议的IDE（例如 Webstorm）或浏览器（例如 <a href="https://zhuanlan.zhihu.com/p/30264842" target="_blank" rel="noopener">chrome://inspect</a> ）来实现断点调试等功能。</p><p>关于 Inspector 协议可看<a href="https://zhuanlan.zhihu.com/p/30264842" target="_blank" rel="noopener">此文章</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为一个基于 Vue 的项目搭建测试框架，有两个比较成熟的选择，Mocha + Webpack + Karma，或是 Jest。&lt;/p&gt;
&lt;p&gt;前者也是 vue-cli 默认脚手架里的测试方案，我们之前的项目也用了它，实际使用起来，感觉成也 Karma，败也 Karma，配置
      
    
    </summary>
    
      <category term="前端" scheme="http://hikerpig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Test" scheme="http://hikerpig.github.io/tags/Test/"/>
    
      <category term="Vue" scheme="http://hikerpig.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>在 Typescript 中继承 Error 对象</title>
    <link href="http://hikerpig.github.io/2018/04/02/2018-04-02-Customize-Error-in-Typescript/"/>
    <id>http://hikerpig.github.io/2018/04/02/2018-04-02-Customize-Error-in-Typescript/</id>
    <published>2018-04-01T16:00:00.000Z</published>
    <updated>2018-08-26T08:50:49.156Z</updated>
    
    <content type="html"><![CDATA[<p>通过 Typescript class 继承 Error 实现自定义错误类型时，遇到了一个坑。</p><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> MyError <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Error</span> &#123;&#125;</code></pre><p>但是运行起来：</p><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> err = <span class="hljs-keyword">new</span> MyError()err <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span> <span class="hljs-comment">// true</span>err <span class="hljs-keyword">instanceof</span> MyError  <span class="hljs-comment">// 结果竟然是 false</span></code></pre><h2 id="原因">原因</h2><p>使用 Babel/Typescript 编译出的代码有类似的问题</p><p>Typescript 2.7.2 编译出的代码</p><pre><code class="hljs typescript"><span class="hljs-keyword">var</span> __extends = (<span class="hljs-keyword">this</span> &amp;&amp; <span class="hljs-keyword">this</span>.__extends) || (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> extendStatics = <span class="hljs-built_in">Object</span>.setPrototypeOf ||        (&#123; __proto__: [] &#125; <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span> &amp;&amp; <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">d, b</span>) </span>&#123; d.__proto__ = b; &#125;) ||        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">d, b</span>) </span>&#123; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> p <span class="hljs-keyword">in</span> b) <span class="hljs-keyword">if</span> (b.hasOwnProperty(p)) d[p] = b[p]; &#125;;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">d, b</span>) </span>&#123;        extendStatics(d, b);        <span class="hljs-function"><span class="hljs-keyword">function</span> __(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">this</span>.constructor = d; &#125;        d.prototype = b === <span class="hljs-literal">null</span> ? <span class="hljs-built_in">Object</span>.create(b) : (__.prototype = b.prototype, <span class="hljs-keyword">new</span> __());    &#125;;&#125;)();<span class="hljs-keyword">var</span> MyError = <span class="hljs-comment">/** @class */</span> (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_super</span>) </span>&#123;    __extends(MyError, _super);    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyError</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-comment">// 问题关键在这里</span>        <span class="hljs-keyword">return</span> _super !== <span class="hljs-literal">null</span> &amp;&amp; _super.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>) || <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-keyword">return</span> MyError;&#125;(<span class="hljs-built_in">Error</span>));</code></pre><p>原因在于，Error 是一个特殊的存在，即是一个构造函数，也是一个普通函数。以下两种调用皆可返回 error object。</p><pre><code class="hljs js"><span class="hljs-built_in">Error</span>(<span class="hljs-string">'message'</span>)<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'message'</span>)</code></pre><p>那么在调用以下函数时，_super 为 Error，返回的即是 <code>Error(this, arguments)</code>，而不是 <code>this</code> 。</p><pre><code class="hljs typescript">_super !== <span class="hljs-literal">null</span> &amp;&amp; _super.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>) || <span class="hljs-keyword">this</span>;</code></pre><h2 id="在-typescript-中">在 Typescript 中</h2><p>翻了翻文档，Typescript 2.1 的一些 <a href="https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work" target="_blank" rel="noopener">breaking change</a> 导致对于一些原生对象(Error/Array/Map)的继承无法正常工作，应该就是由 generated code 的改变造成的。官方给出的一个建议是：</p><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> FooError <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Error</span> &#123;  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">m: <span class="hljs-built_in">string</span></span>) &#123;    <span class="hljs-keyword">super</span>(m)    <span class="hljs-comment">// 在 super 之后立刻调用，改变实例的 prototype.</span>    <span class="hljs-built_in">Object</span>.setPrototypeOf(<span class="hljs-keyword">this</span>, FooError.prototype)  &#125;&#125;</code></pre><p>但是这个写法其实相当的傻，因为对于每一个子类的构建函数来说，在改变原型之前，是无法拿到正确的子类实例 ‘this.constructor’ 的，所以 <code>Object.setPrototypeOf</code> 需要出现在所有子类的构建函数中。</p><h2 id="解决方案">解决方案</h2><p>只好把原型继承拿回来了，最终解决方案：</p><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ExtensibleError <span class="hljs-keyword">implements</span> <span class="hljs-built_in">Error</span> &#123;  message: <span class="hljs-built_in">string</span>  name: <span class="hljs-built_in">string</span>  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">message?: <span class="hljs-built_in">string</span></span>) &#123;    <span class="hljs-built_in">Error</span>.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>)    <span class="hljs-keyword">this</span>.message = message || <span class="hljs-string">''</span>    <span class="hljs-keyword">this</span>.name = <span class="hljs-keyword">this</span>.constructor.name    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Error</span>.captureStackTrace === <span class="hljs-string">'function'</span>) &#123;      <span class="hljs-built_in">Error</span>.captureStackTrace(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.constructor)    &#125;  &#125;&#125;ExtensibleError.prototype = <span class="hljs-built_in">Object</span>.create(<span class="hljs-built_in">Error</span>.prototype)</code></pre><p>构建一个中间的辅助类，并不直接采用 class 继承 Error，而只实现 Error 接口，采用原型继承，此类的示例可经过 <code>instanceOf</code> 的检验。通过 <code>Error.captureStackTrac</code> 在初始化此类实例时能够捕获调用栈。</p><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> MyError <span class="hljs-keyword">extends</span> ExtensibleError &#123;&#125;<span class="hljs-keyword">const</span> err = <span class="hljs-keyword">new</span> MyError()err <span class="hljs-keyword">instanceof</span> ExtensibleError  <span class="hljs-comment">// true</span>err <span class="hljs-keyword">instanceof</span> MyError  <span class="hljs-comment">// true</span>err <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span> <span class="hljs-comment">// true</span></code></pre><p>参考</p><ul><li><a href="https://github.com/thundernet8/Blog/issues/1" target="_blank" rel="noopener">Error继承踩坑记</a></li><li><a href="https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work" target="_blank" rel="noopener">breaking change</a></li><li><a href="https://stackoverflow.com/questions/12915412/how-do-i-extend-a-host-object-e-g-error-in-typescript" target="_blank" rel="noopener">so 上的一个答案</a></li></ul>]]></content>
    
    <summary type="html">
    
      跨过 Error 继承的坑
    
    </summary>
    
      <category term="前端" scheme="http://hikerpig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://hikerpig.github.io/tags/Javascript/"/>
    
      <category term="Typescript" scheme="http://hikerpig.github.io/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>在 Typescript 中使用可被复用的 Vue Mixin</title>
    <link href="http://hikerpig.github.io/2018/01/21/2018-01-21-typed-vue-mixins/"/>
    <id>http://hikerpig.github.io/2018/01/21/2018-01-21-typed-vue-mixins/</id>
    <published>2018-01-20T16:00:00.000Z</published>
    <updated>2018-09-07T03:01:14.276Z</updated>
    
    <content type="html"><![CDATA[<p>转到用 Typescript 写 Vue 应用以后，经过一轮工具链和依赖的洗礼，总算蹒跚地能走起来了，不过有一个很常用的功能 mixin，似乎还没有官方的解决方案。</p><p>既想享受 mixin 的灵活和方便，又想收获 ts 的类型系统带来的安全保障和开发时使用 IntelliSense 的顺滑体验。</p><p>vuejs 官方组织里有一个 ‘vue-class-component’ 以及连带推荐的 ‘vue-property-decorator’，都没有相应实现。翻了下前者的 issue，有一条挂了好些时间的待做 feature 就是 mixin 的支持。</p><p>也不是什么复杂的事，自己写一个吧。</p><blockquote><p>后注：vue-class-component 6.2.0 开始提供 <a href="https://github.com/vuejs/vue-class-component/commit/cdcbfe5bb1a4c9d59a4b3066477f49c9aae8e2fc" target="_blank" rel="noopener">mixins</a> 方法，和本文的实现思路相似。</p></blockquote><h1 id="实现">实现</h1><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> Vue, &#123; VueConstructor &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> VClass&lt;T&gt; = &#123;  <span class="hljs-keyword">new</span>(): T&#125; &amp; Pick&lt;VueConstructor, keyof VueConstructor&gt;<span class="hljs-comment">/** * mixins for class style vue component */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Mixins</span>&lt;<span class="hljs-title">A</span>&gt;(<span class="hljs-params">c: VClass&lt;A&gt;</span>): <span class="hljs-title">VClass</span>&lt;<span class="hljs-title">A</span>&gt;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Mixins</span>&lt;<span class="hljs-title">A</span>, <span class="hljs-title">B</span>&gt;(<span class="hljs-params">c: VClass&lt;A&gt;, c1: VClass&lt;B&gt;</span>): <span class="hljs-title">VClass</span>&lt;<span class="hljs-title">A</span>&amp;<span class="hljs-title">B</span>&gt;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Mixins</span>&lt;<span class="hljs-title">A</span>, <span class="hljs-title">B</span>, <span class="hljs-title">C</span>&gt;(<span class="hljs-params">c: VClass&lt;A&gt;, c1: VClass&lt;B&gt;, c2: VClass&lt;C&gt;</span>): <span class="hljs-title">VClass</span>&lt;<span class="hljs-title">A</span>&amp;<span class="hljs-title">B</span>&amp;<span class="hljs-title">C</span>&gt;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Mixins</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">c: VClass&lt;T&gt;, ...traits: <span class="hljs-built_in">Array</span>&lt;VClass&lt;T&gt;&gt;</span>): <span class="hljs-title">VClass</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;  <span class="hljs-title">return</span> <span class="hljs-title">c</span>.<span class="hljs-title">extend</span>(<span class="hljs-params">&#123;    mixins: traits  &#125;</span>)&#125;</span></span></span></code></pre><p>声明 <code>VClass&lt;T&gt;</code> 可作为 T 的类构造器。同时通过 <code>Pick</code> 拿到 Vue 的构造器上的静态方法（extend/mixin 之类），如此才能够支持下面这段中的真正实现，通过调用一个 Vue 的子类构造器上的 <code>extend</code> 方法生成新的子类构造器。</p><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Mixins</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">c: VClass&lt;T&gt;, ...traits: <span class="hljs-built_in">Array</span>&lt;VClass&lt;T&gt;&gt;</span>): <span class="hljs-title">VClass</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;  <span class="hljs-keyword">return</span> c.extend(&#123;    mixins: traits  &#125;)&#125;</code></pre><p>至于 ABC 这个纯粹是类型声明的体力活了。</p><h1 id="使用">使用</h1><p>实际使用时:</p><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; Component, Vue &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-property-decorator'</span><span class="hljs-keyword">import</span> &#123; Mixins &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'../../util/mixins'</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">class</span> PageMixin <span class="hljs-keyword">extends</span> Vue &#123;  title = <span class="hljs-string">'Test Page'</span>  redirectTo(path: <span class="hljs-built_in">string</span>) &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'calling reidrectTo'</span>, path)    <span class="hljs-keyword">this</span>.$router.push(&#123; path &#125;)  &#125;&#125;<span class="hljs-keyword">interface</span> IDisposable &#123;  dispose(...args: <span class="hljs-built_in">any</span>[]): <span class="hljs-built_in">any</span>&#125;<span class="hljs-meta">@Component</span><span class="hljs-keyword">class</span> DisposableMixin <span class="hljs-keyword">extends</span> Vue &#123;  _disposables: IDisposable[]  created() &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'disposable mixin created'</span>);    <span class="hljs-keyword">this</span>._disposables = []  &#125;  beforeDestroy() &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'about to clear disposables'</span>)    <span class="hljs-keyword">this</span>._disposables.map(<span class="hljs-function">(<span class="hljs-params">d</span>) =&gt;</span> &#123;      d.dispose()    &#125;)    <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._disposables  &#125;  registerDisposable(d: IDisposable) &#123;    <span class="hljs-keyword">this</span>._disposables.push(d)  &#125;&#125;<span class="hljs-meta">@Component</span>(&#123;  template: <span class="hljs-string">`  &lt;div&gt;    &lt;h1&gt;&#123;&#123; title &#125;&#125;&lt;/h1&gt;    &lt;p&gt;Counted: &#123;&#123; counter &#125;&#125;&lt;/p&gt;  &lt;/div&gt;  `</span>&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> TimerPage <span class="hljs-keyword">extends</span> Mixins(PageMixin, DisposableMixin) &#123;  counter = <span class="hljs-number">0</span>  mounted() &#123;    <span class="hljs-keyword">const</span> timer = setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.counter++ &gt;= <span class="hljs-number">3</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.redirectTo(<span class="hljs-string">'/otherpage'</span>)      &#125;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'count to'</span>, <span class="hljs-keyword">this</span>.counter);    &#125;, <span class="hljs-number">1000</span>)    <span class="hljs-keyword">this</span>.registerDisposable(&#123;      dispose() &#123;        clearInterval(timer)      &#125;    &#125;)  &#125;&#125;</code></pre><pre><code class="hljs undefined"><span class="hljs-built_in">count</span> <span class="hljs-keyword">to</span> <span class="hljs-number">1</span><span class="hljs-built_in">count</span> <span class="hljs-keyword">to</span> <span class="hljs-number">2</span><span class="hljs-built_in">count</span> <span class="hljs-keyword">to</span> <span class="hljs-number">3</span>calling reidrectTo /otherpage<span class="hljs-keyword">about</span> <span class="hljs-keyword">to</span> clear disposables</code></pre><p>注意到直接 <code>extends Vue</code> 的 <code>DisposableMixin</code> 并不是一个有效的 Vue 组件，也不可以直接在 <code>mixins</code> 选项里使用，如果要被以 <code>Vue.extend</code> 方式扩展的自定义组件使用，记住使用 <code>Component</code> 包装一层。</p><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> ExtendedComponent = Vue.extend(&#123;  name: <span class="hljs-string">'ExtendedComponent'</span>,  mixins: [Component(DisposableMixin)],&#125;)</code></pre><h1 id="abstract-class">Abstract class</h1><p>在业务系统中，多数情况需求下会更复杂，提供一些基础功能，但有些部分需要留给继承者自行实现，这个时候使用抽象类就很合适。</p><h2 id="直接继承">直接继承</h2><pre><code class="hljs typescript"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> AbstractMusicPlayer <span class="hljs-keyword">extends</span> Vue &#123;  <span class="hljs-keyword">abstract</span> audioSrc: <span class="hljs-built_in">string</span>    playing = <span class="hljs-literal">false</span>    togglePlay() &#123;    <span class="hljs-keyword">this</span>.playing = !<span class="hljs-keyword">this</span>.playing  &#125;&#125;<span class="hljs-meta">@Component</span><span class="hljs-keyword">class</span> MusicPlayerA <span class="hljs-keyword">extends</span> AbstractMusicPlayer &#123;  audioSrc = <span class="hljs-string">'/audio-a.mp3'</span>&#125;<span class="hljs-meta">@Component</span><span class="hljs-keyword">class</span> MusicPlayerB <span class="hljs-keyword">extends</span> AbstractMusicPlayer &#123;  staticBase = <span class="hljs-string">'/statics'</span>  <span class="hljs-keyword">get</span> audioSrc() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;this.staticBase&#125;</span>/audio-b.mp3`</span>  &#125;&#125;</code></pre><h2 id="使用-mixins">使用 Mixins</h2><h3 id="坏方法欺骗以及注释">坏方法：欺骗，以及注释</h3><p>但抽象类是无法被实例化的，并不满足 <code>{ new(): T }</code> 这个要求，因此只能被继承，而<strong>不能</strong>被混入，由于同样的原因，抽象类也无法被 ‘vue-class-component’ 的 <code>Component</code> 函数装饰。</p><p>这时候只好将实现了的功能写入 Mixin 中，待实现的功能放到接口里，让具体类来实现。</p><pre><code class="hljs typescriptvue-class-component">interface IMusicSourceProvider &#123;  audioSrc: string&#125;/** * 需要实现 IPlayerImplementation */@Componentclass PlayerMixin extends Vue &#123;  /** @abstract 必须实现 */  audioSrc: string  logSrc() &#123;    console.log(this.audioSrc)  &#125;&#125;interface IPlayerImplementation extends IMusicSourceProvider &#123;&#125;@Componentclass OtherMixin extends Vue &#123;  description = &apos;另一个 Mixin&apos;&#125;@Componentclass RealPlayer extends Mixins(PlayerMixin, OtherMixin) implements IPlayerImplementation &#123;  audioSrc = &apos;/audio-c.mp3&apos;&#125;// 无法正常工作@Componentclass BrokenPlayer extends Mixins(PlayerMixin, OtherMixin) &#123;&#125;</code></pre><p>鉴于 <code>@Component</code> 装饰器的实现方式，这种欺骗编译器的方式其实还是比较拙劣的。</p><p>如果一个具体类继承了 <code>PlayerMixin</code>，却没有使用 getter 或 property initializer 实现 <code>audioSrc</code> 这个属性，编译器无法告诉你这个错误（不开启严格模式的情况下），但实际使用中 <code>audioSrc</code> 其实是没有被初始化的，你会发现 <code>BrokenPlayer</code> 的实例当中 <code>_data</code> 里并不包含 <code>audioSrc</code>，即便在实例化后手动设置该值，Vue 也无法监听到该值的变化，会造成一些比较隐秘的 bug。</p><p>我们只能在代码里小心翼翼写上注释，期待使用者不要忘了这件事。</p><p>也可以执行一些开发时候的额外检查，如下：</p><h4 id="自定义装饰器-abstractproperty">自定义装饰器 AbstractProperty</h4><p>vue-class-component 提供了 <a href="https://github.com/vuejs/vue-class-component#create-custom-decorators" target="_blank" rel="noopener">createDecorator</a> 方法来创建其体系下的自定义装饰器，我们可以这么用：</p><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; createDecorator &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-class-component'</span><span class="hljs-comment">// 一个什么都不做的装饰器，在 production 环境下启用。不使用 createDecorator</span><span class="hljs-keyword">const</span> HolderDecorator = <span class="hljs-function">(<span class="hljs-params">ctor: <span class="hljs-built_in">any</span></span>) =&gt;</span> ctor<span class="hljs-comment">/** * Only for vue-class-component decorated class */</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> AbstractProperty = isProduction ? HolderDecorator:createDecorator(<span class="hljs-function">(<span class="hljs-params">options, key</span>) =&gt;</span> &#123;  <span class="hljs-keyword">const</span> originCreated = options.created  options.created = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">if</span> (originCreated) originCreated.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>)    <span class="hljs-keyword">if</span> (!(key <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>)) &#123;      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">`未实现 AbstractProperty '<span class="hljs-subst">$&#123;key&#125;</span>'`</span>)    &#125;  &#125;&#125;)<span class="hljs-meta">@Component</span><span class="hljs-keyword">class</span> PlayerMixin <span class="hljs-keyword">extends</span> Vue &#123;  <span class="hljs-meta">@AbstractProperty</span>  audioSrc: <span class="hljs-built_in">string</span>  logSrc() &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.audioSrc)  &#125;&#125;<span class="hljs-meta">@Component</span><span class="hljs-keyword">class</span> BrokenPlayer <span class="hljs-keyword">extends</span> Mixins(PlayerMixin, OtherMixin) &#123;&#125;<span class="hljs-keyword">const</span> player = <span class="hljs-keyword">new</span> BrokenPlayer<span class="hljs-comment">// 未实现 AbstractProperty 'audioSrc'</span></code></pre><h3 id="没那么坏的方法中间类">没那么坏的方法：中间类</h3><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span><span class="hljs-keyword">class</span> _PlayerImpl <span class="hljs-keyword">extends</span> AbstractMusicPlayer &#123;  audioSrc = <span class="hljs-string">'/audio-d.mp3'</span>&#125;<span class="hljs-meta">@Component</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> RealPlayer2 <span class="hljs-keyword">extends</span> Mixins(_PlayerImpl, OtherMixin) &#123;&#125;</code></pre><p>使用中间类 <code>_PlayerImpl</code> 来实现抽象类的抽象部分，然后再被真正的使用者 <code>RealPlayer2</code> 使用。啰嗦了一点，但是类型安全。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转到用 Typescript 写 Vue 应用以后，经过一轮工具链和依赖的洗礼，总算蹒跚地能走起来了，不过有一个很常用的功能 mixin，似乎还没有官方的解决方案。&lt;/p&gt;
&lt;p&gt;既想享受 mixin 的灵活和方便，又想收获 ts 的类型系统带来的安全保障和开发时使用 In
      
    
    </summary>
    
      <category term="前端" scheme="http://hikerpig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Typescript" scheme="http://hikerpig.github.io/tags/Typescript/"/>
    
      <category term="Vue" scheme="http://hikerpig.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>ES6 Class 和 Babel 6 在 IE &lt;= 10 时候的一个坑</title>
    <link href="http://hikerpig.github.io/2017/09/25/2017-09-25-ES6+Babel-little-bug-under-IE11/"/>
    <id>http://hikerpig.github.io/2017/09/25/2017-09-25-ES6+Babel-little-bug-under-IE11/</id>
    <published>2017-09-24T16:00:00.000Z</published>
    <updated>2018-08-26T08:51:33.168Z</updated>
    
    <content type="html"><![CDATA[<p>写 ES6+ 一定逃不开 babel，也避不开调试 babel 生成的一些代码。</p><p>当输入一段 ES6 Class 代码时:</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;  <span class="hljs-keyword">static</span> baseName = <span class="hljs-string">'Person'</span>  <span class="hljs-keyword">static</span> speakForAll() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.baseName  &#125;  speak() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello'</span>  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Developer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;&#125;<span class="hljs-keyword">const</span> myself = <span class="hljs-keyword">new</span> Developer()<span class="hljs-built_in">console</span>.log(myself.speak() === <span class="hljs-string">'Hello'</span>) <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(Person.speakForAll() === <span class="hljs-string">'Person'</span>) <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(Developer.speakForAll() === <span class="hljs-string">'Person'</span>) <span class="hljs-comment">// true</span></code></pre><h1 id="问题">问题</h1><p>在开发常用的浏览器 Chrome 和 Firefox 里正常工作，但是在 IE10 下会报错 <code>Uncaught TypeError: Developer.speakForAll is not a function</code></p><h2 id="刨根问底">刨根问底</h2><p><code>.babelrc</code> 配置如下:</p><pre><code class="hljs json">&#123;  <span class="hljs-attr">"presets"</span>: [<span class="hljs-string">"es2015"</span>, <span class="hljs-string">"stage-2"</span>],&#125;</code></pre><p>看 babel 编译出的一串代码 blahblah， 重点下面说:</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> _class, _temp<span class="hljs-function"><span class="hljs-keyword">function</span> _possibleConstructorReturn(<span class="hljs-params">self, call</span>) </span>&#123;  <span class="hljs-keyword">if</span> (!self) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ReferenceError</span>(      <span class="hljs-string">"this hasn't been initialised - super() hasn't been called"</span>,    )  &#125;  <span class="hljs-keyword">return</span> call &amp;&amp; (<span class="hljs-keyword">typeof</span> call === <span class="hljs-string">'object'</span> || <span class="hljs-keyword">typeof</span> call === <span class="hljs-string">'function'</span>)    ? call    : self&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> _inherits(<span class="hljs-params">subClass, superClass</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> superClass !== <span class="hljs-string">'function'</span> &amp;&amp; superClass !== <span class="hljs-literal">null</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(      <span class="hljs-string">'Super expression must either be null or a function, not '</span> +        <span class="hljs-keyword">typeof</span> superClass,    )  &#125;  subClass.prototype = <span class="hljs-built_in">Object</span>.create(superClass &amp;&amp; superClass.prototype, &#123;    <span class="hljs-attr">constructor</span>: &#123;      <span class="hljs-attr">value</span>: subClass,      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,      <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,      <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,    &#125;,  &#125;)  <span class="hljs-keyword">if</span> (superClass)    <span class="hljs-built_in">Object</span>.setPrototypeOf      ? <span class="hljs-built_in">Object</span>.setPrototypeOf(subClass, superClass)      : (subClass.__proto__ = superClass)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> _classCallCheck(<span class="hljs-params">instance, Constructor</span>) </span>&#123;  <span class="hljs-keyword">if</span> (!(instance <span class="hljs-keyword">instanceof</span> Constructor)) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'Cannot call a class as a function'</span>)  &#125;&#125;<span class="hljs-keyword">var</span> Person = ((_temp = _class = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;    _classCallCheck(<span class="hljs-keyword">this</span>, Person)  &#125;  Person.speakForAll = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">speakForAll</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.baseName  &#125;  Person.prototype.speak = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">speak</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello'</span>  &#125;  <span class="hljs-keyword">return</span> Person&#125;)()),(_class.baseName = <span class="hljs-string">'Person'</span>),_temp)<span class="hljs-keyword">var</span> Developer = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">_Person</span>) </span>&#123;  _inherits(Developer, _Person)  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Developer</span>(<span class="hljs-params"></span>) </span>&#123;    _classCallCheck(<span class="hljs-keyword">this</span>, Developer)    <span class="hljs-keyword">return</span> _possibleConstructorReturn(<span class="hljs-keyword">this</span>, _Person.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>))  &#125;  <span class="hljs-keyword">return</span> Developer&#125;)(Person)<span class="hljs-keyword">var</span> myself = <span class="hljs-keyword">new</span> Developer()<span class="hljs-built_in">console</span>.log(myself.speak() === <span class="hljs-string">'Hello'</span>)<span class="hljs-built_in">console</span>.log(Person.speakForAll() === <span class="hljs-string">'Person'</span>)<span class="hljs-built_in">console</span>.log(Developer.speakForAll() === <span class="hljs-string">'Person'</span>)</code></pre><p>关键是此段实现继承的部分:</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> _inherits(<span class="hljs-params">subClass, superClass</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> superClass !== <span class="hljs-string">'function'</span> &amp;&amp; superClass !== <span class="hljs-literal">null</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(      <span class="hljs-string">'Super expression must either be null or a function, not '</span> +        <span class="hljs-keyword">typeof</span> superClass,    )  &#125;  subClass.prototype = <span class="hljs-built_in">Object</span>.create(superClass &amp;&amp; superClass.prototype, &#123;    <span class="hljs-attr">constructor</span>: &#123;      <span class="hljs-attr">value</span>: subClass,      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,      <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,      <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,    &#125;,  &#125;)  <span class="hljs-keyword">if</span> (superClass)    <span class="hljs-built_in">Object</span>.setPrototypeOf      ? <span class="hljs-built_in">Object</span>.setPrototypeOf(subClass, superClass)      : (subClass.__proto__ = superClass)&#125;</code></pre><p><code>subClass.prototype</code> 这一段比较简单，操作原型链来实现实例方法和属性的继承。顺带还用 object descriptor 重写了 <code>constructor</code> 这一属性，调用 <code>myself.constructor</code> 时才会拿到正确的值 <code>Developer</code>，而不是 <code>Person</code>。</p><p>接下来的一段比较有趣。</p><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.setPrototypeOf(subClass, superClass)</code></pre><p>这个写法还是比较讨巧的，将父类的构造函数 <code>superClass</code> 作为子类构造函数 <code>subClass</code> 的原型。</p><h1 id="知识回顾">知识回顾</h1><h2 id="object.setprototypeof">Object.setPrototypeOf</h2><p>这是个 <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-object.setprototypeof" target="_blank" rel="noopener">ES2015</a> 新提出的函数，函数签名：</p><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.setPrototypeOf(obj, prototype)</code></pre><p>对比 <code>Object.create</code>，可以在对象创建出来之后替换其原型。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = &#123;&#125;<span class="hljs-built_in">Object</span>.setPrototypeOf(p1, Person.prototype)<span class="hljs-built_in">console</span>.log(p1.speak()) <span class="hljs-comment">// 为'Hello'</span></code></pre><p>浏览器兼容性</p><table><thead><tr class="header"><th>Feature</th><th>Chrome</th><th>Edge</th><th>Firefox</th><th>IE</th><th>Opera</th><th>Safari</th></tr></thead><tbody><tr class="odd"><td>Basic Support</td><td>34</td><td>(Yes)</td><td>31</td><td>11</td><td>(Yes)</td><td>9</td></tr></tbody></table><p>注意到从 IE11 才开始支持此方法。</p><p>既然第一条路行不通，那就第二条呗。</p><h2 id="proto__"><code>__proto__</code></h2><p><code>_inherits</code> 函数中回退到 <code>subClass.__proto__ = superClass</code>。<code>__proto__</code> 指向的是对象构造函数的 <code>prototype</code>，通过重设 <code>subClass</code> 的原型来使其获得父类构造函数上的方法(此例中是 class 上的静态方法)。</p><p>关键在于，<code>__proto__</code> 是个非标准的属性，根据<a href="https://docs.microsoft.com/en-us/scripting/javascript/reference/proto-property-object-javascript" target="_blank" rel="noopener">微软的文档</a>，IE10 及其以下都没有支持。</p><blockquote><p>Not supported in the following document modes: Quirks, Internet Explorer 6 standards, Internet Explorer 7 standards, Internet Explorer 8 standards, Internet Explorer 9 standards, Internet Explorer 10 standards. Not supported in Windows 8.</p></blockquote><p><a href="https://github.com/babel/babel/issues/3041" target="_blank" rel="noopener">Babel 的一个 issue</a> 中有人提过类似问题，回答是：babel 6 不考虑兼容 IE。没碰上问题算幸运，碰上问题只好自己解决。</p><h1 id="解决方案">解决方案</h1><p>就这个事情来说，添加一个 polyfill 能够解决。以 <a href="https://github.com/wesleytodd/setprototypeof" target="_blank" rel="noopener">这个实现</a> 来说:</p><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">Object</span>.setPrototypeOf || (&#123;<span class="hljs-attr">__proto__</span>:[]&#125; <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span> ? setProtoOf : mixinProperties);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setProtoOf</span>(<span class="hljs-params">obj, proto</span>) </span>&#123;  obj.__proto__ = proto;  <span class="hljs-keyword">return</span> obj;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mixinProperties</span>(<span class="hljs-params">obj, proto</span>) </span>&#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> prop <span class="hljs-keyword">in</span> proto) &#123;    <span class="hljs-keyword">if</span> (!obj.hasOwnProperty(prop)) &#123;      obj[prop] = proto[prop];    &#125;  &#125;  <span class="hljs-keyword">return</span> obj;&#125;</code></pre><p>先探测 Object 上是否原生支持，然后检测更改 <code>__proto__</code> 是否有作用，最后回退到简单暴力的遍历赋值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写 ES6+ 一定逃不开 babel，也避不开调试 babel 生成的一些代码。&lt;/p&gt;
&lt;p&gt;当输入一段 ES6 Class 代码时:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs js&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="Javascript" scheme="http://hikerpig.github.io/tags/Javascript/"/>
    
      <category term="Babel" scheme="http://hikerpig.github.io/tags/Babel/"/>
    
  </entry>
  
  <entry>
    <title>使用 Object.create(null) 创建空对象</title>
    <link href="http://hikerpig.github.io/2017/09/07/2017-09-07-Using-Object.create/"/>
    <id>http://hikerpig.github.io/2017/09/07/2017-09-07-Using-Object.create/</id>
    <published>2017-09-06T16:00:00.000Z</published>
    <updated>2018-08-26T08:51:38.530Z</updated>
    
    <content type="html"><![CDATA[<p>使用对象字面量形式时，隐式地创建了一个以 <code>Object.prototype</code> 作为原型的对象。</p><p>以下两种方式等同。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> o1 = &#123;&#125;<span class="hljs-keyword">var</span> o2 = <span class="hljs-built_in">Object</span>.create(<span class="hljs-built_in">Object</span>.prototype)</code></pre><h2 id="更省事的方法">更省事的方法</h2><pre><code class="hljs js"><span class="hljs-keyword">var</span> o3 = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>)</code></pre><p>创建一个不继承任何原型的对象。</p><p>如果需要创建一个简单的 map 性质的对象，使用此种方式，在对 <code>o3</code> 进行遍历的时候，就可以躲开充满恶意的世界在 <code>Object.prototype</code> 上添加的方法或属性。</p><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> k <span class="hljs-keyword">in</span> o1) &#123;  <span class="hljs-keyword">if</span> (o1.hasOwnProperty(k)) &#123;  &#125;&#125;<span class="hljs-comment">// 遍历时不需要判断 hasOwnProperty</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> k <span class="hljs-keyword">in</span> o3) &#123;&#125;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用对象字面量形式时，隐式地创建了一个以 &lt;code&gt;Object.prototype&lt;/code&gt; 作为原型的对象。&lt;/p&gt;
&lt;p&gt;以下两种方式等同。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs js&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;va
      
    
    </summary>
    
      <category term="前端" scheme="http://hikerpig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://hikerpig.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>给开发减压的 gulp.watch 配置</title>
    <link href="http://hikerpig.github.io/2017/08/22/2017-08-22-gulp-watch-for-poor-cpu/"/>
    <id>http://hikerpig.github.io/2017/08/22/2017-08-22-gulp-watch-for-poor-cpu/</id>
    <published>2017-08-21T16:00:00.000Z</published>
    <updated>2018-08-26T08:51:43.865Z</updated>
    
    <content type="html"><![CDATA[<p>Gulp 的文件监听使用了 <a href="https://github.com/shama/gaze" target="_blank" rel="noopener">gaze</a>，如果只看了 Gulp 的 API 文档可能会漏掉一些参数。</p><p><a href="https://github.com/gulpjs/gulp/blob/master/docs/API.md" target="_blank" rel="noopener">Gulp 文档</a> 中提到:</p><p><code>gulp.watch(glob[, opts], tasks)</code></p><pre><code class="hljs undefined">opts<span class="hljs-keyword">Type</span>: <span class="hljs-keyword">Object</span>Options, that are passed <span class="hljs-keyword">to</span> gaze.</code></pre><p>options 包括:</p><ul><li><code>interval</code> {integer} Interval to pass to fs.watchFile</li><li><code>debounceDelay</code> {integer} Delay for events called in succession for the same file/event in milliseconds</li><li><code>mode</code> {string} Force the watch mode. Either ‘auto’ (default), ‘watch’ (force native events), or ‘poll’ (force stat polling).</li><li><code>cwd</code> {string} The current working directory to base file patterns from. Default is process.cwd()</li></ul><p>gaze 的设置参数中，感觉最有用却被遗漏的就是 <code>interval</code> 了，好多人提到 <a href="https://github.com/gulpjs/gulp/issues/634" target="_blank" rel="noopener">gulp.watch CPU 占用太高</a>，因为 gaze 默认 100ms 检查监听的文件状态。</p><p>如果监听文件太多导致 CPU 占用居高不下的话，可以考虑加大 <code>interval</code>:</p><pre><code class="hljs js">gulp.watch(blob, &#123;<span class="hljs-attr">interval</span>: <span class="hljs-number">500</span>&#125;, tasks)</code></pre><p>笔记本就不会呼呼乱叫了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Gulp 的文件监听使用了 &lt;a href=&quot;https://github.com/shama/gaze&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gaze&lt;/a&gt;，如果只看了 Gulp 的 API 文档可能会漏掉一些参数。&lt;/p&gt;
&lt;p&gt;&lt;a hre
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Holy Awesome Spacemacs</title>
    <link href="http://hikerpig.github.io/2017/08/05/2017-08-05-Holy-Awesome-Spacemacs/"/>
    <id>http://hikerpig.github.io/2017/08/05/2017-08-05-Holy-Awesome-Spacemacs/</id>
    <published>2017-08-04T16:00:00.000Z</published>
    <updated>2018-08-26T08:51:51.720Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://spacemacs.org/img/logo.svg"></p><p>很久以前看 SICP 的时候尝试在 windows 下使用 emacs 时受到了惊吓，那刀耕火种一般的界面啊。后来在 Ubuntu 终端中打开，诶？怎么关不掉？不掉？掉？（其实 Vim 也一样，小白终结者）</p><p>但是看完<a href="https://www.zhihu.com/question/29692328" target="_blank" rel="noopener">如何评价 Emacs 的配置文件 Spacemacs？</a>以及身边多人的安利后，心痒痒地尝试了下，从一个外行人眼里看来，简直是 Emacs 界的一股清流，史诗级的配置工程。</p><h1 id="安装">安装</h1><p>鉴于有 Every thing in Emacs 的传统，选择了可以不光在终端里使用，便安装了带有 Mac GUI 系统支持的 Emacs：</p><pre><code class="hljs undefined"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>emacs --with-cocoa</code></pre><h2 id="spacemacs">Spacemacs</h2><p>完全没有历史的 <code>.emacs.d</code> 包袱，一键安装</p><pre><code class="hljs undefined">git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://github.com/syl20bnr/spacemacs ~/.emacs.d</code></pre><h1 id="开始使用">开始使用</h1><p>还想说打开速度果然比 Vim 慢了不少，但是慢慢使用着发现，考虑到这些巨量的功能以及超棒的体验来说，等得太值了。重点是，<strong>开箱即用</strong>。</p><p>选择了 Setup Guile 中提示了相对较重的 <code>helm</code> layer，以及开了其他七八个 layer。不考虑首次安装插件的时间，之后平均启动时间在15秒内。</p><p>然后开始领教 Emacs 的能量：</p><h1 id="org-mode">org-mode</h1><p>江湖相传能用于<a href="http://docs.huihoo.com/open-source/guide/ch32.html" target="_blank" rel="noopener">组织你的意念</a>的“文档/知识/日程/<del>人生</del>管理工具”，神级插件。</p><p>在这之前，使用 <a href="http://vimwiki.github.io" target="_blank" rel="noopener">Vimwiki</a> 管理个人知识，在 Vim 里的表现也是很棒的，但是折腾起来总有几点不甚满意，但在 org-mode 下找到了完美的解决方案。</p><h2 id="文档转换">文档转换</h2><p>在 Markdown 大行其道的今天，还需要单独去记忆 Vimwiki 自己的语法，有时候转不过弯来。还有，有时候一些收集性质的笔记，需要从 html 转换过来，Vimwiki 在这方面相关工具比较匮乏。</p><p><code>org-mode</code> 虽说也是自成一派的语法，但是相关工具链非常完善，与各种文档格式互转毫无压力，例如 <a href="https://github.com/fasheng/vimwiki2org" target="_blank" rel="noopener">vimwiki2org</a>。</p><p>当需要集成现有工具到编辑器里时，一边是定义清晰、文档完善、继承了 Lisp 系美感的 Emacs Lisp ，和时常让人呼唤神兽的 Vim Script。</p><h2 id="代码块支持">代码块支持</h2><p>在 Vimwiki 里插入和查阅代码块的体验，纯粹而贫乏。</p><p>同样一个 python 代码块，在 Vimwiki 里：</p><img src="//images-hikerpig.oss-cn-beijing.aliyuncs.com/image/emacs/vimwiki-code.png" alt="undefined" title="undefined"><p>而在 org-mode 当中一切都很行云流水</p><img src="//images-hikerpig.oss-cn-beijing.aliyuncs.com/image/emacs/org-mode-code.png" alt="undefined" title="undefined"><h2 id="其他优点">其他优点</h2><p>包括但不限于：</p><ul><li>所见即所得，默认情况下 live preview，不会生成多余文件</li><li>强大的链接系统，直接跳转至多种形式的内外链接</li><li>强大的<a href="http://orgmode.org/manual/Agenda-Views.html" target="_blank" rel="noopener">日程规划功能</a></li><li>强大的<a href="http://www.cnblogs.com/holbrook/archive/2012/04/12/2444992.html" target="_blank" rel="noopener">表格编辑功能</a></li></ul><h3 id="一些收集">一些收集</h3><ul><li><a href="http://doc.norang.ca/org-mode.htm" target="_blank" rel="noopener">Organize Your Life In Plain Text!</a></li></ul><h1 id="helm">helm</h1><p><a href="http://tuhdo.github.io/helm-intro.html" target="_blank" rel="noopener">A Package in a league of its own: Helm</a></p><p>交互形式让我想起了 Vim 下的 <code>ctrlp</code> 和 <code>unite</code>，但是能做的事情更多，而且扩展性更好。</p><p>除了能找到任何文件外，还能找个任何一个命令，再也不用记那么多 <code>M-x</code> 命令了，再也不用担心小拇指受伤了。</p><figure><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201601/15/103214s4z77zo4pimefccm.jpg" alt="From linux.cn"><figcaption>From linux.cn</figcaption></figure><h1 id="scala-mode-以及-ensime">scala-mode 以及 ensime</h1><p>在做 Coursera 上 Scala 课程作业的时候试了一下。<a href="http://ensime.org/" target="_blank" rel="noopener">Ensime</a> 的 Emacs 插件完成度<a href="http://ensime.org/editors/" target="_blank" rel="noopener">非常的高</a>。</p><h1 id="artist-mode">artist-mode</h1><p>无比炫酷的 ACSII Art 工具，写注释和文档有时一图胜千言。配合 org-mode，感觉自己从未如此热爱写文档。</p><p>看<a href="http://emacser.com/artist-mode.htm" target="_blank" rel="noopener">emacser 上的一篇介绍</a>。</p><p>Vim 上有个类似的插件 <a href="http://www.vim.org/scripts/script.php?script_id=40" target="_blank" rel="noopener">Drawit.vim</a>，不知二者谁先谁后，都挺好用的。</p><h1 id="imenu-list">imenu-list</h1><p>在右边新建一个 buffer 显示 imenu 的结果，接近于 Vim 的 Tagbar 使用体验。</p><figure><img src="https://github.com/bmag/imenu-list/raw/master/images/imenu-list-dark.png" alt="github imenu-list"><figcaption>github imenu-list</figcaption></figure><h1 id="可以使用但不准备替换现有主力编辑器atomvim的">可以使用，但不准备替换现有主力编辑器（Atom/Vim）的</h1><h2 id="coffee-mode">coffee-mode</h2><p><a href="https://github.com/defunkt/coffee-mode" target="_blank" rel="noopener">coffee-mode</a> 支持 coffeescript 文件的语法高亮、编译和 watch 等功能，配合 etags 使用还不错。</p><p>与 evil 一起使用的时候需要一些额外配置，否则用 <code>o</code> 换行的时候发现缩进不对。</p><p>官方 README 给出了解决方案：</p><pre><code class="hljs elisp">(custom-set-variables &apos;(coffee-indent-like-python-mode t))</code></pre><h1 id="放弃折腾的部分">放弃折腾的部分</h1><h2 id="javascript-和-eslint">Javascript 和 Eslint</h2><p>作为一个前端，还是有点小遗憾的。</p><p>没有找到开箱即用的插件，<code>flycheck</code> 似乎很是强大，但是要支持 eslint 还有改许多配置。当然了，前端开发还是看 VS Code 和 Atom 吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://spacemacs.org/img/logo.svg&quot;&gt;&lt;/p&gt;
&lt;p&gt;很久以前看 SICP 的时候尝试在 windows 下使用 emacs 时受到了惊吓，那刀耕火种一般的界面啊。后来在 Ubuntu 终端中打开，诶？怎么关不掉？不掉？掉
      
    
    </summary>
    
    
      <category term="emacs" scheme="http://hikerpig.github.io/tags/emacs/"/>
    
      <category term="editor" scheme="http://hikerpig.github.io/tags/editor/"/>
    
      <category term="productivity" scheme="http://hikerpig.github.io/tags/productivity/"/>
    
  </entry>
  
  <entry>
    <title>前端 Log 小记</title>
    <link href="http://hikerpig.github.io/2016/12/21/2016-12-21-Enhanced-Client-Side-Console/"/>
    <id>http://hikerpig.github.io/2016/12/21/2016-12-21-Enhanced-Client-Side-Console/</id>
    <published>2016-12-20T16:00:00.000Z</published>
    <updated>2018-08-26T08:52:02.072Z</updated>
    
    <content type="html"><![CDATA[<p>相信各位前端工程师们都经历过一个黑暗的场景。</p><img src="//images-hikerpig.oss-cn-beijing.aliyuncs.com/image/stack-or-gtfo.jpg" alt="undefined" title="undefined"><p>(哎哟哎哟测试大人我什么也没说)</p><p>曾经有一个出现bug的页面出现在我面前，我没有珍惜，直到用户关掉页面了，才后悔莫及。</p><p>而且错误不能等到用户反馈了才去探究，最好有完备的收集和响应系统，积极的错误日志分析，使我们防患于未然。</p><h2 id="成熟的-saas-服务">成熟的 SaaS 服务</h2><p>选择还是挺多的，例如 <a href="http://trackjs.com/" target="_blank" rel="noopener">track.js</a>，<a href="https://sentry.io" target="_blank" rel="noopener">Sentry</a>，<a href="https://errorception.com/" target="_blank" rel="noopener">ErrorCeption</a>，<a href="https://www.loggly.com/" target="_blank" rel="noopener">Loggly</a>，<a href="https://airbrake.io/" target="_blank" rel="noopener">Airbrke</a>。都比较成熟，各家各有特色，集成相对简单。</p><h3 id="track.jstrackjs"><a href="http://trackjs.com/" target="_blank" rel="noopener">{track.js}</a></h3><p>鄙公司在使用的服务，十分好用，比起其他几个选项，只专注在前端错误日志，除了基本的记录、sourcemap支持以及错误栈追踪以外，提供的事件记录和时间轴功能，记录了所有网络请求以及用户操作(皆可配置开关)，能让你更好地重现异常发生的过程。十分推荐大家试试，试用期有30天，在自己的项目里先试试吧。</p><h3 id="sentrysentry"><a href="https://sentry.io" target="_blank" rel="noopener">Sentry</a></h3><p>有跨语言和多框架集成支持，前后端皆可用，有免费的社区版本。</p><p>值得一说的是浏览器端的库名字是<code>raven</code>，看了不得不为这个梗点个赞。</p><figure><img src="http://www.30play.com/manage/editor/UploadFile/2014108143616129.jpg" alt="X-Men"><figcaption>X-Men</figcaption></figure><h2 id="错误栈追踪stack-trace">错误栈追踪(Stack Trace)</h2><p>如果不使用自带 parser 的服务而是自己实现前后功能，可能在发送到服务器之前，最好做一些处理，例如生成更可读的错误栈，会让你工作更加轻松。栈信息对于定位和调试错误是十分重要的。</p><h3 id="第三方库">第三方库</h3><h4 id="tracekit"><a href="https://github.com/csnover/TraceKit" target="_blank" rel="noopener">TraceKit</a></h4><pre><code class="hljs javascript"><span class="hljs-comment">// 先注册一下报告的行为回调</span>TraceKit.report.subscribe(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">yourLogger</span>(<span class="hljs-params">errorReport</span>) </span>&#123;  <span class="hljs-comment">// 发送ajax请求到服务器端</span>  <span class="hljs-comment">// 在 https://gist.github.com/4491219 上有个好例子</span>&#125;;<span class="hljs-comment">// 开始写程序</span><span class="hljs-keyword">try</span> &#123;  <span class="hljs-comment">/*   * your application code here   *   */</span>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'oops'</span>);&#125; <span class="hljs-keyword">catch</span> (e) &#123;  TraceKit.report(e); <span class="hljs-comment">//error with stack trace gets normalized and sent to subscriber</span>&#125;</code></pre><h4 id="stacktrace.js"><a href="http://stacktracejs.com/" target="_blank" rel="noopener">stacktrace.js</a></h4><p>解析错误栈并且给出结构化表示，api 设计满足 Promise 规范。</p><p>官方给出的例子:</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> callback = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stackframes</span>) </span>&#123;  <span class="hljs-keyword">var</span> stringifiedStack = stackframes.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">sf</span>) </span>&#123;    <span class="hljs-keyword">return</span> sf.toString();  &#125;).join(<span class="hljs-string">'\n'</span>);  <span class="hljs-built_in">console</span>.log(stringifiedStack);&#125;;<span class="hljs-keyword">var</span> errback = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>&#123; <span class="hljs-built_in">console</span>.log(err.message); &#125;;<span class="hljs-built_in">window</span>.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">msg, file, line, col, error</span>) </span>&#123;  <span class="hljs-comment">// callback is called with an Array[StackFrame]</span>  StackTrace.fromError(error).then(callback).catch(errback);&#125;;</code></pre><h3 id="提升开发时console-log体验的轻量第三方库">提升开发时Console log体验的轻量第三方库</h3><h4 id="logdown"><a href="https://github.com/caiogondim/logdown.js" target="_blank" rel="noopener">Logdown</a></h4><p>node和浏览器端都可以使用的一个工具。</p><p>提供命名空间，并能分别开关各命名空间的log:</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> uiLogger = <span class="hljs-keyword">new</span> Logdown(&#123;<span class="hljs-attr">prefix</span>: <span class="hljs-string">'MyApp:UI'</span>&#125;);<span class="hljs-keyword">var</span> networkServiceLogger = <span class="hljs-keyword">new</span> Logdown(&#123;<span class="hljs-attr">prefix</span>: <span class="hljs-string">'MyApp:Network'</span>&#125;);Logdown.disable(<span class="hljs-string">'MyApp:UI'</span>);Logdown.enable(<span class="hljs-string">'MyApp:Network'</span>);Logdown.disable(<span class="hljs-string">'MyApp:*'</span>); <span class="hljs-comment">// 支持通配符</span></code></pre><p>还支持 markdown 语法:</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> logger = <span class="hljs-keyword">new</span> Logdown(&#123;<span class="hljs-attr">markdown</span>: <span class="hljs-literal">true</span>&#125;);logger.warn(<span class="hljs-string">'Log is *Awesome*'</span>);</code></pre><p>可以看看作者给的<a href="https://caiogondim.github.io/logdown.js/" target="_blank" rel="noopener">例子</a></p><img src="//images-hikerpig.oss-cn-beijing.aliyuncs.com/image/logdown.js.png" alt="undefined" title="undefined"><h1 id="最后">最后</h1><p>错误日志收集完了记住要去看哟。</p><h1 id="参考">参考</h1><ul><li><a href="https://www.sitepoint.com/logging-errors-client-side-apps/" target="_blank" rel="noopener">Logging Errors in Client-Side Applications</a>: 基本上是原文</li><li>题图来自<a href="https://github.com/csnover/TraceKit" target="_blank" rel="noopener">TraceKit</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;相信各位前端工程师们都经历过一个黑暗的场景。&lt;/p&gt;
&lt;img src=&quot;//images-hikerpig.oss-cn-beijing.aliyuncs.com/image/stack-or-gtfo.jpg&quot; alt=&quot;undefined&quot; title=&quot;undefi
      
    
    </summary>
    
      <category term="前端" scheme="http://hikerpig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://hikerpig.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Engineering" scheme="http://hikerpig.github.io/tags/Engineering/"/>
    
  </entry>
  
  <entry>
    <title>[译] 使用重构件（Codemod）加速 JavaScript 开发</title>
    <link href="http://hikerpig.github.io/2016/06/30/2016-06-02-turbocharged-javascript-refactoring-with-codemods/"/>
    <id>http://hikerpig.github.io/2016/06/30/2016-06-02-turbocharged-javascript-refactoring-with-codemods/</id>
    <published>2016-06-29T16:00:00.000Z</published>
    <updated>2018-08-26T08:57:39.030Z</updated>
    
    <content type="html"><![CDATA[<ul><li>原文链接 : <a href="https://medium.com/airbnb-engineering/turbocharged-javascript-refactoring-with-codemods-b0cae8b326b9#.tjerodd52" target="_blank" rel="noopener">Turbocharged JavaScript refactoring with codemods</a></li><li>原文作者 : <a href="https://medium.com/u/e52389684329" target="_blank" rel="noopener">Joe Lencioni</a></li></ul><h3 id="使用重构件codemod加速-javascript-开发">使用重构件（Codemod）加速 JavaScript 开发</h3><p>在花园里耕耘乐趣无穷，但如果除草不勤，最后收获可能是一团揪心。漏掉一次除草本身可能并无大碍，但积少成多最后会毁掉整座花园。没有杂草的花园让维护工作神清气爽。这个道理对代码库也类似。</p><p>我通常讨厌除草，经常忘记这事的结果就是一团糟。谢天谢地在编程界有像 <a href="http://eslint.org/" target="_blank" rel="noopener">ESLint</a> 和 <a href="https://github.com/brigade/scss-lint" target="_blank" rel="noopener">SCSS-Lint</a> 这样的好东西提醒我们勤理代码。但是如果面对的是大段大段的历史代码，光是想想要手动调整成百十千万的空格和逗号，悲伤便逆流成河。</p><p>8年来有几百万行 JavaScript 代码进入 Airbnb 的版本控制系统中。同时，前端界风起云涌。新功能，新框架，甚至 JavaScript 本身都在快速进化。尽管遵循<a href="https://github.com/airbnb/javascript" target="_blank" rel="noopener">良好的代码风格</a>会让变革少些疼痛，但还是很容易累积出不再遵循最新“最佳实践”的巨大代码库。每一处代码风格的不一致都是一棵杂草，唯一归宿就是被铲掉，化作春泥更护花，好让开发团队保持高效。来看看我们花园现在的样子：</p><p><img src="http://ww1.sinaimg.cn/large/005SiNxygw1f3j83hmmrij30jk0dvjsn.jpg"></p><p>我执着于增加团队效率，也深知保持一致性的代码能增速团队反馈和减少无效沟通。我们最近开始了一个整理代码的项目，准备把许多陈旧的 JavaScript 代码转化得符合我们的代码风格，亦使我们的代码检验器有更多用武之地。若全都手动完成，会是件十分无聊和耗时的苦差，所以我们借助工具帮我们自动化此工作。虽说使用 <em><code>eslint -fix</code></em> 是个不错的开始，但<a href="https://github.com/eslint/eslint/issues/5329" target="_blank" rel="noopener">它现在所能有限</a>。尽管他们<a href="https://twitter.com/geteslint/status/723909416957829122" target="_blank" rel="noopener">最近开始接受修复所有规则的PR</a>，也准备<a href="https://github.com/cst/cst" target="_blank" rel="noopener">构建 JavaScript 的具体语法树</a>，但等这些功能完成还需要些时间。感谢上苍我们发现了 Facebook 的 <a href="https://github.com/facebook/jscodeshift" target="_blank" rel="noopener">jscodeshift</a>，这是一个重构工具（协助大型代码库的自动化重构）。如果代码库是个花园，那么 jscodeshift 就像个除草机器人。</p><p>此工具将 JavaScript 解析为一棵 <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank" rel="noopener">抽象语法树</a>，并在其上进行变换，然后输出符合指定代码风格的新 JavaScript 代码。转换过程是用 JavaScript 本身实现的，所以我们团队很乐意使用此工具。寻找或是创建转换代码能加速我们乏味的重构，让我们团队能够专注于更有意义的工作。</p><p>运行几个代码重构件后，我们的花园整洁了点：</p><p><img src="http://ww4.sinaimg.cn/large/a490147fjw1f3j9ybpgazj20je0flwfm.jpg"></p><h3 id="策略">策略</h3><p>鉴于多数重构件能在一分钟内处理上千文件，我发现它是我打发主要工作的等待间隙（例如等代码审查）的不错选择。它帮我最大化提升了工作效率从而让我能在更大和更重要的项目中有所建树。</p><p>大规模重构主要面临四大挑战。沟通、正确性、代码审查以及冲突合并。我采取以下策略来应对这些挑战。</p><p>重构件不总是能产出我需要的结果，因此对其结果的审查和改动十分重要。以下命令在跑完重构件后很有用：</p><pre><code>git diffgit add --patchgit checkout --patch</code></pre><p>保持每个提交和 PR 在小的体量是好的做法，对于重构件也不例外。我通常一段时间内进行一类重构，减少代码审查和冲突合并的麻烦。我亦经常让重构件自动提交重构结果，而后若有必要，再手动清理。这样在衍合分支时解决冲突会轻松点，因为我可以使用</p><pre><code>git checkout --ours path/to/conflict</code></pre><p>然后在那个文件上再运行一次重构件，之后也不会弄乱我自己的手动提交。</p><p>有时重构件生成了很大的变动，我觉得在此情况下根据目录或文件名来分成数次提交或 PR 会比较好。例如，一个提交重构 .js 文件，另一个提交重构.jsx 文件。这样之后代码审查和冲突合并会相对轻松一点。谨遵 <a href="https://en.wikipedia.org/wiki/Unix_philosophy" target="_blank" rel="noopener">Unix 哲学</a>，分批进行文件重构简单到仅需调整 <em><code>find</code></em> 命令的参数：</p><pre><code>find app/assets/javascripts -name *.jsx -not -path */vendor/* | \  xargs jscodeshift -t ~/path/to/transform.js</code></pre><p>为避免和别人的代码冲突，我通常在周五早上才推送我的重构件生成的提交，然后周一赶在大家开始工作之前进行衍合和合并。这样其他人周末放假前不被你的重构件阻碍，能好好整理自己的工作成果。</p><h3 id="我们用得顺手的重构件">我们用得顺手的重构件</h3><p>虽然此工具还比较新，已然有了一些实用的重构件。以下是一些我们成功上手了的。</p><h4 id="轻量级重构件">轻量级重构件</h4><p>以下是些用着不那么痛苦的，立刻上手感受成效。</p><p><a href="https://github.com/cpojer/js-codemod#arrow-function" target="_blank" rel="noopener"><strong>js-codemod/arrow-function</strong></a><strong>:</strong> 谨慎地把函数转为箭头函数</p><p>使用前:</p><pre><code>[1, 2, 3].map(function(x) {  return x * x;}.bind(this));</code></pre><p>使用后:</p><pre><code>[1, 2, 3].map(x =&gt; x * x);</code></pre><p><a href="https://github.com/cpojer/js-codemod#no-vars" target="_blank" rel="noopener"><strong>js-codemod/no-vars</strong></a><strong>:</strong> 将 <em><code>var'_ 安全转化为 _</code>const<code>_ 或 _</code>let`</em>。</p><p>使用前:</p><pre><code>var belong = &#39;anywhere&#39;;</code></pre><p>使用后:</p><pre><code>const belong = &#39;anywhere&#39;;</code></pre><p><a href="https://github.com/cpojer/js-codemod#object-shorthand" target="_blank" rel="noopener"><strong>js-codemod/object-shorthand</strong></a><strong>:</strong> 把对象字面量转为 ES6 的简写表示。</p><p>使用前:</p><pre><code>const things = {  belong: belong,  anywhere: function() {},};</code></pre><p>使用后:</p><pre><code>const things = {  belong,  anywhere() {},};</code></pre><p><a href="https://github.com/cpojer/js-codemod#unchain-variables" target="_blank" rel="noopener"><strong>js-codemod/unchain-variables</strong></a><strong>:</strong> 分离连续声明的变量。</p><p>使用前:</p><pre><code>const belong = &#39;anywhere&#39;, welcome = &#39;home&#39;;</code></pre><p>使用后:</p><pre><code>const belong = &#39;anywhere&#39;;const welcome = &#39;home&#39;;</code></pre><p><a href="https://github.com/cpojer/js-codemod#unquote-properties" target="_blank" rel="noopener"><strong>js-codemod/unquote-properties</strong></a><strong>:</strong> 移除对象属性的引号。</p><p>使用前:</p><pre><code>const things = {  &#39;belong&#39;: &#39;anywhere&#39;,};</code></pre><p>使用后:</p><pre><code>const things = {  belong: &#39;anywhere&#39;,};</code></pre><h4 id="重量级重构件">重量级重构件</h4><p>以下重构件或是改动很多代码引发合并和冲突之痛，或是需要更多后续的手动更改以保证代码还能看得下去。</p><p><a href="https://github.com/reactjs/react-codemod#class" target="_blank" rel="noopener"><strong>react-codemod/class</strong></a><strong>:</strong> 把 <em><code>React.createClass</code></em> 转为 ES6 class 的实现。</p><p>此重构件在有 mixin 的时候不会变换，在类似于 <em><code>propTypes</code></em>、默认 props 和 initial state 定义这样的必要转换做得很好，还能将事件回调函数绑定到构造器上。</p><p>使用前:</p><pre><code>const BelongAnywhere = React.createClass({  // ...});</code></pre><p>使用后:</p><pre><code>class BelongAnywhere extends React.Component {  // ...}</code></pre><p><a href="https://github.com/reactjs/react-codemod#sort-comp" target="_blank" rel="noopener"><strong>react-codemod/sort-comp</strong></a><strong>:</strong> 根据 <a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/sort-comp.md" target="_blank" rel="noopener">ESLint react/sort-comp rule</a> 重新组织 React component 的方法声明顺序。</p><p>这个会调整大量代码，git 不会自动合并冲突。我觉得在使用此重构件前最好最好跟队友打个招呼，在不太容易发生冲突的时候（例如周末）进行重构。当我衍合此重构的提交且遇上冲突的时候，我会：</p><pre><code>git checkout --ours path/to/conflict</code></pre><p>然后再运行一次重构件。</p><p>使用前:</p><pre><code>class BelongAnywhere extends React.Component {  render() {    return &lt;div&gt;Belong Anywhere&lt;/div&gt;;  }  componentWillMount() {      console.log(&#39;Welcome home&#39;);    }  }</code></pre><p>使用后:</p><pre><code>class BelongAnywhere extends React.Component {  componentWillMount() {    console.log(&#39;Welcome home&#39;);  } render() {    return &lt;div&gt;Belong Anywhere&lt;/div&gt;;  }}</code></pre><p><a href="https://github.com/cpojer/js-codemod#template-literals" target="_blank" rel="noopener"><strong>js-codemod/template-literals</strong></a><strong>:</strong> 把字符串的串联转换为字符串模板字面量表示。</p><p>因为我们多处用到字符串串联，而且这个重构件尽其所能把所有字符串都转成模板，我发现很多转换结果其实并不合理。我之所以这个重构件放到“重量级”列表里，是因为它会改动很多文件，而且之后我们还得进行大量的手动修改才能得到满意的结果。</p><p>使用前:</p><pre><code>const belong = &#39;anywhere &#39;+ welcomeHome;</code></pre><p>使用后:</p><pre><code>const belong = `anywhere ${welcomeHome}`;</code></pre><h3 id="资源">资源</h3><p>若你想写自己的重构件，或是看看它能做什么，可以看下下面的资源。</p><ul><li><a href="https://www.youtube.com/watch?v=d0pOgY8__JM" target="_blank" rel="noopener">逐步改进复杂系统</a>：来自 Christoph Pojer 于 JSConf EU 2015 上关于 Facebook 的重构件的演讲。（亦可见<a href="https://medium.com/@cpojer/effective-javascript-codemods-5a6686bb46fb" target="_blank" rel="noopener">高效的 JavaScript 重构件</a>）。</li><li><a href="https://vramana.github.io/blog/2015/12/21/codemod-tutorial/" target="_blank" rel="noopener">如何写重构件</a>: 带你写一个把字符串串联转化为字符串模板字面量的重构件的教程。</li><li><a href="https://astexplorer.net/" target="_blank" rel="noopener">AST 探索</a>: 可查看由多种语法分析程序产生的 AST 的工具。好东西，可以查看你想转换的代码的 AST。</li><li><a href="https://medium.com/nfl-engineers/nfl-codemods-migrating-a-monolith-1e3363571707" target="_blank" rel="noopener">NFL ♥ C重构件: 海量代码迁移</a>: 关于 NFL 如何使用重构件的一个使用案例。</li><li><a href="https://github.com/reactjs/react-codemod" target="_blank" rel="noopener">react-codemod</a>: 一系列关于 React 的重构件。</li><li><a href="https://github.com/cpojer/js-codemod" target="_blank" rel="noopener">js-codemod</a>: 一系列常用的 JavaScript 重构件。</li></ul><h3 id="影响">影响</h3><p>在使用了一些现成的和我们自己写的并贡献给社区的重构件之后，我们的旧代码质量获得很大的提升。我不费吹灰之力便重构了40000行代码，将旧代码调整至符合 ES6 代码风格。花园焕然一新，我们之后的工作也更有效率和乐趣。</p><p>使用已有的重构件仅是牛刀小试，只有在你拿起键盘写出自己的重构件时，真正的能量才会释放。无论是对代码风格重构，或是对失效 API 的调整，重构件都能大显身手，你可以尽情想象发挥。这些技术值得学习投入，能省下你和使用你的项目使用者很多时间精力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;原文链接 : &lt;a href=&quot;https://medium.com/airbnb-engineering/turbocharged-javascript-refactoring-with-codemods-b0cae8b326b9#.tjerodd52&quot; ta
      
    
    </summary>
    
      <category term="工具" scheme="http://hikerpig.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Javascript" scheme="http://hikerpig.github.io/tags/Javascript/"/>
    
      <category term="前端" scheme="http://hikerpig.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Engineering" scheme="http://hikerpig.github.io/tags/Engineering/"/>
    
  </entry>
  
  <entry>
    <title>[译] Javascript 姿势提升简略</title>
    <link href="http://hikerpig.github.io/2016/04/28/2016-04-28-%E8%AF%91-Javascript-%E5%A7%BF%E5%8A%BF%E6%8F%90%E5%8D%87%E7%AE%80%E7%95%A5/"/>
    <id>http://hikerpig.github.io/2016/04/28/2016-04-28-译-Javascript-姿势提升简略/</id>
    <published>2016-04-27T16:00:00.000Z</published>
    <updated>2018-08-26T08:52:47.250Z</updated>
    
    <content type="html"><![CDATA[<ul><li>原文链接 : <a href="http://developer.telerik.com/featured/leveling-up-your-javascript/" target="_blank" rel="noopener">Leveling Up Your JavaScript</a></li><li>原文作者 : <a href="http://developer.telerik.com/author/rcamden/" target="_blank" rel="noopener">Raymond Camden</a></li></ul><p>JavaScript 是一门入门容易，但是相当难以精通的语言。可现今一些文章总假设你已经精通了它。</p><p>我从 1995 年 JavaScript 还以 LiveScript 名字出现的时候就开始用它了，但后来逐渐从前端开发撤回服务器的安全怀抱中，直到五年前才重拾。很高兴看到如今的浏览器更加的强大和易于调试。但 JavaScript 已经演变得越来越复杂且难以精通了。不过最近我终于得出结论，我并不需要_精通_ Javascript，只需要比以前更进一步就好。能成为一个“好”的 JavaScript 开发者我便觉欣慰。</p><p>以下是我发现的一些_实用_的 JavaScript 小技巧: <a href="#组织代码">组织代码</a>; <a href="#代码检验(Linting)">代码检验</a>; <a href="#测试">测试</a>; 以及 <a href="#浏览器开发者工具">使用开发者工具</a>。里面有几条对有经验的 JavaScript 开发者来说可能很显而易见，但是语言初学者很容易养成坏习惯。这些技巧提高了我的技术水平，同时也为我的用户创造了更好的体验。_这_难道不是我们最大的目标么。</p><blockquote><p>你可在此处<a href="http://developer.telerik.com/wp-content/uploads/2016/01/code.zip" target="_blank" rel="noopener">下载</a>本文的样例代码。</p></blockquote><h2 id="组织代码">组织代码</h2><p>JavaScript 初学者总是不可避免地在他们的 HTML 页面里写上一大坨代码。开始的时候都是很简单的，例如使用 jQuery 给一个表单输入自动加上焦点，然后要加上表单验证，然后又要加上一些市场上走俏的模态框组件——就是那些阻止用户往下阅读内容好让他们在 Facebook 上给网站点赞的东西。经过这些七七八八的功能迭代后你的一个文件里 HTML 标签和 JavaScript 都有了几百行。</p><p>别再继续这种乱七八糟的方式了。这个技巧太简单了我都不好意思单独把它列出来，但大家还_真的_很难拒绝这种把代码一坨扔上页面的偷懒做法。还请各位务必避之如瘟疫。养成好习惯：在开始的时候就先创建好一个空的 JavaScript 文件，然后用 script 标签引入它。这样一来，之后的交互与其他客户端功能代码就可以直接填入先前准备好的空文件里去了。</p><p>把 JavaScript 从 HTML 页面中剥离以后（干净多了是不是？），下一个问题就是关于这些代码的组织形式了。这几百行 JavaScript 也许功能没啥问题，但是几个月后，一旦你开始想调试或是改点东西，你可能特么找不到某个函数在哪了。</p><p>若仅仅把代码从 HTML 中剥离到一个单独文件中是不够的，那还能怎么办呢？</p><h3 id="框架">框架！</h3><p>显然解决方案是框架。把所有东西用 AngularJS，或 Ember，或 React 或其他几百个框架中某一个写一遍。哼哧哼哧地把整个网站重写为一个单页应用，用上 MVC 什么的。</p><p>或者根本不需要。当然了，别误会我，在编写应用的时候我喜欢用 Angular，但是一个“应用”和一个页面的交互复杂度是有区别的。一个用上 Ajax 技术的产品目录页和 Gmail 也是有区别的 - 起码几十万行代码的区别。那么，如果不走框架这条路的话，还有什么选择呢？</p><h3 id="设计模式">设计模式</h3><p>设计模式是对“这是过去人们解决问题的一个方法”这句话的高级说法。Addy Osmani 写过一本关于此的很好的书，<a href="http://addyosmani.com/resources/essentialjsdesignpatterns/book/" target="_blank" rel="noopener">学习 JavaScript 设计模式</a>，可以免费下载阅读。我推荐这本书。但是我对它（以及类似的关于此议题的讨论）有点小看法，因为最后你们写的代码可能变成这样:</p><pre><code>var c = new Car();c.startEngine();c.drive();c.soNotRealistic();</code></pre><p>对我来说，设计模式在抽象层面上是有意义的，但是在_实际工作中_，没有什么用。在实际项目的环境下，挑选并应用设计模式是件很困难的事情。</p><h4 id="模块">模块</h4><p>在所有我看过的设计模式中，我觉得模块模式是最简单也是最容易应用到现有代码里的。</p><p>纵而览之，模块模式就是一系列代码之外加了个包装。你抽取出一系列功能相关的代码扔到一个模块里，决定需要暴露的部分，也可以把一个模块里的代码放到不同的文件里。然后建立一个易于在项目之间共享的代码黑匣。</p><p>看看这个简单的例子。此处的语法乍看可能有点奇怪，起码我一开始是这样觉得的。我们先从“包装”部分开始看，然后我再解释其余部分。</p><p><img src="http://ww4.sinaimg.cn/large/9b5c8bd8jw1f0zumg7z7gj20kp05ojru.jpg"></p><p>模块模式的包装。</p><p>只有我一个人被这些括号搞晕了么？我搞不明白这里是干嘛的，这还是在我懂 JavaScript 的前提下。其实这里如果从里往外看，就清晰很多。</p><p><img src="http://ww2.sinaimg.cn/large/9b5c8bd8jw1f0zuncbxnuj20m805lgly.jpg"></p><p>模块的内部只是个普通的函数。</p><p>从一个简单的函数开始，在其内部定义该模块的实际需要提供的代码。</p><p><img src="http://ww1.sinaimg.cn/large/9b5c8bd8jw1f0zunvmhafj20m805ot94.jpg"></p><p>圆括号使得这个函数自动执行。</p><p>最后的圆括号会让该函数立即执行。我们在函数里返回了什么，模块就是什么。此时我们这里还是空的。不过此时上图高亮的部分还_不是_合法的 JavaScript。那么，怎样让它变得合法呢？</p><p><img src="http://ww4.sinaimg.cn/large/9b5c8bd8jw1f0zuoenvzjj20m805mdg9.jpg"></p><p>外边的圆括号开始发功了。</p><p>在<code>function() { }()</code> 外的圆括号使得此处成为合法JavaScript。你要是不信我，就打开开发者工具的控制台自己输入看看。</p><p>这样就是我们一开始看到的。</p><p><img src="http://ww1.sinaimg.cn/large/9b5c8bd8jw1f0zuotyvzej20m808ngm7.jpg"></p><p>返回值被赋给一个变量。</p><p>最后一件事是把返回值赋给一个变量。尽管我自己完全懂得这里，但每次我看见这种代码我都得暂停一秒钟来提醒自己这是什么鬼。说来也不怕羞，我在编辑器里存着这段空模块代码随时快手粘贴。</p><p>当我们终于征服了这坨诡异的语法之后，真正的模块模式究竟长啥样呢？</p><pre><code>var counterModule = (function() {  var counter = 0;  return {    incrementCounter: function () {      return counter++;    },    resetCounter: function () {      console.log(&quot;counter value prior to reset: &quot; + counter );      counter = 0;    }  };}());</code></pre><p>这段代码创建了一个叫做 <code>counterModule</code> 的模块。它有两个函数，<code>incrementCounter</code> 和 <code>resetCounter</code>。可以这样使用它们：</p><pre><code>console.log(counterModule.getCounter()); //0counterModule.incrementCounter();console.log(counterModule.getCounter()); //1counterModule.resetCounter();console.log(counterModule.getCounter()); //0</code></pre><p>主要的思想就是把 <code>counterModule</code> 里的代码好好地封装起来。封装是计算机科学基础概念，将来 JavaScript 还会提供更简单的封装方法，不过就现在来说，我觉得模块模式已是个超级简单和使用的组织代码方案。</p><h4 id="一个实用的模块案例">一个实用的模块案例</h4><p>吐槽完网上看到的样例（例如上面那个 Car 的例子）。我们现在需要编写一个符合实际场景需求的简单代码。限于本文篇幅，我会写得尽量简单，但会贴合你在遇到实际 web 项目时的情况。</p><p>假设你的网游公司愣天堂 (任粉莫喷)，在用户要创建游戏人物的时候需要一个注册页面。你需要一个可以让用户选择名字的表单。构建名字的规则有点诡异：</p><ul><li>必须以大写字母开头</li><li>长度不小于2</li><li>允许空格，但是不能有标点</li><li>不能有“敏感”词汇</li></ul><p>先写下这个超简单的表单。</p><pre><code>&lt;html&gt;  &lt;head&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;p&gt;Text would be here to describe the rules...&lt;/p&gt;    &lt;form&gt;      &lt;input type=&quot;text&quot; placeholder=&quot;Identifer&quot;&gt;      &lt;input type=&quot;submit&quot; value=&quot;Register Identifer.&quot;&gt;    &lt;/form&gt;    &lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>除了我描述的输入框，表单里还有个提交按钮。然后我加了些有关上面提到的规则的说明，先尽量保持精简。让我们来看看代码。</p><pre><code>var badWords = [&quot;kitten&quot;,&quot;puppy&quot;,&quot;beer&quot;];function hasBadWords(s) {  for(var i=0; i &lt; badwords.length; i++) {    if(s.indexof(badwords[i]) &gt;= 0) return true;  }  return false;}function validIdentifier(s) {  //是否为空  if(s === &quot;&quot;) return false;  //至少两个字符  if(s.length === 1) return false;  //必须以大写字母开头  if(s.charAt(0) !== s.charAt(0).toUpperCase()) return false;  //只允许字母和空格  if(/[^a-z ]/i.test(s)) return false;  //没有敏感词  if(hasBadWords(s)) return false;  return true;}document.getElementById(&quot;submitButton&quot;).addEventListener(&quot;click&quot;, function(e) {  var identifier = document.getElementById(&quot;identifer&quot;).value;  if(validIdentifier(identifier)) {    return true;  } else { console.log(&#39;false&#39;);    e.preventDefault();    return false;  }});</code></pre><p>从代码底部开始，你看到我写了点基本的获取页面元素的代码（没错伙计们这里我没有用 jQuery）然后监听 button 上的点击事件。拿到用户输入的用户名字段然后传给验证函数。验证的内容也就是我之前描述的那些。这里代码还没有_太_乱，不过随着之后验证逻辑的增长和页面交互逻辑的增加，代码会越来越难以维护。所以我们把这里重写为模块吧。</p><p>首先，创建 game.js 文件并在 index.html 中使用 script 标签引入它。然后把验证逻辑移到一个模块里。</p><pre><code>var gameModule = (function() {  var badWords = [&quot;kitten&quot;,&quot;puppy&quot;,&quot;beer&quot;];  function hasBadWords(s) {    for(var i=0; i &lt; badwords.length; i++) {      if(s.indexof(badwords[i]) &gt;= 0) return true;    }    return false;  }  function validIdentifier(s) {    //是否为空    if(s === &quot;&quot;) return false;    //至少两个字符    if(s.length === 1) return false;    //必须以大写字母开头    if(s.charAt(0) !== s.charAt(0).toUpperCase()) return false;    //只允许字母和空格    if(/[^a-z ]/i.test(s)) return false;    //没有敏感词    if(hasBadWords(s)) return false;    return true;  }  return {    valid:validIdentifier  }}());</code></pre><p>现在的代码和之前相比没有翻天覆地的差别，只不过是被封装成了一个有一个 <code>valid</code> 接口的 <code>gameModule</code> 变量。接下来我们来看看 app.js 文件。</p><pre><code>document.getElementById(&quot;submitButton&quot;).addEventListener(&quot;click&quot;, function(e) {  var identifier = document.getElementById(&quot;identifer&quot;).value;  if(gameModule.valid(identifier)) {    return true;  } else { console.log(&#39;false&#39;);    e.preventDefault();    return false;  }});</code></pre><p>看看我们的 DOM 监听函数里少了多少代码。所有的验证逻辑（两个函数和一个敏感词列表）被安全地移到了模块里后，这里的代码就更好维护了。如果你的编辑器支持，你在此处还能有模块方法名的代码补全。</p><p>模块化不是什么高深的东西，但它使我们的代码_更干净_，<em>更简单</em> ，这绝对是件好事。</p><h2 id="代码检验linting">代码检验(Linting)</h2><p>简单给初闻者解释下，代码检验表示使用最佳实践和一些避免出错的规则对代码进行检查。很高大上对不对？这么好的东西，我以前却以为只有挑剔过头的开发者才会考虑这个。当然了，我期望自己写出超棒的代码，但我也需要腾出时间玩游戏。就算我的代码够不上某些高大上的完美标准，但它能好好工作我就能满意了。</p><p>然而…</p><p>记不记得你有多少次重命名了个函数然后提醒自己之后一定会改？</p><p>记不记得你有多少次创建了个有两个形参的函数，其实最后只用了一个？</p><p>记不记得你有多少次写过多少蠢代码？我说的是那些根本不能工作的，类似我最爱的 <code>fuction</code> 和 <code>functon</code>。</p><p>代码检验就是这时候站出来帮你的！除了我之外大家都知道，代码检验不只有风格的最佳实践，还包含语法和基本的逻辑检验。还有一个让我从“等我有时间一定或做的” 跳到“我会虔诚地遵循它” 的原因，那就是几乎所有现代编辑器都支持此功能。我目前用的编辑器（ Sublime, Brackets 和 Visual Studio Code）都支持代码实时检验和反馈。</p><p>举个例子，以下是 Visual Studio Code 对我一段很挫的代码的提示。当然了，我是故意写得很挫的。</p><p><img src="http://ww4.sinaimg.cn/large/9b5c8bd8jw1f0zupgeoxdj20m80d1q40.jpg"></p><p>Visual Studio Code 代码检验。</p><p>上图中，你能看到 Visual Studio Code <strike>抱怨</strike>我代码中的几个错误。Visual Studio Code 的代码检验器，和大多数检验器一样，可配置你关心的检验规则以及对其中“错误”（必须修正）和“警告”(别偷懒啊，总要修复的)的定义。</p><p>如果你不想安装任何东西，也不想折腾编辑器，另一种好方法是使用<a href="http://jshint.com" target="_blank" rel="noopener">JSHint.com</a>在线检验代码。JSHint 差不多是最流行的检验器，它基于另一个检验器 JSLint (谁说它们长得像来着？)。JSHint 的诞生一部分原因是由于 JSLint 太过严格。你可以直接在编辑器里或是通过命令行使用 JSHint，最简单的体验方法是在它的网站上试试。</p><p><img src="http://ww1.sinaimg.cn/large/9b5c8bd8jw1f0zuppot76j20m804w0t8.jpg"></p><p>JSHint 网站。</p><p>乍看可能不太明显，其实左边是在一个在线代码编辑器。右边的是一份对左边代码的检验报告。要看到检验效果，最简单方式是在代码里随便写错点什么。我这里把 <code>main</code> 函数名改成了 <code>main2</code>。</p><pre><code>function main2() {  return &#39;Hello, World!&#39;;}main();</code></pre><p>马上，网页就对此给我报了两个错误。注意了，这并不是语法错误。代码在语法上是完全没问题的，但是 JSHint 发现了你可能忽视了的问题所在（当然了，这里代码只有5行，但想象下一个大文件里函数定义和调用之间隔了好多行的时候）。</p><p><img src="http://ww4.sinaimg.cn/large/9b5c8bd8jw1f0zuq1qvjvj209t070wei.jpg"></p><p>JSHint 错误。</p><p>来个更真实的例子如何？以下的代码（嗯现在我_是_用了 jQuery），我写了点简单的 JavaScript 做表单验证。都是些鸡毛蒜皮的东西，不过今天几乎一半的 JavaScript 代码做的都是这些事（哦哦当然还有创建弹出框然后问你要不要“赞”这个网站。真特么爱死这些了）。这些代码可以在 demo_jshint 文件夹的 app_orig.js 中找到。</p><pre><code>function validAge(x) {  return $.isNumeric(x) &amp;&amp; x &gt;= 1;}function invalidEmail(e) {  return e.indexOf(&quot;@&quot;) == -1;}$(document).ready(function() {  $(&quot;#saveForm&quot;).on(&quot;submit&quot;, function(e) {    e.preventDefault();    var name = $(&quot;#name&quot;).val();    var age = $(&quot;#age&quot;).val();    var email = $(&quot;#email&quot;).val();    badForm = false;    if(name == &quot;&quot;) badForm = true;    if(age == &quot;&quot;) badForm = true;    if(!$.isNumeric(age) || age &lt;= 0) badForm = true;    if(email == &quot;&quot;) badForm = true;    if(invalidemail(email)) badForm = true;    console.log(badform);    if (badform) alert(&#39;Bad Form!&#39;);    else {      // do something on good    }  });});</code></pre><p>开始是两个辅助验证的函数（对年龄和 email）。然后是 <code>document.ready</code> 代码块里对表单提交的监听。获取表单中三个字段的值，检查是否为空（或是无效输入），若表单无效就弹出警告，否则继续（在我们的例子里，什么也没发生，表单没变化）。</p><p>扔到 JSHint 上看看发生了啥：</p><p><img src="http://ww3.sinaimg.cn/large/9b5c8bd8jw1f0zuqkjapdj20b90s5q3x.jpg"></p><p>JSHint 对我们样例代码的报错。</p><p>哇塞好多东西！看起来是类似的问题出现了多次。我开始用检验器的时候这种情况挺常见。我并没有弄出很多种错误，而仅仅是同种错误的重复。第一个非常简单—— 检查相等时使用三等号替代双等号。简单来说就是用更严格的标准检测空字符串。先修复这个(demo_jshint/app_mod1.js)。</p><pre><code>function validAge(x) {  return $.isNumeric(x) &amp;&amp; x &gt;= 1;}function invalidEmail(e) {  return e.indexOf(&quot;@&quot;) == -1;}$(document).ready(function() {  $(&quot;#saveForm&quot;).on(&quot;submit&quot;, function(e) {    e.preventDefault();    var name = $(&quot;#name&quot;).val();    var age = $(&quot;#age&quot;).val();    var email = $(&quot;#email&quot;).val();    badForm = false;    if(name == &quot;&quot;) badForm = true;    if(age == &quot;&quot;) badForm = true;    if(!$.isNumeric(age) || age &lt;= 0) badForm = true;    if(email == &quot;&quot;) badForm = true;    if(invalidemail(email)) badForm = true;    console.log(badform);    if (badform) alert(&#39;Bad Form!&#39;);    else {      // do something on good    }  });});</code></pre><p>JSHint 报告变成了:</p><p><img src="http://ww2.sinaimg.cn/large/9b5c8bd8jw1f0zur1n2y4j20am0lb0t8.jpg"></p><p>JSHint 对我们样例代码的报错。</p><p>算是解决了。下一个错误类型是“未声明变量”。看着有点诡异。如果使用 jQuery 的话，你知道<code>$</code> 是存在的。<code>badForm</code> 的问题就更简单点——我忘记用 <code>var</code> 声明它了。那我们怎么解决<code>$</code>的问题呢？JSHint 提供了对代码规则检验方法的配置。在代码里加上一个注释以后，我们告诉 JSHint <code>$</code> 变量是作为全局变量可以放心使用。接下来我们补上这个注释，并且加上丢失的 <code>var</code> 声明（demo_jshint/app_mod2.js）。</p><pre><code>/* globals $ */function validAge(x) {  return $.isNumeric(x) &amp;&amp; x &gt;= 1;}function invalidEmail(e) {  return e.indexOf(&quot;@&quot;) == -1;}$(document).ready(function() {  $(&quot;#saveForm&quot;).on(&quot;submit&quot;, function(e) {    e.preventDefault();    var name = $(&quot;#name&quot;).val();    var age = $(&quot;#age&quot;).val();    var email = $(&quot;#email&quot;).val();    var badForm = false;    if(name == &quot;&quot;) badForm = true;    if(age == &quot;&quot;) badForm = true;    if(!$.isNumeric(age) || age &lt;= 0) badForm = true;    if(email == &quot;&quot;) badForm = true;    if(invalidemail(email)) badForm = true;    console.log(badform);    if (badform) alert(&#39;Bad Form!&#39;);    else {      // do something on good    }  });});</code></pre><p>JSHint 报告变成了:</p><p><img src="http://ww4.sinaimg.cn/large/9b5c8bd8jw1f0zurgx350j209204gwed.jpg"></p><p>JSHint 对我们样例代码的报错。</p><p>哇哦！就快结束了！最后一个问题恰好的展示了 JSHint 在提示最佳代码风格实践和指出错误以外的用途。这里我忘了写过一个处理年龄验证的函数。你看我创建了 <code>validAge</code>，但是在表单验证代码区域没使用它。也许我该删了这个函数 —— 反正也只有一行，但我觉得留下来更好——以免以后验证逻辑越来越复杂。以下就是完整的代码了(demo_jshint/app.js)。</p><pre><code>/* globals $ */function validAge(x) {  return $.isNumeric(x) &amp;&amp; x &gt;= 1;}function invalidEmail(e) {  return e.indexOf(&quot;@&quot;) == -1;}$(document).ready(function() {  $(&quot;#saveForm&quot;).on(&quot;submit&quot;, function(e) {    e.preventDefault();    var name = $(&quot;#name&quot;).val();    var age = $(&quot;#age&quot;).val();    var email = $(&quot;#email&quot;).val();    var badForm = false;    if(name === &quot;&quot;) badForm = true;    if(age === &quot;&quot;) badForm = true;    if(!validAge(age)) badForm = true;    if(email === &quot;&quot;) badForm = true;    if(invalidEmail(email)) badForm = true;    console.log(badForm);    if(badForm) alert(&#39;Bad Form!&#39;);    else {      //do something on good    }  });});</code></pre><p>最终版本“通过”了 JSHint 的测试。虽然实际上并不完美。注意到我两个检验函数一个叫 <code>validAge</code> 一个叫 <code>invalidEmail</code> ，一个返回肯定一个返回否定。更好的做法是保持语义一致性。还有每次这个验证函数运行的时候，jQuery 需要获取DOM 中的三个元素，其实它们只需要被获取一次。我应该在表单提交回调函数外创建这些变量，每次验证的时候重复使用。如我所言，JSHint 不是完美的，但代码最终版本绝对比第一版要好很多，我的修改也没有花多少时间。</p><p>不同用途的代码检验器有 JavaScript(<a href="http://www.jslint.com" target="_blank" rel="noopener">JSLint</a>和 <a href="http://www.jshint.com" target="_blank" rel="noopener">JSHint</a>)，HTML(<a href="http://htmlhint.com/" target="_blank" rel="noopener">HTMLHint</a>和 <a href="https://validator.w3.org/" target="_blank" rel="noopener">W3C Validator</a>)和CSS (<a href="http://csslint.net/" target="_blank" rel="noopener">CSSLint</a>)。如果编辑器支持，而你还是个“前端潮人”，还可以用 Grunt 和 Gulp 工具对这些进行自动化。</p><h2 id="测试">测试</h2><p>我不写测试。</p><p>没错，我话就撂这儿了。世界不会停止转动。不过，在开发客户端项目时，我其实_是_写测试的（好啦实际是我_尝试_去写测试），但是我的主要工作写博客，和各种功能的样例代码。这些代码只为验证概念而非投入生产环境使用，因此不写测试没什么大不了的。其实，在我成为布道者和不做“实际”工作之前，我也是敢这么放话的，不写测试的借口和不使用代码检验器一样。不过一些给检验器加分的因素放在测试上也很好用。</p><p>首先——许多编辑器会为你自动生成测试代码。例如在 Brackets 中，可以使用 <a href="https://github.com/dschaffe/brackets-xunit" target="_blank" rel="noopener">xunit</a> 扩展。借助它你只要在 JavaScript 文件上调出右键菜单就能生成测试代码（支持多种流行测试框架格式）。</p><p><img src="http://ww1.sinaimg.cn/large/9b5c8bd8jw1f0zus4jz8sj20m80hymy4.jpg"></p><p>xunit 创建的测试。</p><p>该扩展基于现存代码去生成测试代码。生成的测试代码只是个模板，你需要自己去填写具体内容，这避免了一些无聊的重复劳动。</p><p><img src="http://ww2.sinaimg.cn/large/9b5c8bd8jw1f0zuthjkyxj20m80hxjtd.jpg"></p><p>xunit 创建的测试。</p><p>完成了测试细节的填充后，该扩展会帮你自动执行测试。都到了这份上了，不写代码基本上就只是懒了。</p><p><img src="http://ww2.sinaimg.cn/large/9b5c8bd8jw1f0zutuzzmij20m80l50we.jpg"></p><p>测试报告。</p><p>你也许听过 TDD (测试驱动开发)。说的是在写具体代码之前先把单元测试写好。本质上是测试主导你的开发。写下代码并看它通过测试的时候，这些通过的测试能让你确保自己没有走错路。</p><p>我觉得这个想法不错，不过让所有人都这么做的确是有点困难。我们干脆先从简单点的开始。想象下你手上有一些据你所知功能正常的代码，然后你发现了个 bug。在修复它之前，你可以创建一个测试去检验出此 bug，修复 bug，然后跑跑测试，确保此后相同的 bug _不会_再次出现。如我所言，这不是最理想的实践，但也能算是朝着以后在开发所有阶段实践测试的一个过渡。</p><p>我用我写的一个精简数字显示的函数作为 bug 的例子。109203可以精简为109K。更大的例如2190290这样的数可精简为2M。看下代码然后我会说说 bug。</p><pre><code>var formatterModule = (function() {  function fnum(x) {    if(isNaN(x)) return x;    if(x &lt; 9999) {      return x;    }    if(x &lt; 1000000) {      return Math.round(x/1000) + &quot;K&quot;;    }    if(x &lt; 10000000) {      return (x/1000000).toFixed(2) + &quot;M&quot;;    }    if(x &lt; 1000000000) {      return Math.round((x/1000000)) + &quot;M&quot;;    }    if(x &lt; 1000000000000) {      return Math.round((x/1000000000)) + &quot;B&quot;;    }    return &quot;1T+&quot;;  }  return {    fnum:fnum  }}());</code></pre><p>你马上看出问题了？还是放弃了？当输入9999的时候，会返回10K。尽管此精简可能有用，但代码对于所有小于10K的数字应该一视同仁，都返回它们的原始值。这个修正很简单，我们正好当作添加测试的机会。关于测试框架我选择 <a href="http://jasmine.github.io/" target="_blank" rel="noopener">Jasmine</a>。Jasmine 的测试易于编写和运行。最快的使用方法是下载这个库。解压后你会发现 SpecRunner.html 文件。此文件负责引入我们的代码，引入测试，而后运行测试和生成漂亮的报告。它依赖于压缩包中的 lib 文件夹，你一开始可以把 SpecRunner 和 lib 文件夹一起复制到你的服务器某处。</p><p>打开 SpecRunner.html 你会看到。</p><pre><code>&lt;!-- include source files here... --&gt;script tags here...&lt;!-- include spec files here... --&gt;more script tags here...</code></pre><p>在第一个注释下你需要删除已有的代码然后加上一个 script 标签引入你的代码。如果下载了此文的代码，你可以在 demo4 文件夹里找到 formatter.js 文件。之后你要加一个 script 标签引入测试代码。你可能之前没见过 Jasmine，但你看看这个测试代码，_非常_易读，新手也能懂。</p><pre><code>describe(&quot;It can format numbers nicely&quot;, function() {  it(&quot;takes 9999 and returns 9999&quot;, function() {    expect(9999).toBe(formatterModule.fnum(9999));  });});</code></pre><p>我的测试说的是当9999作为输入时应该返回9999。在浏览器里打开 SpecRunner.html 你就能看到错误报告。</p><p><img src="http://ww4.sinaimg.cn/large/9b5c8bd8jw1f0zuu5bbhaj20m80e1q61.jpg"></p><p>测试失败的报告。</p><p>修复起来很简单。把条件里的数字从9999增到10000:</p><pre><code>if(x &lt; 10000) {  return x;}</code></pre><p>不论何时再跑测试你能看到一片欢乐。</p><p><img src="http://ww2.sinaimg.cn/large/9b5c8bd8jw1f0zuuh4xj8j20m804y74k.jpg"></p><p>测试成功的报告。</p><p>你估计能想出一些相关测试完善这套测试。通常来说，积极地添加测试以覆盖你代码的各种可能使用场景没有任何不妥。关于日期和时间的牛库 <a href="http://momentjs.com/" target="_blank" rel="noopener">Moment.js</a>，不是我骗你，有超过五万七千多个测试。你真没看错，就是几万个。</p><p>JavaScript 测试框架的其他选择有 <a href="https://qunitjs.com/" target="_blank" rel="noopener">QUnit</a>和 <a href="http://mochajs.org/" target="_blank" rel="noopener">Mocha</a>。和代码检验一样，你能使用 Grunt 之类的工具自动化测试，甚至可以往全栈靠一点，使用 <a href="http://www.seleniumhq.org/" target="_blank" rel="noopener">Selenium</a> 测试浏览器。</p><h2 id="浏览器开发者工具">浏览器开发者工具</h2><p>我提到的最后一个工具在浏览器里——开发者工具。你能找到许多关于此的文章、演讲和视频，我亦不需赘言。在今天所说的所有内容中，这一条我认为应该是 web 开发者的<strong>必需知识</strong>。你可以写出不能用的代码，可以不是什么都懂，但起码还有开发者工具帮你找出错误所在，然后你只需要 google 一下问题就能解决了。</p><p>再多提一个建议，你不该把自己吊在一个浏览器的开发者工具上。几年前我在鼓捣 App Cache （没错我就是爱自虐），碰上了个只在 Chrome 下出现的问题。当时开着开发者工具，但是没啥用。我灵机一动用 Firefox 打开我的代码，使用它的工具调试，然后我<strong>立刻</strong>就发现了问题所在。Firefox 列出的关于请求的信息比 Chrome 多。我用了一次这个工具立马解决了问题（好吧其实这是胡诌的，Firefox 的确显出问题所在不过我修复问题也用了好些时间）。如果你卡在某个问题上，不如试试打开其他浏览器看看错误报告有没有多说些什么。</p><p>万一万一你真从没_见_过开发者工具，以下有些主流浏览器工具阅览指南和极好的详细教程。</p><h3 id="google-chrome">Google Chrome</h3><p>点击浏览器右上角的汉堡菜单图标，选择“更多工具” -&gt; “开发者工具”。也可以用键盘快捷键打开，例如在 OSX 下快捷键是 <code>CMD+SHIFT+C</code>。关于谷歌的开发者工具文档可到 <a href="https://developer.chrome.com/devtools" target="_blank" rel="noopener">Chrome 开发者工具纵览</a>寻找。</p><h3 id="mozilla-firefox">Mozilla Firefox</h3><p>在主菜单的“工具”栏里，选择 “Web 开发者” -&gt; “切换工具箱”。Firefox 工具栏很酷，在同一菜单下，有许多快速打开开发者工具命令。详情请见 <a href="https://developer.mozilla.org/en-US/docs/Tools" target="_blank" rel="noopener">Firefox 开发者工具</a></p><h3 id="apple-safari-传说中用来看-apple-keynotes-的浏览器">Apple Safari (传说中用来看 Apple keynotes 的浏览器)</h3><p>你得先开启“开发”菜单才能使用开发者工具。进入 Safari 偏好设置，选择“高级”，选中“在菜单栏中显示’开发’菜单”。然后就能从“开发菜单”里通过“显示 Web 检查器”（或者其下的其他三个菜单项）打开工具。详情见<a href="https://developer.apple.com/library/safari/documentation/AppleApplications/Conceptual/Safari_Developer_Guide/Introduction/Introduction.html" target="_blank" rel="noopener">关于 Safari Web 检查器</a>。</p><h3 id="internet-explorer">Internet Explorer</h3><p>点击浏览器右上角的设置按钮或按下键盘 F12键打开开发者工具。详情见<a href="https://msdn.microsoft.com/library/bg182326%28v=vs.85%29" target="_blank" rel="noopener">使用 F12 开发者工具</a>。</p><h2 id="更多学习">更多学习</h2><p>有时候感觉像我们这些做开发的，工作就从来没有完成的时候。你知道在这篇文章写作期间有13个新的 JavaScript 框架发布了么？讲真！以下是最后几个让你学习并且跟上潮流的建议，尽量跟上。</p><p>学习方面，我选择专注于 <a href="http://developer.mozilla.org" target="_blank" rel="noopener">Mozilla Developer Network</a>(你要是准备 google 什么，最好加上 “mdn” 作为前缀)，<a href="http://www.codeschool.com" target="_blank" rel="noopener">CodeSchool</a> (一个商业的编程学习视频网站，内容还不错), 和 <a href="https://www.khanacademy.org/" target="_blank" rel="noopener">Khan Academy</a>。特别要说下 Mozilla 开发者网络(MDN)，多年来我以为它只有 Netscape/Firefox 知识而忽视了它，蠢死了我。</p><p>另一建议是多读代码！你们中许多人都用过 jQuery，但你有打开它的源码看看它的实现么？读别人的代码是一个很好的学习技巧的和方法的途径。还有一个听起来可能有点恐怖，不过我真的强烈建议你分享自己的代码。不光是多了双雪亮的眼睛（或者成千上万双）来审视你的代码，你也许也能帮助其他的人。几年前我看见一个初级程序员分享他的代码，虽然里面有些菜鸟级的错误，但也有一些超棒的技巧。</p><p>为获取最新资讯，我订阅了 <a href="http://cooperpress.com" target="_blank" rel="noopener">Cooper Press</a> 发行的一系列周报。有 HTML 的，JavaScript 的，Node 的和移动开发(Mobile) 和其他一系列。信息可能会淹没你，尽你所能阅读就行。当我看到某个新发布的工具有我_并不_需要的 XXX 功能的时候，我也不用去学它。我只要记住“诶哟有个工具有 XXX 功能”，以后我需要这个功能的时候再去学习。</p>]]></content>
    
    <summary type="html">
    
      成为一个更好的 Javascript 开发者。代码组织，Linting，测试。
    
    </summary>
    
      <category term="前端" scheme="http://hikerpig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://hikerpig.github.io/tags/Javascript/"/>
    
  </entry>
  
</feed>
