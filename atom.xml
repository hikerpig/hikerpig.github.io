<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HP goes FE</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hikerpig.github.io/"/>
  <updated>2020-07-25T08:26:50.125Z</updated>
  <id>http://hikerpig.github.io/</id>
  
  <author>
    <name>Hikerpig</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Toc Bar Userscript - 一个显示页面大纲的油猴脚本</title>
    <link href="http://hikerpig.github.io/2020/07/02/2020-07-02-Toc-Bar-Userscript/"/>
    <id>http://hikerpig.github.io/2020/07/02/2020-07-02-Toc-Bar-Userscript/</id>
    <published>2020-07-01T16:00:00.000Z</published>
    <updated>2020-07-25T08:26:50.125Z</updated>
    
    <content type="html"><![CDATA[<h1 id="toc-bar">Toc Bar</h1><p>一个自用的油猴脚本，在页面中插入一个显示当前内容大纲的浮动组件，可<a href="https://greasyfork.org/zh-CN/scripts/406337-toc-bar" target="_blank" rel="noopener">去 greasefork 下载</a>。</p><p>目前适配了一些个人经常访问的网站，主要面向技术阅读，知乎/Medium/devto/github 之类。</p><h2 id="features">✨Features</h2><ul><li>使用 <a href="https://tscanlin.github.io/tocbot" target="_blank" rel="noopener">tocbot</a> 生成 Table of Content</li><li>对一些页面中 <code>h*</code> 标签不带 id 的网站，生成 id，以实现点击 TOC 标题跳转到对应内容的功能</li><li>不想使用的时候，组件可以一键折叠，避免挡住正在浏览的内容</li></ul><h2 id="screenshots">Screenshots</h2><figure><img src="https://raw.githubusercontent.com/hikerpig/toc-bar-userscript/master/images/screenshot-2.png" alt="" /><figcaption>devto</figcaption></figure><figure><img src="https://i.loli.net/2020/07/25/i3Ub8OwqrvaGzZX.png" alt="" /><figcaption>tocbar-github.png</figcaption></figure><figure><img src="https://raw.githubusercontent.com/hikerpig/toc-bar-userscript/master/images/screenshot-1.jpg" alt="" /><figcaption>zhuanlan-sspai</figcaption></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;toc-bar&quot;&gt;Toc Bar&lt;/h1&gt;
&lt;p&gt;一个自用的油猴脚本，在页面中插入一个显示当前内容大纲的浮动组件，可&lt;a href=&quot;https://greasyfork.org/zh-CN/scripts/406337-toc-bar&quot; target=&quot;_bla
      
    
    </summary>
    
    
      <category term="玩具" scheme="http://hikerpig.github.io/categories/%E7%8E%A9%E5%85%B7/"/>
    
    
      <category term="Toys" scheme="http://hikerpig.github.io/tags/Toys/"/>
    
      <category term="Userscript" scheme="http://hikerpig.github.io/tags/Userscript/"/>
    
  </entry>
  
  <entry>
    <title>工作和个人项目使用不同 gitconfig</title>
    <link href="http://hikerpig.github.io/2020/06/05/2020-06-05-Separate-Git-Config-By-Directories/"/>
    <id>http://hikerpig.github.io/2020/06/05/2020-06-05-Separate-Git-Config-By-Directories/</id>
    <published>2020-06-04T16:00:00.000Z</published>
    <updated>2020-06-05T12:55:55.971Z</updated>
    
    <content type="html"><![CDATA[<p>首先在 <code>~/.gitconfig</code> 中设定如下，注意 gitdir 后面的 <code>~/work/</code> 末尾的 <code>/</code> 不能少。</p><figure class="highlight cs"><table><tr><td class="code"><pre><code class="hljs cs">[<span class="hljs-meta">includeIf <span class="hljs-meta-string">"gitdir:~/work/"</span></span>]<br>  path = ~/.gitconfig-company<br><br>[<span class="hljs-meta">includeIf <span class="hljs-meta-string">"gitdir:~/projects/"</span></span>]<br>  path = ~/.gitconfig-personal<br></code></pre></td></tr></table></figure><p>然后这两个文件就可以单独设置一些项目了。</p><p>例如 ~/.gitconfig-personal 文件内容，可以使用与工作时不同的用户设置：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">[<span class="hljs-keyword">user</span>]<br>  <span class="hljs-type">name</span> = <span class="hljs-string">'hikerpig'</span><br>  email = <span class="hljs-string">'hikerpigwinnie@gmail.com'</span><br></code></pre></td></tr></table></figure><p>最后可在某项目路径下使用 <code>git config --list --show-origin</code> 验证设置是否正确。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先在 &lt;code&gt;~/.gitconfig&lt;/code&gt; 中设定如下，注意 gitdir 后面的 &lt;code&gt;~/work/&lt;/code&gt; 末尾的 &lt;code&gt;/&lt;/code&gt; 不能少。&lt;/p&gt;
&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;t
      
    
    </summary>
    
    
      <category term="工具" scheme="http://hikerpig.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="git" scheme="http://hikerpig.github.io/tags/git/"/>
    
      <category term="tip" scheme="http://hikerpig.github.io/tags/tip/"/>
    
  </entry>
  
  <entry>
    <title>初识 Web Audio API - 术语扫盲</title>
    <link href="http://hikerpig.github.io/2020/03/16/2020-03-16-A-Glimpse-Of-Web-Audio-API/"/>
    <id>http://hikerpig.github.io/2020/03/16/2020-03-16-A-Glimpse-Of-Web-Audio-API/</id>
    <published>2020-03-15T16:00:00.000Z</published>
    <updated>2020-03-31T14:57:34.995Z</updated>
    
    <content type="html"><![CDATA[<p>Web Audio 提供了一个基于图的音频处理构建体系，这个系统里的单元为各种音频节点（AudioNode），可模块化连接（modular routing）。这个体系被业界广泛认同多年，有很多成熟的应用和系统，例如 Apple <a href="https://developer.apple.com/documentation/coreaudio" target="_blank" rel="noopener">CoreAudio</a>，而这个设计理念再往上还能追溯到 1964 年的 <a href="https://www.wikiwand.com/en/Moog_synthesizer" target="_blank" rel="noopener">Moog</a> 合成器。</p><figure><img src="https://i.loli.net/2020/03/17/KnWXYecoivIxS7r.jpg" alt><figcaption>A 1975 Moog Modular 55 system</figcaption></figure><p>如果从 <a href="https://webaudio.github.io/web-audio-api" target="_blank" rel="noopener">Web Audio 规范文档</a> 初入这个领域，可能理解起来有点费力，毕竟文档给出了参数和实现细节，却并不解释这些命名的逻辑。</p><p>看看这张遍布着黑话的模块图：</p><figure><img src="https://i.loli.net/2020/03/17/nX3TarNg6IMwUYe.jpg" alt><figcaption>一个音频处理系统图</figcaption></figure><p>对一些基础概念的解释，MDN 的文档<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Audio_API/Basic_concepts_behind_Web_Audio_API" target="_blank" rel="noopener">《网页音频接口的基本概念》</a>做得很好。</p><p>不过 MDN 的文档里对一些领域知识和行内术语的解释也不太详尽，以下是我碰到的几个初感迷惑，调查背景以后才理解了的概念。</p><h2 id="效果节点">效果节点</h2><h3 id="gainnode">GainNode</h3><p>这是我第一个遇见的效果节点，需要改变音量的时候会用到，那么为什么不叫做 VolumeNode 呢？私以为，音量是一个比较主观和复杂的概念。而音频处理，基本上可以看做一个信号处理过程，无论是早年的模拟信号（电流、电压），还是现在的数字信号，关注点都在于信号本身。</p><p>Gain 一般翻译为增益，是电子学的术语，单独拎出来说没有意义，要细说的话有电压增益、电流增益、功率增益等。</p><h3 id="pannernode">PannerNode</h3><p>又一个看到名字不知道是做什么的东西， pan 的翻译是“平底锅”，和声音又有什么关系呢？ 在<a href="https://www.wikiwand.com/en/Panning_(audio)" target="_blank" rel="noopener">维基百科里关于 Panning 的解释</a>里提到：</p><blockquote><p>声音处理中的 Panning 借用了摄像中的“摇拍”概念。</p></blockquote><figure><img src="https://upload.wikimedia.org/wikipedia/commons/9/9c/Pan1.gif" alt><figcaption>摄影中的摇拍</figcaption></figure><p>简单来说就是通过更改多个声道的相对强度，来营造出一种音源在移动的感觉。同时这个移动的感觉能够营造出空间感，所以在规范里这个技术与”空间化“（Spatialization）也放在一起讨论。</p><h3 id="biquadfilternode">BiquadFilterNode</h3><p>双二阶滤波器（Biquad Filter）在电子学里很常用。按照百度百科的说法：</p><blockquote><p>双二阶滤波器是传递函数的分子、分母都是二阶多项式的滤波器。</p></blockquote><p>直观地从使用角度来理解，这个滤波器在两个不同的频段可以有不同的响应模型，所以通过合理配置参数，可以增强或者削减某些频段的强度，实现低通（lowpass）、高通（highpass）、带通（bandpass）等效果。详细响应曲线可以参考以下这个例子，来自<a href="https://webaudioapi.com/samples/frequency-response/" target="_blank" rel="noopener">webaudioapi.com</a>。</p><iframe src="https://webaudioapi.com/samples/frequency-response/" height="600" class="iframe--resize-v"></iframe><!--以下是一个低通滤镜的响应曲线：![low pass filter](https://i.loli.net/2020/03/17/jyV8N5axb1HUuA3.jpg)--><h3 id="convolvernode">ConvolverNode</h3><p><a href="https://webaudio.github.io/web-audio-api/#ConvolverNode" target="_blank" rel="noopener">规范中的 ConvolverNode 定义</a>：</p><blockquote><p>The ConvolverNode interface is an AudioNode that performs a Linear Convolution on a given AudioBuffer, often used to achieve a reverb effect</p></blockquote><p>对信号源和提供给卷积器的冲激响应（impulse response，以 AudioBuffer 的形式提供给卷积器，作为卷积核）做卷积，信号源和卷积核都是离散和线性的。一般可用于制造混响（reverb，或称回响）效果。</p><p>首先说到<a href="https://www.wikiwand.com/zh-hans/%E5%86%B2%E6%BF%80%E5%93%8D%E5%BA%94" target="_blank" rel="noopener">冲激响应</a>，指的是一个系统随着时间，对于单位输入信号（即一个脉冲）的响应。</p><p>以下的冲激响应来自 <a href="https://webaudioapi.com/samples/room-effects/" target="_blank" rel="noopener">webaudioapi room-effects 例子</a> 里的 telephone 效果。对于每一个脉冲来说，在发生的 0.0006 秒左右后开始有响应，大概 0.0025 秒之后趋于平静。在音效处理中，一般会将未经处理的声音（称作“干”声音，对应于题图中的 dry）与经过处理过的声音（称作“湿”声音，对应于 wet）按照一定比例混合，那么在电话的这个例子中，就能听到稍微有一点延后的效果。假如这个延后的时间内更长，就有大的房间里回音的效果。</p><figure><img src="https://i.loli.net/2020/03/18/CsUke2BOMqRPbQt.jpg" alt><figcaption>电话效果</figcaption></figure><p>blink 的源码中有一段关于 <a href="https://github.com/chromium/chromium/blob/master/third_party/blink/renderer/modules/webaudio/docs/convolver_reverb.md" target="_blank" rel="noopener">convolver_reverb 的文档</a>，叙述了实现卷积混响时减少计算量的一些技巧。</p><p>一般来说，冲激响应曲线由音效设计师录制或是制作，可以导出成 <code>.wav</code> 文件等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Web Audio 提供了一个基于图的音频处理构建体系，这个系统里的单元为各种音频节点（AudioNode），可模块化连接（modular routing）。这个体系被业界广泛认同多年，有很多成熟的应用和系统，例如 Apple &lt;a href=&quot;https://develo
      
    
    </summary>
    
    
      <category term="前端" scheme="http://hikerpig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Avtech" scheme="http://hikerpig.github.io/tags/Avtech/"/>
    
      <category term="audio" scheme="http://hikerpig.github.io/tags/audio/"/>
    
  </entry>
  
  <entry>
    <title>一次 Webpack 下的 Vuex HMR 尝试</title>
    <link href="http://hikerpig.github.io/2020/03/07/2020-03-07-Vuex-Webpack-HMR/"/>
    <id>http://hikerpig.github.io/2020/03/07/2020-03-07-Vuex-Webpack-HMR/</id>
    <published>2020-03-06T16:00:00.000Z</published>
    <updated>2020-04-13T02:57:12.321Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Webpack 构建 Vue 项目时，借助 vue-loader 和 vue-hot-reload-api，我们在开发的时候可以获得很好的组件热加载（Hot Module Replacement）体验。然而 vue-loader 中却没有关于 vuex 的配置（当然这也的确不是它应该插手的地方）。</p><p>官方 vue-cli 的 vuex 插件也没有相应支持（在 cli serve 下如果更改 store 或是其依赖的模块，页面会自动刷新，这个行为是 hot reload 而不是 HMR）。</p><p>Nuxt.js 框架秉承着 convention over configuration 的思想，在一定的目录和文件结构约定下，通过目录分析和脚手架文件模板，很好地解决了 HMR 的问题，生成 <code>store</code> 入口模块的相关代码在<a href="https://github.com/nuxt/nuxt.js/blob/dev/packages/vue-app/template/store.js" target="_blank" rel="noopener">这里</a>。</p><p>在不使用 Nuxt 的情况下，我们也可以通过在项目中保持一定的模块规范来简单实现 Vuex HMR 的配置。</p><h2 id="vuex-的-api">Vuex 的 API</h2><p>Vuex 自身是提供了 hotUpdate api 以及 <a href="https://vuex.vuejs.org/guide/hot-reload.html" target="_blank" rel="noopener">一个 HMR 的代码示例</a> 的。</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">module</span>.hot) &#123;<br>  <span class="hljs-comment">// accept actions and mutations as hot modules</span><br>  <span class="hljs-built_in">module</span>.hot.accept([<span class="hljs-string">'./mutations'</span>, <span class="hljs-string">'./modules/a'</span>], () =&gt; &#123;<br>    <span class="hljs-comment">// require the updated modules</span><br>    <span class="hljs-comment">// have to add .default here due to babel 6 module output</span><br>    <span class="hljs-keyword">const</span> newMutations = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./mutations'</span>).default<br>    <span class="hljs-keyword">const</span> newModuleA = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./modules/a'</span>).default<br>    <span class="hljs-comment">// swap in the new modules and mutations</span><br>    store.hotUpdate(&#123;<br>      mutations: newMutations,<br>      modules: &#123;<br>        a: newModuleA<br>      &#125;<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子稍显简单，需要手动指定每一个 submodule 的路径。</p><h2 id="解决方案">解决方案</h2><p>假设项目中 vuex 相关文件的目录结构如下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs text">src&#x2F;store<br>├── index.js<br>└── modules<br>    ├── complex<br>    │   └── index.js<br>    ├── sub.js &#x2F;&#x2F; 一个 vuex 模块定义文件<br>    ├── util.js &#x2F;&#x2F; 一个随意的工具函数文件，不导出 vuex 模块定义，并不推荐这样与 module 并行的结构，但我们的方案不会误判，详情请继续往下看<br>    └── ...<br></code></pre></td></tr></table></figure><p>其中省略了上例中的 <code>mutations</code> 文件，将全局根模块的内容都写在 <code>store/index.js</code> 中。 <code>modules</code> 文件夹里存放模块的定义内容。</p><p>那我们就可以使用 <a href="https://webpack.js.org/api/module-methods/#requirecontext" target="_blank" rel="noopener">require.context</a> 来动态得出依赖的模块列表。</p><p>首先 <code>sub.js</code> 和 <code>complex/index.js</code> 需要服从一些我们预设的规则：</p><ol type="1"><li>vuex module 定义文件都使用 <code>export default</code> 导出</li><li>如果是 <code>namespaced</code> 模块，需要通过 <code>export const VUEX_NS</code> 或者在 vuex module 定义中添加一个 <code>namespace: string</code> 字段来导出命名空间名。</li></ol><p>例如 sub.js 文件内容：</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; greet &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./util'</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> VUEX_NS = <span class="hljs-string">'sub'</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  namespaced: <span class="hljs-literal">true</span>,<br>  actions: &#123;<br>    test_sub_action() &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'sub v1'</span>)<br>      greet()<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 store/index.js 中的例子如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><br><span class="hljs-keyword">import</span> Vuex <span class="hljs-keyword">from</span> <span class="hljs-string">'vuex'</span><br><br><span class="hljs-keyword">import</span> SUB, &#123; VUEX_NS <span class="hljs-keyword">as</span> SUB_VUEX_NS &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./modules/sub'</span><br><span class="hljs-keyword">import</span> COMPLEX, &#123; VUEX_NS <span class="hljs-keyword">as</span> COMPLEX_VUEX_NS &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./modules/complex'</span><br><br>Vue.use(Vuex)<br><br><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>  actions: &#123;<br>    test_action() &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'root action v1'</span>)<br>    &#125;<br>  &#125;,<br>  modules: &#123;<br>    [SUB_VUEX_NS]: SUB,<br>    [COMPLEX_VUEX_NS]: COMPLEX,<br>  &#125;<br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">module</span>.hot) &#123;<br>  <span class="hljs-comment">// submodules hmr</span><br>  <span class="hljs-keyword">const</span> moduleFiles = <span class="hljs-built_in">require</span>.context(<span class="hljs-string">'./modules'</span>, <span class="hljs-literal">true</span>, /js$/)<br>  <span class="hljs-keyword">const</span> moduleFileKeys = moduleFiles.keys().map(<span class="hljs-function"><span class="hljs-params">k</span> =&gt;</span> moduleFiles.resolve(k))<br><br>  <span class="hljs-built_in">module</span>.hot.accept(moduleFileKeys, (deps) =&gt; &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'module files update'</span>, deps)<br>    <span class="hljs-keyword">const</span> hotUpdatePayload = &#123;<br>      modules: &#123;&#125;,<br>    &#125;<br>    deps.forEach(<span class="hljs-function">(<span class="hljs-params">moduleId</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> m = __webpack_require__(moduleId)<br>      <span class="hljs-keyword">const</span> moduleDef = m.default<br>      <span class="hljs-keyword">if</span> (moduleDef &amp;&amp; (moduleDef.actions || moduleDef.mutations)) &#123;<br>        <span class="hljs-keyword">let</span> namespace = <span class="hljs-string">''</span><br>        <span class="hljs-keyword">if</span> (moduleDef.namespaced) &#123;<br>          <span class="hljs-comment">// Guess namespace</span><br>          namespace = moduleDef.namespace || m[<span class="hljs-string">'VUEX_NS'</span>] || moduleDef[<span class="hljs-string">'namespace'</span>]<br>        &#125;<br>        <span class="hljs-keyword">if</span> (namespace) &#123;<br>          <span class="hljs-keyword">if</span> (hotUpdatePayload.modules[namespace]) &#123;<br>            <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">`Already exists module with namespace <span class="hljs-subst">$&#123;namespace&#125;</span>`</span>)<br>          &#125;<br>          <span class="hljs-built_in">Object</span>.assign(hotUpdatePayload.modules, &#123; [namespace]: moduleDef &#125;)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-built_in">Object</span>.assign(hotUpdatePayload, moduleDef)<br>        &#125;<br>      &#125;<br>    &#125;)<br><br>    store.hotUpdate(hotUpdatePayload)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="样例说明">样例说明</h3><p>在以上的目录结构下，<code>moduleFileKeys</code> 的结果为：</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">[<span class="hljs-string">"./src/store/modules/complex/index.js"</span>, <span class="hljs-string">"./src/store/modules/sub.js"</span>, <span class="hljs-string">"./src/store/modules/util.js"</span>]<br></code></pre></td></tr></table></figure><p>这其中任一个文件发生变化，都会在 module 更新结束后，进入给 <code>module.hot.accept</code> 函数传入的回调函数 <code>(deps) =&gt; {...}</code> 中，执行我们自定义的更新逻辑。</p><p><code>__webpack_require__</code> 是一个 webpack module 作用域内特有的函数，文档<a href="https://webpack.js.org/api/module-variables/#__webpack_require__-webpack-specific" target="_blank" rel="noopener">在此</a>。P.S. 这里使用它，而不是 <code>require(moduleId)</code>，我们都知道源文件中的 <code>require</code> 语句会被 webpack 分析并在生成目标代码时改写，但若入参不是字符串，不能被静态分析出具体的模块，在生成的 bundle 里会被 webpack 转为 <code>__webpack_require__("./src/store sync recursive")(moduleId)</code>，在我的测试中，<code>__webpack_require__("./src/store sync recursive")</code> 这句的结果是一个 <code>webpackEmptyContext</code>，调用它会抛出 MODULE_NOT_FOUND 的异常。</p><p>接下来关于 moduleDef 判断的代码建立在之前说的预设规则上，可以根据项目实际修改。</p><p>P.S. 目前这个方案没有解决两层及以上深度的 module 情况，实际使用中这个似乎也不常见。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用 Webpack 构建 Vue 项目时，借助 vue-loader 和 vue-hot-reload-api，我们在开发的时候可以获得很好的组件热加载（Hot Module Replacement）体验。然而 vue-loader 中却没有关于 vuex 的配置（当然这
      
    
    </summary>
    
    
      <category term="前端" scheme="http://hikerpig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Engineering" scheme="http://hikerpig.github.io/tags/Engineering/"/>
    
      <category term="Vuex" scheme="http://hikerpig.github.io/tags/Vuex/"/>
    
      <category term="Webpack" scheme="http://hikerpig.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>我的常用正则表达式清单</title>
    <link href="http://hikerpig.github.io/2020/02/19/2020-02-19-Regex-Collection/"/>
    <id>http://hikerpig.github.io/2020/02/19/2020-02-19-Regex-Collection/</id>
    <published>2020-02-18T16:00:00.000Z</published>
    <updated>2020-02-19T02:58:08.983Z</updated>
    
    <content type="html"><![CDATA[<h2 id="转换">转换</h2><p><a href="https://medium.com/javascript-in-plain-english/convert-string-to-different-case-styles-snake-kebab-camel-and-pascal-case-in-javascript-da724b7220d7" target="_blank" rel="noopener">medium 的一篇文章有列出几种常见命名方式转换的 JS 函数</a></p><h3 id="camelcase---kebab-case">CamelCase -&gt; kebab-case</h3><p>javascript 使用示例</p><pre><code class="hljs js">string.replace(<span class="hljs-regexp">/([a-z0-9]|(?=[A-Z]))([A-Z])/g</span>, <span class="hljs-string">'$1-$2'</span>).toLowerCase()</code></pre><p>其中使用了正向前瞻 (positive lookahead)，有一些 <a href="https://www.cnblogs.com/boundless-sky/p/7597631.html" target="_blank" rel="noopener">参考文章</a> 可以学习一下。</p><h3 id="kebab-casesnake_case---camelcase">kebab-case/snake_case -&gt; CamelCase</h3><pre><code class="hljs js"><span class="hljs-keyword">const</span> toCamelCase = <span class="hljs-function"><span class="hljs-params">str</span> =&gt;</span>  str    .toLowerCase()    .replace(<span class="hljs-regexp">/[^a-zA-Z0-9]+(.)/g</span>, (m, char) =&gt; char.toUpperCase())</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;转换&quot;&gt;转换&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/javascript-in-plain-english/convert-string-to-different-case-styles-snake-kebab-camel-and
      
    
    </summary>
    
    
      <category term="Engineering" scheme="http://hikerpig.github.io/categories/Engineering/"/>
    
    
      <category term="工具" scheme="http://hikerpig.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="正则" scheme="http://hikerpig.github.io/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Awesome UltiSnips</title>
    <link href="http://hikerpig.github.io/2020/02/05/2020-02-05-Awesome-UltiSnips/"/>
    <id>http://hikerpig.github.io/2020/02/05/2020-02-05-Awesome-UltiSnips/</id>
    <published>2020-02-04T16:00:00.000Z</published>
    <updated>2020-02-10T14:11:59.801Z</updated>
    
    <content type="html"><![CDATA[<p>UltiSnips 不愧为 vim （或乃至所有编辑器）生态下的最佳代码片段解决方案。支持多种常见语法、snippet 添加和管理符合直觉（此处应 cue 一下隔壁对多行文本支持令人垂泪的 vscode）、还有眼花缭乱的 python 脚本插值供 <a href="https://github.com/honza/vim-snippets" target="_blank" rel="noopener">高级玩家</a> 使用。</p><p>UltiSnips 项目已有十年的历史，功能为其模仿和致敬的 SnipMate 的超集，SnipMate 模仿了 TextMate 的语法。</p><p>vscode 也模仿了 TextMate snippet 的语法，从而使得在 ultisnips 和 vscode snippet 语法之间 <a href="http://unisnips.netlify.com/" target="_blank" rel="noopener">转换</a> 变得相对容易。</p><p>仔细阅读文档以后，发现了一些以前遗漏了的功能。</p><h2 id="snippets-文件组织方式">snippets 文件组织方式</h2><p>引自官方文档：</p><pre><code class="hljs text">Using a strategy similar to how Vim detects |ftplugins|, UltiSnips iteratesover the snippet definition directories looking for files with names of thefollowing patterns: ft.snippets, ft_*.snippets, or ft/*, where &quot;ft&quot; is the&apos;filetype&apos; of the current document and &quot;*&quot; is a shell-like wildcard matchingany string including the empty string. The following table shows some typicalsnippet filenames and their associated filetype.    snippet filename         filetype ~    ruby.snippets            ruby    perl.snippets            perl    c.snippets               c    c_my.snippets            c    c/a                      c    c/b.snippets             c    all.snippets             all    all/a.snippets           all</code></pre><p>同一语言的 snippet 不用都塞到一个文件里，可以按照主题组织。</p><pre><code class="hljs text">-- javascript   |-- jest.snippets   |-- vue.snippets   |-- class.snippets</code></pre><h2 id="trigger-不用费脑记">trigger 不用费脑记</h2><h3 id="列出当前可展开的-snippets">列出当前可展开的 snippets</h3><p>在 Normal 模式下，可以使用 <code>:call UltiSnips#ListSnippets()</code>，该函数会列出当前 cursor 处所有支持的 snippet （如果当前 cursor 处没有字符，列出的是此文件所有支持的 snippet），且可以通过数字选择直接展开 snippet 。</p><p>在 Insert 模式下，可设置 <code>g:UltiSnipsListSnippets</code> 绑定按键触发以上函数，默认是 <code>&lt;c-tab&gt;</code>，在一些 terminal 软件里可能会有按键冲突，可以改成别的键，例如：</p><pre><code class="hljs vim"><span class="hljs-variable">g:UltiSnipsListSnippets</span>=<span class="hljs-string">'&lt;c-u&gt;&lt;c-l&gt;'</span></code></pre><p>效果如下：</p><figure><img src="https://i.loli.net/2020/02/05/zL9IbrTyBgfQXEo.gif" alt><figcaption>list snippets usage</figcaption></figure><p>不过这个函数调用的是 vim 的 <a href="https://vim-jp.org/vimdoc-en/eval.html" target="_blank" rel="noopener">inputlist</a> 接口，稍显原始，同时列出的数据太过详尽，有点干扰正常输入流。如果不介意多安装一些东西，可以看下一节。</p><h3 id="与-vim-的自动补全插件配合">与 vim 的自动补全插件配合</h3><p>文档的 <em>UltiSnips and Other Plugins</em> 一节列出了一些支持的自动补全插件。</p><blockquote><p>YouCompleteMe - comes with out of the box completion support for UltiSnips. It offers a really nice completion dialogue for snippets.</p><p>neocomplete - UltiSnips ships with a source for neocomplete and therefore offers out of the box completion dialogue support for it too.</p><p>deoplete - The successor of neocomplete is also supported.</p><p>unite - UltiSnips has a source for unite.</p></blockquote><p>我试过 deoplete ，开箱即用，体验良好。不过由于其他的一些原因，同类型插件我只使用了 <a href="https://github.com/neoclide/coc.nvim" target="_blank" rel="noopener">coc.nvim</a> ，它其实也有对 ultisnips 很好的支持（翻源码才发现它甚至还 port 了一个 vscode 的 snippet 引擎）。</p><figure><img src="https://i.loli.net/2020/02/05/58nsKTQmfAGNVpJ.gif" alt><figcaption>ultisnips with coc.nvim</figcaption></figure><h2 id="以前端项目为例子可以使用的进阶功能">以前端项目为例子，可以使用的进阶功能</h2><h3 id="vim-script-code-transformation">Vim script code + Transformation</h3><p>形式为 <code>${&lt;tab_stop_no/regular_expression/replacement/options}</code> 的 Transformation 需要依赖于一个 tabstop。是在强大的 python script 之外，稍微简单和通用一点的转换形式。</p><p>例如在 <code>test-component.vue</code> 文件里，快速起草一个 Vue SFC 文件结构。</p><pre><code class="hljs vim-snippets">snippet sfc_component &quot;setup sfc component&quot;&lt;template&gt;  &lt;div class=&quot;$&#123;1:`!v expand(&quot;%:r&quot;)`&#125;&quot;&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &apos;$&#123;1/[-_]?([a-z]+)/\u$1/g&#125;&apos;,&#125;&lt;/script&gt;endsnippet</code></pre><p>展开后内容为：</p><pre><code class="hljs vue">&lt;template&gt;  &lt;div class=&quot;test-component&quot;&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &apos;TestComponent&apos;,&#125;&lt;/script&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;UltiSnips 不愧为 vim （或乃至所有编辑器）生态下的最佳代码片段解决方案。支持多种常见语法、snippet 添加和管理符合直觉（此处应 cue 一下隔壁对多行文本支持令人垂泪的 vscode）、还有眼花缭乱的 python 脚本插值供 &lt;a href=&quot;http
      
    
    </summary>
    
    
      <category term="工具" scheme="http://hikerpig.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Vim" scheme="http://hikerpig.github.io/tags/Vim/"/>
    
      <category term="UltiSnips" scheme="http://hikerpig.github.io/tags/UltiSnips/"/>
    
  </entry>
  
  <entry>
    <title>浏览器 IndexedDB 存储限制</title>
    <link href="http://hikerpig.github.io/2019/12/11/2019-12-11-Browser-Storage-Limit/"/>
    <id>http://hikerpig.github.io/2019/12/11/2019-12-11-Browser-Storage-Limit/</id>
    <published>2019-12-10T16:00:00.000Z</published>
    <updated>2020-04-09T10:05:04.197Z</updated>
    
    <content type="html"><![CDATA[<p>以下列出在 <a href="https://duomu.tv/" target="_blank" rel="noopener">夺目</a> 产品的开发中，对 WebStorage 和 IndexedDB 使用的一些经验。</p><h1 id="webstorage-存储空间限制">WebStorage 存储空间限制</h1><p>首先，存储分为两种：</p><ol type="1"><li>临时存储 (Temporary Storage)，默认类型，之后可能会被浏览器删除。</li><li>持久存储 (Persistent Storage)，不会被浏览器自动删除，可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/StorageManager/persist" target="_blank" rel="noopener">StorageManager::persist()</a> 方法将<strong>此域名</strong>的存储类型转为持久型，此时浏览器会弹出弹窗征求用户许可，用户也可以选择拒绝。</li></ol><p>根据 <a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Browser_storage_limits_and_eviction_criteria#Storage_limits" target="_blank" rel="noopener">MDN 的文档</a>，浏览器分配给数据存储的磁盘空间大小是动态的，会根据磁盘剩余空间决定，同时对于一个具体域名下的空间分配也有一定策略。</p><p>Firefox 的策略为：</p><ol type="1"><li>全局限制 (Global Limit)，50% 剩余磁盘空间</li><li>域名组限制，大约是 20% 的全局限制量。例如 <code>mozilla.org</code>/<code>joe.blogs.mozilla.org</code>/<code>firefox.com</code> 被认为是同一个域名组，共享一个组限制。</li></ol><p>当磁盘空间告罄，quota manager 会开始删除临时存储 (temporary storage)，以<strong>域名</strong>为单位删除，直到觉得磁盘空间余量尚足。</p><p>删除顺序遵循 LRU 原则，最后访问时间距离现在最远的域名下的 object store 会被整个删除。</p><p>目前 chrome (79) 的策略细节可能不太一样，但还没有找到具体文档描述。</p><h2 id="查询当前存储空间状况">查询当前存储空间状况</h2><p>使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/StorageManager/estimate" target="_blank" rel="noopener">StorageManager::estimate()</a> 方法查询当前存储空间的配额 (quota) 和已使用量 (usage)。</p><p>详细描述在 <a href="https://storage.spec.whatwg.org/" target="_blank" rel="noopener">Stroage 草案</a> 中可查。</p><pre><code class="hljs js">navigator.storage.estimate().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">estimate</span>) </span>&#123;  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"percent"</span>).innerHTML =      (estimate.usage / estimate.quota * <span class="hljs-number">100</span>).toFixed(<span class="hljs-number">2</span>);&#125;);</code></pre><p>额外一说，在 Chrome 中返回的 estimate 还会多出一个非标准字段 <code>usageDetails</code>，能看到更详细的信息。</p><pre><code class="hljs json">"usageDetails": &#123;  "caches": 197632,  "indexedDB": 187255711,  "serviceWorkerRegistrations": 1561632&#125;</code></pre><h1 id="实际使用时一些技术选择考量">实际使用时，一些技术选择考量</h1><h2 id="存储大文件和数据块">存储大文件和数据块</h2><p>IndexedDB 在 WebApp 中可以担任数据持久层，比起更早的基于字符串的 LocalStorage ，可以存储更复杂、更多样化和更大的数据。以下是一些常见的场景：</p><ul><li>ArrayBuffer/Uint8Array/Float32Array 存储等二进制数据和视图对象，用作密集计算</li><li>ImageData 在基于 canvas 的绘图程序或游戏中做绘制结果缓存</li><li>File/Blob 文件分片上传，大文件存储</li></ul><h2 id="blob-与常用二进制数据类型互转">Blob 与常用二进制数据类型互转</h2><p>如果文件很大，建议使用 File/Blob，目前在 mac chrome 79 上测试，保存包含 ArrayBuffer 的单条记录超过 100MB，便会写入失败。</p><p>使用 Blob（或者基于它的 File 对象） 还有许多好处，如果应用的主要功能是音视频相关处理，使用 <code>URL.createObjectURL(blob)</code> 生成的字符串最后能直接作为原生 DOM 的 img/video/audio 标签接受的 src。而且 <code>blob.type</code> 是有意义的 MIME Type，在调试数据的时候也有更多的信息。因此 Blob 很适合作为处理后可以直接展示的成品存储。</p><p>但若数据需要被修改和操作，Blob 需要转化为 ArrayBuffer 以及具体的类型数据视图 Uint8Array 等使用。</p><h3 id="blob---arraybuffer">Blob -&gt; ArrayBuffer</h3><p>以下两种方法，都为异步过程</p><p>1 使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob/arrayBuffer" target="_blank" rel="noopener">blob.arrayBuffer()</a> 方法。此方法为标准的推荐，不过目前浏览器支持有限。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> arrayBuffer = awiat blob.arrayBuffer()</code></pre><p>2 使用 <code>FileReader</code></p><pre><code class="hljs js"><span class="hljs-keyword">let</span> arrayBuffer<span class="hljs-keyword">const</span> fr = <span class="hljs-keyword">new</span> FileReader()fr.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;  arrayBuffer = e.target.value&#125;fr.readAsArrayBuffer(blob)</code></pre><h3 id="arraybuffer---blob">ArrayBuffer -&gt; Blob</h3><p>同步过程</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">new</span> Blob([arrayBuffer], &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">'video/mp4'</span> &#125;)</code></pre><h1 id="参考">参考</h1><p>https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Browser_storage_limits_and_eviction_criteria</p><p>https://developers.google.com/web/updates/2016/06/persistent-storage</p><p>https://developer.chrome.com/apps/offline_storage</p><p>https://stackoverflow.com/questions/17809824/how-to-use-navigator-instead-of-window-webkitstorageinfo-html5-file-system-api</p>]]></content>
    
    <summary type="html">
    
      对 WebStorage 和 IndexedDB 使用的一些经验
    
    </summary>
    
    
      <category term="前端" scheme="http://hikerpig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="IndexedDB" scheme="http://hikerpig.github.io/tags/IndexedDB/"/>
    
      <category term="WebStorage" scheme="http://hikerpig.github.io/tags/WebStorage/"/>
    
      <category term="Browser" scheme="http://hikerpig.github.io/tags/Browser/"/>
    
  </entry>
  
  <entry>
    <title>编译 Skia canvaskit.wasm</title>
    <link href="http://hikerpig.github.io/2019/09/24/2019-09-24-Compile-Skia-Canvaskit-WASM/"/>
    <id>http://hikerpig.github.io/2019/09/24/2019-09-24-Compile-Skia-Canvaskit-WASM/</id>
    <published>2019-09-23T16:00:00.000Z</published>
    <updated>2020-03-30T03:57:45.634Z</updated>
    
    <content type="html"><![CDATA[<p>Skia 是 Google 一个开源的跨平台图形库，用于 Android, Chromium, Flutter 等项目。目前项目内有在开发的一个 Skia + WebAssembly 版的 <a href="https://skia.org/user/modules/canvaskit" target="_blank" rel="noopener">CanvasKit</a>, 可以使用 JS 调用预先编译好的 c++ -&gt; wasm 模块，为一些跨平台的图形项目(例如 lottie 的 Skia 版 <a href="https://skia.org/user/modules/skottie" target="_blank" rel="noopener">skottie</a> )移植到 web 端提供了一种新的可能性。</p><h1 id="编译">编译</h1><h2 id="skia-代码准备">Skia 代码准备</h2><p>下载和编译源码部分参看官方文档 <a href="https://skia.org/user/build" target="_blank" rel="noopener">How to build Skia</a>, 准备好梯子。</p><p>canvaskit 相关源码都在 <code>modules/canvaskit</code> 目录下。</p><p>拉取完代码后进行到同步依赖这一步就行。因为我们的构建脚本在 <code>modules/canvaskit</code> 里已经有了，可以不用从头编译所有 skia 样例代码和可执行程序，当然了你也可以跟着教程构建完整项目，加深对各功能模块的理解。</p><pre><code class="hljs undefined">python2 tools/git-<span class="hljs-keyword">sync</span>-deps</code></pre><h2 id="选择-emscripten-工具链">选择 emscripten 工具链</h2><p>使用 <a href="https://github.com/emscripten-core/emsdk" target="_blank" rel="noopener">emsdk</a> 安装 emscripten 相关工具链。</p><p>emsdk 的各个发行 tag 里有几套命名，例如 <code>1.38.45</code> 和 <code>1.38.45-upstream</code>, 区别在于前者使用 fastcomp 后端，后者使用 llvm 后端。虽然 emscripten 官方推荐使用较新的 llvm 后端，但是在对 canvaskit 里实际使用的时候我发现 <code>wasm-ld</code> 步骤会报错，无法编译成功。 因此选择 fastcomp 版。</p><pre><code class="hljs undefined"><span class="hljs-selector-tag">emsdk</span> <span class="hljs-selector-tag">install</span> 1<span class="hljs-selector-class">.38</span><span class="hljs-selector-class">.45</span></code></pre><h2 id="canvaskitcompile.sh">canvaskit/compile.sh</h2><p>这个编译脚本组织了调用 gn 和 em++ 的参数。有以下可选参数，不细看的话可以直接跳到下一步<a href="#编译步骤">编译步骤</a></p><ul><li><code>no_font</code> / <code>no_embedded_font</code> 字体管理相关，不指定的话会包括 skia fontmgr 相关内容，且内嵌一个默认字体 <code>NotoMono-Regular.ttf</code></li><li><code>debug</code> / <code>profiling</code> 不指定的话默认按照 release 标准，开启最高代码优化模式。</li><li><code>cpu</code> 不指定的话默认会加上 webgl 支持。</li><li><code>no_canvas</code> 指定的话会排除掉 htmlcanvas/*.js 文件</li></ul><h2 id="编译步骤">编译步骤</h2><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/dev/emsdk/emsdk_env.shemsdk activate 1.38.45<span class="hljs-built_in">cd</span> /path/to/skia./modules/canvaskit/compile.sh</code></pre><p>喝杯茶伸伸懒腰，大概四五分钟后，等到最后一步 log 'Generating final wasm' 完成，便可以在 <code>skia/out/canvaskit_wasm</code> 里找到结果文件。</p><pre><code class="hljs undefined">canvaskit<span class="hljs-selector-class">.js</span>  canvaskit<span class="hljs-selector-class">.wasm</span> ...</code></pre><h2 id="tips">TIPS</h2><ul><li>不知道别的 emsdk 编译的之前结果有没有影响，所以如果更换了 emsdk 的版本，推荐开始前 <code>emcc --clear-cache</code></li></ul><h1 id="查看效果">查看效果</h1><p>使用刚才编译出来的 js/wasm 文件查看效果。</p><pre><code class="hljs undefined">cd <span class="hljs-meta-keyword">/path/</span>to<span class="hljs-meta-keyword">/skia/</span>modules/canvaskitmkdir -p node_modules/canvaskitln -s <span class="hljs-meta-keyword">/path/</span>to<span class="hljs-meta-keyword">/skia/</span>out/canvaskit_wasm node_modules<span class="hljs-meta-keyword">/canvaskit/</span>bin</code></pre><p>使用一个简单的 http 静态服务器程序 (如 <a href="https://www.npmjs.com/package/http-server" target="_blank" rel="noopener">http-server</a> ) ：</p><pre><code class="hljs undefined">http-<span class="hljs-keyword">server</span> .</code></pre><p>然后可以在 <code>http://127.0.0.1:8080/canvaskit/example.html</code> 和 <code>http://127.0.0.1:8080/canvaskit/extra.html</code> 页面里看示意效果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Skia 是 Google 一个开源的跨平台图形库，用于 Android, Chromium, Flutter 等项目。目前项目内有在开发的一个 Skia + WebAssembly 版的 &lt;a href=&quot;https://skia.org/user/modules/can
      
    
    </summary>
    
    
      <category term="前端" scheme="http://hikerpig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="WebAssembly" scheme="http://hikerpig.github.io/tags/WebAssembly/"/>
    
      <category term="Skia" scheme="http://hikerpig.github.io/tags/Skia/"/>
    
  </entry>
  
  <entry>
    <title>在浏览器端检测电脑是否刚从休眠中醒来</title>
    <link href="http://hikerpig.github.io/2019/09/04/2019-09-04-Detect-Computer-Resume-From-Sleep-In-Browser/"/>
    <id>http://hikerpig.github.io/2019/09/04/2019-09-04-Detect-Computer-Resume-From-Sleep-In-Browser/</id>
    <published>2019-09-03T16:00:00.000Z</published>
    <updated>2019-09-06T03:49:42.517Z</updated>
    
    <content type="html"><![CDATA[<p>当电脑进入休眠状态，浏览器的一些持久功能会受到影响(例如 WebSocket 连接中断)，有时需要在从休眠状态中恢复过来的时候做一些检查和恢复工作。</p><h1 id="解决方案">解决方案</h1><h2 id="利用计时器">利用计时器</h2><pre><code class="hljs js"><span class="hljs-keyword">let</span> lastTime = (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()).getTime()<span class="hljs-comment">// 可能由于脚本计算量大，或是使用了 alert/confirm 等阻塞线程的函数，的确会有些小误差，可以忽略掉</span><span class="hljs-keyword">const</span> THRESHOLD = <span class="hljs-number">15000</span>setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">const</span> currentTime = <span class="hljs-built_in">Date</span>.now()  <span class="hljs-keyword">if</span> (currentTime &gt; (lastTime + THRESHOLD)) &#123;    <span class="hljs-comment">// 刚醒来，做点什么呢</span>  &#125;  lastTime = currentTime&#125;, <span class="hljs-number">30000</span>); <span class="hljs-comment">// 30s 比较保守，可以根据业务需求来调整</span></code></pre><h1 id="参考">参考</h1><ul><li><a href="https://stackoverflow.com/questions/4079115/can-any-desktop-browsers-detect-when-the-computer-resumes-from-sleep" target="_blank" rel="noopener">Can any desktop browsers detect when the computer resumes from sleep?</a></li></ul>]]></content>
    
    <summary type="html">
    
      当电脑进入休眠状态，浏览器的一些持久功能会受到影响(例如 WebSocket 连接中断)，有时需要在从休眠状态中恢复过来的时候做一些检查和恢复工作
    
    </summary>
    
    
      <category term="前端" scheme="http://hikerpig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="浏览器" scheme="http://hikerpig.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>命令行下的图片压缩工具</title>
    <link href="http://hikerpig.github.io/2019/08/20/2019-08-20-Run-Image-Optimize-With-Cli/"/>
    <id>http://hikerpig.github.io/2019/08/20/2019-08-20-Run-Image-Optimize-With-Cli/</id>
    <published>2019-08-19T16:00:00.000Z</published>
    <updated>2019-08-20T11:09:12.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="imagemin-cli">imagemin-cli</h1><p><a href="https://github.com/imagemin/imagemin-cli" target="_blank" rel="noopener">imagemin/imagemin-cli</a> 是一个用 node.js 写的工具，调用的都是纯 CLI 的开源程序，所以平台兼容性好很多。其依赖的 <a href="https://github.com/imagemin/imagemin" target="_blank" rel="noopener">imagemin</a> 项目支持 <code>imagemin-*</code> 形式的 npm package 插件扩展，cli 默认的插件有这 4 个。</p><pre><code class="hljs undefined"><span class="hljs-symbol">'gifsicle</span>'<span class="hljs-symbol">'jpegtran</span>'<span class="hljs-symbol">'optipng</span>'<span class="hljs-symbol">'svgo</span>'</code></pre><p>使用的时候会检测当前系统变量里有没有对应的可执行文件，没有的话会自动下载安装，真正做到了开箱即用。imagemin 在前端自动化工作流中有诸多支持，例如 <a href="https://github.com/Klathmon/imagemin-webpack-plugin" target="_blank" rel="noopener">imagemin-webpack-plugin</a>，<a href="https://github.com/sindresorhus/gulp-imagemin" target="_blank" rel="noopener">gulp-imagemin</a>。</p><p>官方维护的插件列表和项目构建支持可见 <a href="https://github.com/imagemin" target="_blank" rel="noopener">github 下的 imagemin 组织</a> 。</p><h2 id="使用示例">使用示例</h2><p><code>--help</code> 里给的例子:</p><pre><code class="hljs undefined">Examples<span class="hljs-meta">  $</span><span class="bash"> imagemin images/* --out-dir=build</span><span class="hljs-meta">  $</span><span class="bash"> imagemin foo.png &gt; foo-optimized.png</span><span class="hljs-meta">  $</span><span class="bash"> cat foo.png | imagemin &gt; foo-optimized.png</span><span class="hljs-meta">  $</span><span class="bash"> imagemin --plugin=pngquant foo.png &gt; foo-optimized.png</span></code></pre><h1 id="imageoptim-cli">ImageOptim-CLI</h1><p>仅 Mac 可用，<a href="https://github.com/JamieMason/ImageOptim-CLI" target="_blank" rel="noopener">ImageOptim-CLI</a> 包装了几个 Mac 下 GUI/CLI 图片压缩工具的调用，支持调用的 App 有：</p><pre><code>Supported Apps:ImageAlpha: https://pngmini.comImageOptim: https://imageoptim.comJPEGmini Lite: https://itunes.apple.com/us/app/jpegmini-lite/id525742250JPEGmini Pro: https://itunes.apple.com/us/app/jpegmini-pro/id887163276JPEGmini: https://itunes.apple.com/us/app/jpegmini/id498944723</code></pre><p>常见的 JPEG/PNG/GIF/SVG 等格式都可以压缩。</p><p>调用方式很暴力，直接硬编码了应用的路径。</p><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> PNGQUANT_BIN_PATH = <span class="hljs-string">'/Applications/ImageAlpha.app/Contents/MacOS/pngquant'</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> IMAGEOPTIM_BIN_PATH = <span class="hljs-string">'/Applications/ImageOptim.app/Contents/MacOS/ImageOptim'</span>;</code></pre><p>所以先要提前安装好相应的 App。</p><h2 id="安装">安装</h2><pre><code class="hljs bash">npm install -g imageoptim-cli</code></pre><p>默认使用的是 <a href="https://imageoptim.com/mac" target="_blank" rel="noopener">ImageOptim</a>，一个开源的 GUI 图片压缩工具，集成了针对各种格式图片的优秀开源压缩工具。</p><blockquote><p><a href="https://imageoptim.com/" target="_blank" rel="noopener">ImageOptim</a> is a GUI for lossless image optimization tools: Zopfli, PNGOUT, <a href="https://crates.rs/crates/oxipng" target="_blank" rel="noopener">OxiPNG</a>, AdvPNG, PNGCrush, <a href="https://github.com/tjko/jpegoptim" target="_blank" rel="noopener">JPEGOptim</a>, Jpegtran, <a href="https://github.com/google/guetzli" target="_blank" rel="noopener">Guetzli</a>, <a href="https://kornel.ski/lossygif" target="_blank" rel="noopener">Gifsicle</a>, <a href="https://github.com/svg/svgo" target="_blank" rel="noopener">SVGO</a>, <a href="https://github.com/RazrFalcon/svgcleaner" target="_blank" rel="noopener">svgcleaner</a> and <a href="https://github.com/mozilla/mozjpeg" target="_blank" rel="noopener">MozJPEG</a>.</p></blockquote><pre><code class="hljs bash">brew cask install imageoptim</code></pre><h2 id="使用">使用</h2><p>处理 JPEG 格式还是挺快的。</p><pre><code class="hljs bash">$ imageoptim <span class="hljs-string">'**/*.jpg'</span> <span class="hljs-string">'**/*.jpeg'</span>i Running ImageOptim...✓ coffeetags_tagbar.jpg was: 845kB now: 786kB saving: 58.4kB (6.91%)✓ compare-shadow-blur.jpg was: 22.4kB now: 22.4kB saving: 0B (0.00%)✓ stack-or-gtfo.jpg was: 98.1kB now: 68.1kB saving: 30kB (30.59%)✓ truck.jpg was: 449kB now: 401kB saving: 47.7kB (10.63%)✓ fonts/kosugi-maru-1.jpg was: 22.9kB now: 14.4kB saving: 8.54kB (37.29%)✓ fonts/noto-sans-jp-1.jpg was: 24.9kB now: 15.8kB saving: 9.17kB (36.79%)✓ tabs/santa_monica_dream_-_angus_and_julia.jpg was: 263kB now: 189kB saving: 73.4kB (27.94%)✓ CSS_EX1.jpeg was: 538kB now: 495kB saving: 43.6kB (8.10%)✓ TOTAL was: 2.26MB now: 1.99MB saving: 271kB (11.97%)✓ Finished</code></pre><p>处理 PNG 时有点慢，可能是因为使用底层的 <a href="https://pngquant.org/" target="_blank" rel="noopener">pngquant</a> 时的参数问题，计算量有点大。</p><pre><code class="hljs bash">$ time imageoptim <span class="hljs-string">'**/*.png'</span>i Running ImageOptim...✓ org-mode-code.png was: 36.6kB now: 15.8kB saving: 20.8kB (56.78%)✓ screenshot.png was: 109kB now: 42kB saving: 67.2kB (61.55%)✓ vimwiki-code.png was: 34kB now: 14.3kB saving: 19.7kB (57.90%)✓ TOTAL was: 180kB now: 72.1kB saving: 108kB (59.89%)✓ Finishedimageoptim <span class="hljs-string">'**/*.png'</span>  146.20s user 1.37s system 290% cpu 50.865 total</code></pre><p>如已经安装了 <a href="https://pngmini.com" target="_blank" rel="noopener">ImageAlpha</a> ，加上参数 <code>--imagealpha</code>，先调用 ImageAlpha，处理 PNG 的效率和速度都有很大提升。</p><pre><code class="hljs bash">$ time imageoptim --imagealpha <span class="hljs-string">'**/*.png'</span>i Running ImageAlpha...i Running ImageOptim...✓ org-mode-code.png was: 36.6kB now: 5.64kB saving: 31kB (84.60%)✓ screenshot.png was: 109kB now: 15.8kB saving: 93.4kB (85.56%)✓ vimwiki-code.png was: 34kB now: 4.72kB saving: 29.3kB (86.11%)✓ TOTAL was: 180kB now: 26.1kB saving: 154kB (85.47%)✓ Finishedimageoptim --imagealpha <span class="hljs-string">'**/*.png'</span>  55.98s user 0.75s system 298% cpu 18.985 total</code></pre><p>CLI 提供了 <code>--quality</code> 和 <code>--speed</code> 两个细化的调整参数，仔细调整可能有更合适的速度/压缩率组合。</p><p>对于不同工具对不同格式和特性的压缩效果，作者给出了<a href="http://jamiemason.github.io/ImageOptim-CLI/" target="_blank" rel="noopener">一份评测数据</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;imagemin-cli&quot;&gt;imagemin-cli&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/imagemin/imagemin-cli&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;imagemin/imagem
      
    
    </summary>
    
    
      <category term="工具" scheme="http://hikerpig.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://hikerpig.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="图片" scheme="http://hikerpig.github.io/tags/%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>使用 Typescript 加强 Vuex 使用体验</title>
    <link href="http://hikerpig.github.io/2019/06/17/2019-06-17-typescript-powered-vuex/"/>
    <id>http://hikerpig.github.io/2019/06/17/2019-06-17-typescript-powered-vuex/</id>
    <published>2019-06-16T16:00:00.000Z</published>
    <updated>2019-12-30T08:46:46.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="碰到的问题">碰到的问题</h1><h2 id="如履针毡的状态管理和业务逻辑调用">如履针毡的状态管理和业务逻辑调用</h2><p>Vuex 使用了统一的 <code>dispatch</code>/<code>commit</code> 方法去触发 Action 和 Mutation, 如果使用嵌套的 module, Vuex 还会解析命名空间，以找到正确的 Action/Mutation 函数。</p><p>对于组件来说很友好，但是对于项目维护来说可能就稍显痛苦。虽然对状态的更改都从视图逻辑里分离出来放在了 store 文件夹下，一目了然，但是对于触发 Action 的组件来说，维持与 store 部分的函数签名和接口统一，就不得不靠全局搜索了（由此催发了一些 Vuex 下的最佳实践，例如动作名称都用 CAPITAL_SNAKE_CASE 命名法，或是抽取出 mutation-types.js 文件）。</p><p>随着项目的推进，一旦 Action 有变动（增减参数数量或是改变类型等等），项目里有5个地方用到了它，而你粗心地只改了 4 个地方，在一个犄角旮旯的平时不会用到也没有测试覆盖的地方，一个炸弹默默地就冒了出来。</p><p>在 Javascript 能力的限制下，只好靠命名规范和小心翼翼（不断搜索和确认修改）来规避的问题。其实借助 Typescript 强大的类型推断能力，这种心智负担是完全可以避免的。</p><h1 id="解决方案">解决方案</h1><p>vuex 的 d.ts 文件提供了一些很有用的类型，不过里面有好多 any, 我们其实可以在其之上再细化一下类型限制。</p><h2 id="关键代码">关键代码</h2><p>这个文件导出了一些类型，以及两个需要传入类型的高阶函数 <code>makeDispatcher</code> 和 <code>makeMutator</code>，具体使用可以看再之后的示例。</p><pre><code class="hljs typescript"><span class="hljs-comment">// vuex-util.ts</span><span class="hljs-keyword">import</span> &#123; ActionContext, Store, Module &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vuex'</span><span class="hljs-keyword">type</span> DictOf&lt;T&gt; = &#123;[key: <span class="hljs-built_in">string</span>]: T &#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> ActionDescriptor = [<span class="hljs-built_in">any</span>, <span class="hljs-built_in">any</span>]<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> ModuleActions&lt;Context, Descriptor <span class="hljs-keyword">extends</span> DictOf&lt;ActionDescriptor&gt;&gt; = &#123;  [K <span class="hljs-keyword">in</span> keyof Descriptor]: <span class="hljs-function">(<span class="hljs-params">ctx: Context, payload: Descriptor[K][0]</span>) =&gt;</span> Descriptor[K][<span class="hljs-number">1</span>]&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> ModuleMutations&lt;State, PayloadTree&gt; = &#123;  [K <span class="hljs-keyword">in</span> keyof PayloadTree]: <span class="hljs-function">(<span class="hljs-params">state: State, payload: PayloadTree[K]</span>) =&gt;</span> <span class="hljs-built_in">any</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isStore</span>(<span class="hljs-params">context: <span class="hljs-built_in">any</span></span>) </span>&#123;  <span class="hljs-keyword">return</span> (<span class="hljs-string">'strict'</span> <span class="hljs-keyword">in</span> context)&#125;<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeDispatcher</span>&lt;<span class="hljs-title">Context</span> <span class="hljs-title">extends</span> <span class="hljs-title">ActionContext</span>&lt;<span class="hljs-title">any</span>, <span class="hljs-title">any</span>&gt;, <span class="hljs-title">Descriptor</span> <span class="hljs-title">extends</span> <span class="hljs-title">DictOf</span>&lt;<span class="hljs-title">ActionDescriptor</span>&gt;&gt;(<span class="hljs-params">ns?: <span class="hljs-built_in">string</span></span>) </span>&#123;  <span class="hljs-keyword">return</span> &lt;K <span class="hljs-keyword">extends</span> keyof Descriptor&gt;(    context: Store&lt;<span class="hljs-built_in">any</span>&gt; | Context,    action: K,    payload: Descriptor[K][<span class="hljs-number">0</span>],  ) =&gt; &#123;    <span class="hljs-keyword">const</span> _context: <span class="hljs-built_in">any</span> = context    <span class="hljs-keyword">let</span> actionName = action <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>    <span class="hljs-keyword">if</span> (ns &amp;&amp; isStore(context)) &#123;      actionName = <span class="hljs-string">`<span class="hljs-subst">$&#123;ns&#125;</span>/<span class="hljs-subst">$&#123;action&#125;</span>`</span>    &#125;    <span class="hljs-keyword">return</span> _context.dispatch(actionName, payload)  &#125;&#125;<span class="hljs-comment">/** * 当此模块为 namespaced 的时候, `$store.commit(mutation)` 和在 action handler 内的 `ctx.commit(mutation)` 是不一样的 */</span><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeMutator</span>&lt;<span class="hljs-title">Context</span> <span class="hljs-title">extends</span> <span class="hljs-title">ActionContext</span>&lt;<span class="hljs-title">any</span>, <span class="hljs-title">any</span>&gt;, <span class="hljs-title">MutationPayloadTree</span>&gt;(<span class="hljs-params">ns?: <span class="hljs-built_in">string</span></span>) </span>&#123;  <span class="hljs-keyword">return</span> &lt;K <span class="hljs-keyword">extends</span> keyof MutationPayloadTree&gt;(    context: Store&lt;<span class="hljs-built_in">any</span>&gt; | Context,    mutation: K,    payload: MutationPayloadTree[K],  ) =&gt; &#123;    <span class="hljs-keyword">let</span> mutationName = mutation <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>    <span class="hljs-keyword">if</span> (ns &amp;&amp; isStore(context)) &#123;      mutationName = <span class="hljs-string">`<span class="hljs-subst">$&#123;ns&#125;</span>/<span class="hljs-subst">$&#123;mutation&#125;</span>`</span>    &#125;    <span class="hljs-keyword">return</span> context.commit(mutationName, payload)  &#125;&#125;</code></pre><h2 id="使用示例-一个-todo-app">使用示例, 一个 Todo App</h2><h3 id="导出-vuex-module">导出 Vuex Module</h3><p>首先列一下最后导出的 Vuex Module 声明:</p><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; ActionContext, Module &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vuex'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> VUEX_NS = <span class="hljs-string">'todo'</span><span class="hljs-comment">/** 此对象接收类型变量, 分别代表 module state 和 rootState 类型 */</span><span class="hljs-keyword">type</span> TodoContext = ActionContext&lt;TodosState, GlobalState&gt;<span class="hljs-comment">// ...</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  namespaced: <span class="hljs-literal">true</span>,  state: &#123;...&#125;,  actions: ACTIONS,  mutations: MUTATIONS,&#125; <span class="hljs-keyword">as</span> Module&lt;TodosState, GlobalState&gt;</code></pre><h3 id="简单的-actions-和-mutations">简单的 ACTIONS 和 MUTATIONS</h3><p>声明 ACTIONS，非常简单地从 localStorage 里取出数据，然后调用 <code>SET_TODOS</code> mutation:</p><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> ActionDescriptors = &#123;  GET_USER_TODOS: [&#123;&#125;, <span class="hljs-built_in">void</span>]&#125;<span class="hljs-keyword">const</span> ACTIONS: ModuleActions&lt;TodoContext, ActionDescriptors&gt; = &#123;  GET_USER_TODOS(ctx) &#123;    <span class="hljs-keyword">const</span> todos = <span class="hljs-built_in">JSON</span>.parse(localStorage.getItem(<span class="hljs-string">'todoItems'</span>)) || []    ctx.dispatch(<span class="hljs-string">'SET_TODOS'</span>, &#123; todos &#125;)  &#125;,&#125;</code></pre><p>接下来实现 MUTAIONS，先声明好所有 Mutation 需要的参数，并使用工具类型 <code>ModuleMutations</code> 标注即将给 Vuex Module 传递的 mutations 对象：</p><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> MutationPayloads = &#123;  SET_TODOS: &#123; todos: TodoItem[] &#125;&#125;<span class="hljs-keyword">const</span> MUTATIONS: ModuleMutations&lt;TodosState, MutationPayloads&gt; = &#123;&#125;</code></pre><p>此时，TS 编译器会提示错误，是因为 <code>ModuleMutations</code> 这个工具类型要求包含第二个类型参数中所有的 key，一个空 Object 没有实现 <code>MutationPayloads</code> 所要求的 <code>SET_TODOS</code> 方法，因此会抛出 TS Error。</p><pre><code class="hljs typescript"> <span class="hljs-keyword">const</span>  MUTATIONS:  ModuleMutations&lt;TodosState,  MutationPayloads&gt; <span class="hljs-string">'MUTATIONS'</span> is declared but its value is never read.ts(<span class="hljs-number">6133</span>)Property <span class="hljs-string">'SET_TODOS'</span> is missing <span class="hljs-keyword">in</span> <span class="hljs-keyword">type</span> <span class="hljs-string">'&#123;&#125;'</span> but required <span class="hljs-keyword">in</span> <span class="hljs-keyword">type</span> <span class="hljs-string">'ModuleMutations&lt;TodosState, MutationPayloads&gt;'</span>.ts(<span class="hljs-number">2741</span>)</code></pre><p>接下来可以看看顺滑的编辑器提示体验：</p><figure><img src="https://i.loli.net/2019/06/18/5d08ee57943b421476.gif" alt><figcaption>实现 MUTATIONS</figcaption></figure><p>声明好 <code>MutationPayloads</code> 以后，可以借助一个工具函数生成一个新的类似于 <code>commit</code> 的函数：</p><pre><code class="hljs ts"><span class="hljs-comment">/** * 一个带有类型变量的函数，使用示例 todoItemMutate(actionContext, 'mutationName', mutationPayload) */</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> todoItemMutate = makeMutator&lt;TodoContext, MutationPayloads&gt;(VUEX_NS)</code></pre><p>让我们来改一改 <code>GET_USER_TODOS</code> 里提交 mutation 的方式，同时享受到代码提示：</p><figure><img src="https://i.loli.net/2019/06/18/5d08f24166d5812315.gif" alt><figcaption>调用 mutator</figcaption></figure><p>好的，现在可以使用另一个工具函数，生成一个新的带有类型限制的类似于 <code>dispatch</code> 的函数，并在别处调用：</p><pre><code class="hljs ts"><span class="hljs-comment">/** * 一个带有类型变量的函数，使用示例 todoItemDispatch(actionContext, 'actionName', actionName) */</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> todoItemDispatch = makeDispatcher&lt;TodoContext, ActionDescriptors&gt;(VUEX_NS)...todoItemDispatch(store, <span class="hljs-string">'GET_USER_TODOS'</span>, &#123;&#125;)</code></pre><h3 id="然后需求改了">然后，需求改了！</h3><p>此时你决定 TodoApp 需要能支持多用户，每个用户有自己的记录。那么 ACTIONS 接口说明需要更改：</p><pre><code class="hljs undefined"><span class="hljs-keyword">type</span> <span class="hljs-type">ActionDescriptors</span> = &#123;  <span class="hljs-type">GET_USER_TODOS</span>: [&#123; userName: string &#125;, void]&#125;</code></pre><p>此时编译器会报错，在上一节最后的 <code>todoItemDispatch</code> 调用处：</p><pre><code class="hljs ts">Argument of <span class="hljs-keyword">type</span> <span class="hljs-string">'&#123;&#125;'</span> is not assignable to parameter of <span class="hljs-keyword">type</span> <span class="hljs-string">'&#123; userName: string; &#125;'</span>.  Property <span class="hljs-string">'userName'</span> is missing <span class="hljs-keyword">in</span> <span class="hljs-keyword">type</span> <span class="hljs-string">'&#123;&#125;'</span> but required <span class="hljs-keyword">in</span> <span class="hljs-keyword">type</span> <span class="hljs-string">'&#123; userName: string; &#125;'</span>.ts(<span class="hljs-number">2345</span>)todo.ts(., .): <span class="hljs-string">'userName'</span> is declared here.</code></pre><p>好的，现在开心地来到出错地方，改一改:</p><pre><code class="hljs ts">todoItemDispatch(store, <span class="hljs-string">'GET_USER_TODOS'</span>, &#123; userName: <span class="hljs-string">'hikerpig'</span> &#125;)</code></pre><p>没有全局搜索，不用做无谓的参数检查单元测试。</p><h1 id="总结">总结</h1><h2 id="优点">优点</h2><ul><li>优化开发时的体验</li><li>不改变原先 actions 和 mutations 成员函数实现的方式，也不像 vuex-typescript 引入了一些额外的 class</li></ul><h2 id="缺点">缺点</h2><ul><li>接口描述的类型需要提前单独声明，没法直接使用函数的签名</li><li>没法把所有类型增强合并为一个统一的 <code>dispath</code> 函数，其他文件里的代码若想享受这个类型增强，必须显式地 import <code>todoItemDispatch</code>/<code>todoItemMutate</code> 方法，略微麻烦</li></ul>]]></content>
    
    <summary type="html">
    
      Typescript powered vuex, 使用 Typescript 加强 Vuex 使用体验
    
    </summary>
    
    
      <category term="前端" scheme="http://hikerpig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Typescript" scheme="http://hikerpig.github.io/tags/Typescript/"/>
    
      <category term="Vuex" scheme="http://hikerpig.github.io/tags/Vuex/"/>
    
  </entry>
  
  <entry>
    <title>图像近似高斯模糊的快速实现，以及 WebAssembly 模块的导出</title>
    <link href="http://hikerpig.github.io/2019/05/13/2019-05-13-Fastblur-implemetation-with-rust/"/>
    <id>http://hikerpig.github.io/2019/05/13/2019-05-13-Fastblur-implemetation-with-rust/</id>
    <published>2019-05-12T16:00:00.000Z</published>
    <updated>2020-03-16T05:26:52.900Z</updated>
    
    <content type="html"><![CDATA[<p>在图像处理软件中的模糊滤镜一般都会有<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A?oldformat=true" target="_blank" rel="noopener">高斯模糊（Gaussian Blur）</a>，因为它效果最好，接近人眼的模糊效果（也许是由于正态分布的无处不在？）。但对图像做真正的高斯模糊（在我的理解，也即使用满足二阶正态分布的卷积核对二维离散分布的空间域做平滑处理），由于卷积的定义，计算量颇大。可以采用一些快速的算法去模拟这个效果。</p><h1 id="使用盒模糊模拟高斯模糊">使用盒模糊模拟高斯模糊</h1><p>根据 <a href="http://blog.ivank.net/fastest-gaussian-blur.html" target="_blank" rel="noopener">Photopea 作者的这个 JS 实现</a> 和 <a href="http://www.peterkovesi.com/papers/FastGaussianSmoothing.pdf" target="_blank" rel="noopener">论文 《Fast Almost-Gaussian Filtering》</a>中的论证，通过对图像进行多次盒模糊操作，可模拟高斯模糊的效果。设盒模糊次数为 n，当 n = 5 时，模拟效果已足够好。</p><h2 id="盒滤波-box-filter">盒滤波 Box filter</h2><p>平均滤波（Average filter），或称均值滤波（Mean filter）卷积核的每一点权重都是一样的，2 维情况下就像在图像上扣着的一个方盒子，所以也称作盒滤波。一个边长为 3 的二维盒滤波的卷积核如下</p><p><br><span class="math display">$$\left[ \begin{array}{lll}{1} &amp; {1} &amp; {1} \\ {1} &amp; {1} &amp; {1} \\ {1} &amp; {1} &amp; {1}\end{array}\right]$$</span><br></p><p>为什么使用盒滤波呢？除了实现简单以外，还有性能上的考量。由于权重相同，使用盒滤波时有一个可爱的特性能使得计算变得更加快速：对图像在水平方向进行一次一维平均滤波，再在垂直方向进行一次，等价于对整个图片做一次二维盒滤波。</p><h2 id="论文的大概操作思路">论文的大概操作思路</h2><p>论文的论证目标基本上为：需要执行<strong>多少次</strong>盒滤波，以及每一次的<strong>滤波宽度</strong>需要是多少，才能够模拟出近似于高斯滤波器的<strong>标准差</strong>。</p><p>首先盒滤波有一些特性：对于图像经过 n 次盒滤波后，标准差如下，其中 <span class="math inline"><em>w</em></span> 为滤波器宽度。</p><p><br><span class="math display">$$\sigma_{n a v}=\sqrt{\frac{n w^{2}-n}{12}}$$</span><br></p><p>那么为了使得标准差与高斯滤波相同，理想的滤波器宽度 <span class="math inline"><em>w</em><sub><em>i</em><em>d</em><em>e</em><em>a</em><em>l</em></sub></span> 求法：</p><p><br><span class="math display">$$w_{i d e a l}=\sqrt{\frac{12 \sigma^{2}}{n}+1}$$</span><br></p><p>对于图像滤波来说，w 需要是整数，且最好是奇数，如此一来总会有一个中心点的像素值可以被指定。于是在理想宽度附近找到两个奇数，<span class="math inline"><em>w</em><sub><em>l</em></sub> &lt; <em>w</em><sub><em>i</em><em>d</em><em>e</em><em>a</em><em>l</em></sub> &lt; <em>w</em><sub><em>u</em></sub></span>，分别为下限(l)和上限(u)，显然 <span class="math inline"><em>w</em><sub><em>l</em></sub> + 2 = <em>w</em><sub><em>u</em></sub></span>。接下来要进行 n 次平均滤波，设 c 为当前滤波的轮数，从 1 开始，在 <span class="math inline">0 &lt; <em>c</em> &lt;  = <em>m</em></span> 时，滤波器宽度为 <span class="math inline"><em>w</em><sub><em>l</em></sub></span>，在 <span class="math inline"><em>m</em> &lt; <em>c</em> &lt;  = <em>n</em></span> 时，滤波器宽度为 <span class="math inline"><em>w</em><sub><em>u</em></sub></span>。</p><p><br><span class="math display">$$\begin{aligned} \sigma &amp;=\sqrt{\frac{m w_{l}^{2}+(n-m) w_{u}^{2}-n}{12}} \\ &amp;=\sqrt{\frac{m w_{l}^{2}+(n-m)\left(w_{l}+2\right)^{2}-n}{12}} \end{aligned}$$</span><br></p><p>因此算出 m:</p><p><br><span class="math display">$$m=\frac{12 \sigma^{2}-n w_{l}^{2}-4 n w_{l}-3 n}{-4 w_{l}-4}$$</span><br></p><h1 id="开发和使用-webassembly">开发和使用 WebAssembly</h1><p>我们基于 github 上用 rust 写的一个实现，继续填充一些细节，完成了 <a href="https://github.com/bestminr/fastblur" target="_blank" rel="noopener">fastblur</a> 这个模块。</p><p>考虑到中间涉及大量运算，使用 WebAssembly 应该比纯 js 更快点。使用 rust 和 <a href="https://crates.io/crates/image" target="_blank" rel="noopener">image crate</a> 使得算法验证和调试输出能快速进行，同时 rust 有着目前编译到 WebAssembly 最佳的工具链 <a href="https://github.com/rustwasm/wasm-pack" target="_blank" rel="noopener">wasm-pack</a>（毕竟这俩都是 Mozilla 在积极推行的标准）。</p><h2 id="在-typescript-webpack-项目中引入和使用">在 Typescript + Webpack 项目中引入和使用</h2><p>确保 <code>tsconfig.json</code> 中的 <code>compilerOptions.module: esnext</code>，才能方便地使用 <code>import().then()</code>。</p><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">applyFastBlur</span>(<span class="hljs-params">imageData: ImageData, blurRadius: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">Bluebird</span>&lt;<span class="hljs-title">ImageData</span>&gt; </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-keyword">import</span>(<span class="hljs-string">'@bestminr/fastblur'</span>)      .then(<span class="hljs-function">(<span class="hljs-params">m</span>) =&gt;</span> &#123;        <span class="hljs-keyword">const</span> &#123; width, height &#125; = imageData        <span class="hljs-keyword">const</span> inputDataArr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(imageData.data)        m.do_fast_blur(inputDataArr, width, height, blurRadius)        <span class="hljs-keyword">const</span> outputImageData = <span class="hljs-keyword">new</span> ImageData(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8ClampedArray</span>(inputDataArr), width, height)        <span class="hljs-keyword">return</span> resolve(outputImageData)      &#125;).catch(reject)  &#125;)&#125;</code></pre><h2 id="参考">参考</h2><ul><li><a href="http://blog.ivank.net/fastest-gaussian-blur.html" target="_blank" rel="noopener">Fastest Gaussian Blur (in linear time)</a></li><li>http://elynxsdk.free.fr/ext-docs/Blur/Fast_box_blur.pdf</li><li><a href="http://www.peterkovesi.com/papers/FastGaussianSmoothing.pdf" target="_blank" rel="noopener">FastGaussianSmoothing 论文</a></li><li>https://stackoverflow.com/questions/1696113/how-do-i-gaussian-blur-an-image-without-using-any-in-built-gaussian-functions</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在图像处理软件中的模糊滤镜一般都会有&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A?oldformat=true&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
    
      <category term="图像处理" scheme="http://hikerpig.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="WebAssembly" scheme="http://hikerpig.github.io/tags/WebAssembly/"/>
    
      <category term="Rust" scheme="http://hikerpig.github.io/tags/Rust/"/>
    
      <category term="图像处理" scheme="http://hikerpig.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>使用 d8 快速测试 WebAssembly 模块性能</title>
    <link href="http://hikerpig.github.io/2019/05/05/2019-05-05-Benchmark-WASM-with-d8/"/>
    <id>http://hikerpig.github.io/2019/05/05/2019-05-05-Benchmark-WASM-with-d8/</id>
    <published>2019-05-04T16:00:00.000Z</published>
    <updated>2019-05-07T03:09:36.652Z</updated>
    
    <content type="html"><![CDATA[<p>d8 是 v8 的简易 CLI，它提供了一个极简的 JS 宿主环境，可用于 v8 的学习和调试，比起 nodejs，它更精简和专注。</p><p>除了 JS 以外，d8 也具有 WASM 的解释功能，可以方便地用于测试 WASM 模块的性能。如果你的 WASM 是要在浏览器里运行的，比起 wasmtime，v8（以及 spidermonkey 等主流浏览器 JS 引擎）显然是个更合适的命令行测试方案。</p><h2 id="安装-v8">安装 v8</h2><h3 id="使用包管理器">使用包管理器</h3><pre><code class="hljs undefined"><span class="hljs-keyword">brew </span>install <span class="hljs-built_in">v8</span></code></pre><h3 id="使用-jsvu">使用 jsvu</h3><p><a href="https://github.com/GoogleChromeLabs/jsvu" target="_blank" rel="noopener">jsvu</a> 是 GoogleChromeLabs 出品的一个工具, 可以快速安装多个主流 JS 引擎(spidermonkey/v8/chakra/javascriptcore)。不过用它安装的 CLI 名字是 <code>v8</code>。</p><h2 id="使用例子">使用例子</h2><p>不同于 nodejs 的模块系统和库函数，d8 提供给脚本的全局函数很克制。<a href="https://v8.dev/docs/d8" target="_blank" rel="noopener">简易的文档</a>说明了几个，如直接使用 <code>load()</code> 加载和执行外部脚本至当前上下文，或是使用 <code>read()</code> 读取文件内容。</p><p>除了看文档外，还可以去查看 <a href="https://chromium.googlesource.com/v8/v8/+/master/src/d8.cc" target="_blank" rel="noopener">d8.cc 源码</a> 获知 d8 script 支持的全部全局方法。</p><p>可使用 <code>readbuffer()</code> 方法获取 WASM 二进制内容。</p><p>假如用 rust 编译出了一个 <code>rotate.wasm</code> 模块 ，导出了一个简单方法 <code>rotate_90</code>，用于将图片旋转 90 度。</p><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">rotate_90</span></span>(width: <span class="hljs-built_in">usize</span>, height: <span class="hljs-built_in">usize</span>, image_data_ptr: *<span class="hljs-keyword">mut</span> <span class="hljs-built_in">u8</span>)</code></pre><p>简单的测试脚本 <code>benchmark.js</code> 如下:</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> iterTimes = <span class="hljs-number">10</span>;<span class="hljs-keyword">const</span> imageDimensions = <span class="hljs-number">4096</span>;<span class="hljs-keyword">const</span> iterations = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(iterTimes);<span class="hljs-keyword">const</span> imageByteSize = imageDimensions * imageDimensions * <span class="hljs-number">4</span>;<span class="hljs-keyword">const</span> wasmPageSize = <span class="hljs-number">64</span> * <span class="hljs-number">1024</span>;<span class="hljs-keyword">const</span> buffer = readbuffer(<span class="hljs-string">"rotate.wasm"</span>);<span class="hljs-keyword">const</span> &#123; instance &#125; = <span class="hljs-keyword">await</span> WebAssembly.instantiate(buffer);<span class="hljs-keyword">const</span> pagesAvailable = <span class="hljs-built_in">Math</span>.floor(instance.exports.memory.buffer.byteLength / wasmPageSize);<span class="hljs-keyword">const</span> pagesNeeded = <span class="hljs-built_in">Math</span>.floor((imageByteSize * <span class="hljs-number">2</span> + <span class="hljs-number">4</span>) / wasmPageSize) + <span class="hljs-number">1</span>;<span class="hljs-keyword">const</span> additionalPagesNeeded = pagesNeeded - pagesAvailable;<span class="hljs-keyword">if</span> (additionalPagesNeeded &gt; <span class="hljs-number">0</span>) &#123;instance.exports.memory.grow(additionalPagesNeeded);&#125;<span class="hljs-keyword">const</span> imageData = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>(imageByteSize)print(<span class="hljs-string">`==============================`</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; iterTimes; i++) &#123;  <span class="hljs-keyword">const</span> view = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8ClampedArray</span>(instance.exports.memory.buffer);  <span class="hljs-keyword">const</span> dataPtr = <span class="hljs-number">8</span>;  view.set(imageData.data, dataPtr);  <span class="hljs-keyword">const</span> start = <span class="hljs-built_in">Date</span>.now();  instance.exports.rotate_90(imageDimensions, imageDimensions, dataPtr);  iterations[i] = <span class="hljs-built_in">Date</span>.now() - start;&#125;<span class="hljs-keyword">const</span> average = iterations.reduce(<span class="hljs-function">(<span class="hljs-params">sum, c</span>) =&gt;</span> sum + c) / iterations.length;<span class="hljs-keyword">const</span> stddev = <span class="hljs-built_in">Math</span>.sqrt(  iterations    .map(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> <span class="hljs-built_in">Math</span>.pow(i - average, <span class="hljs-number">2</span>))    .reduce(<span class="hljs-function">(<span class="hljs-params">sum, c</span>) =&gt;</span> sum + c) / iterations.length);print(<span class="hljs-string">`n = <span class="hljs-subst">$&#123;iterations.length&#125;</span>`</span>);print(<span class="hljs-string">`Average: <span class="hljs-subst">$&#123;average&#125;</span>`</span>);print(<span class="hljs-string">`StdDev: <span class="hljs-subst">$&#123;stddev&#125;</span>`</span>);</code></pre><p>使用 d8 运行脚本：</p><pre><code class="hljs bash">d8 benchmark.js</code></pre><p>结果打印出平均时间和方差：</p><pre><code class="hljs undefined">==============================n = 10<span class="hljs-section">Average: 45.8</span><span class="hljs-section">StdDev: 19.75246820020222</span></code></pre><h2 id="参考">参考</h2><p>Squoosh 项目的 <a href="https://github.com/GoogleChromeLabs/squoosh/blob/master/codecs/rotate/rotate.rs" target="_blank" rel="noopener">codecs/rotate</a> 模块。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;d8 是 v8 的简易 CLI，它提供了一个极简的 JS 宿主环境，可用于 v8 的学习和调试，比起 nodejs，它更精简和专注。&lt;/p&gt;
&lt;p&gt;除了 JS 以外，d8 也具有 WASM 的解释功能，可以方便地用于测试 WASM 模块的性能。如果你的 WASM 是要在浏览
      
    
    </summary>
    
    
      <category term="前端" scheme="http://hikerpig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="WebAssembly" scheme="http://hikerpig.github.io/tags/WebAssembly/"/>
    
      <category term="Benchmark" scheme="http://hikerpig.github.io/tags/Benchmark/"/>
    
      <category term="V8" scheme="http://hikerpig.github.io/tags/V8/"/>
    
  </entry>
  
  <entry>
    <title>Handy Video Analyze Tool</title>
    <link href="http://hikerpig.github.io/2019/03/14/2019-03-13-Handy-Video-Analyze-Tool/"/>
    <id>http://hikerpig.github.io/2019/03/14/2019-03-13-Handy-Video-Analyze-Tool/</id>
    <published>2019-03-13T16:00:00.000Z</published>
    <updated>2019-05-25T05:34:27.181Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写一些跟视频解码相关的简单程序，学习 avcodec 技术时有一些强大的分析工具，分享一下。</p><h1 id="码流与封装容器相关">码流与封装容器相关</h1><h2 id="iso-viewer">ISO Viewer</h2><p><a href="https://github.com/sannies/isoviewer" target="_blank" rel="noopener">isoviewer</a> 是 Mac 下一个检查 mp4 文件构成的 GUI 程序，能直观地看到各个 box 的数据。</p><img src="//images-hikerpig.oss-cn-beijing.aliyuncs.com/image/iso-viewer.png" alt="undefined" title="undefined"><h2 id="bento4">bento4</h2><p><a href="https://www.bento4.com/" target="_blank" rel="noopener">bento4</a> 是一套专用于 mp4 格式文件分析和编辑的 SDK，支持的功能非常多。</p><table><colgroup><col style="width: 11%"><col style="width: 88%"></colgroup><thead><tr class="header"><th>工具</th><th>用途</th></tr></thead><tbody><tr class="odd"><td>mp4info</td><td>displays high level info about an MP4 file, including all tracks and codec details</td></tr><tr class="even"><td>mp4dump</td><td>displays the entire atom/box structure of an MP4 file</td></tr><tr class="odd"><td>mp4edit</td><td>add/insert/remove/replace atom/box items of an MP4 file</td></tr><tr class="even"><td>mp4extract</td><td>extracts an atom/box from an MP4 file</td></tr><tr class="odd"><td>mp4encrypt</td><td>encrypts an MP4 file (multiple encryption schemes are supported)</td></tr><tr class="even"><td>mp4decrypt</td><td>decrypts an MP4 file (multiple encryption schemes are supported)</td></tr><tr class="odd"><td>mp4dcfpackager</td><td>encrypts a media file into an OMA DCF file</td></tr><tr class="even"><td>mp4compact</td><td>converts 'stsz' tables into 'stz2' tables to create more compact MP4 files</td></tr><tr class="odd"><td>mp4fragment</td><td>creates a fragmented MP4 file from a non-fragmented one.</td></tr><tr class="even"><td>mp4split</td><td>splits a fragmented MP4 file into discrete files</td></tr><tr class="odd"><td>mp4tag</td><td>show/edit MP4 metadata (iTunes-style and others)</td></tr><tr class="even"><td>mp4mux</td><td>multiplexes one or more elementary streams (H264/AVC, H265/HEVC, AAC) into an MP4 file</td></tr><tr class="odd"><td>mp42aac</td><td>extract a raw AAC elementary stream from an MP4 file</td></tr><tr class="even"><td>mp42avc</td><td>extract a raw AVC/H.264 elementary stream from an MP4 file</td></tr><tr class="odd"><td>mp42hls</td><td>converts an MP4 file to an HLS (HTTP Live Streaming) presentation, including the generation of the segments and .m3u8 playlist as well as AES-128 and SAMPLE-AES (for Fairplay) encryption. This can be used as a replacement for Apple's mediafilesegmenter tool.</td></tr><tr class="even"><td>mp42ts</td><td>converts an MP4 file to an MPEG2-TS file.</td></tr><tr class="odd"><td>mp4dash</td><td>creates an MPEG DASH output from one or more MP4 files, including encryption. This is a full-featured MPEG DASH packager.</td></tr><tr class="even"><td>mp4dashclone</td><td>creates a local clone of a remote or local MPEG DASH presentation, optionally encrypting the segments as they are cloned.</td></tr><tr class="odd"><td>mp4hls</td><td>creates a multi-bitrate HLS master playlist from one or more MP4 files, including support for encryption and I-frame-only playlists. This tool uses the 'mp42hls' low level tool internally, so all the options supported by that low level tool are also available. This can be used as a replacement for Apple's variantplaylistcreator tool.</td></tr></tbody></table><h2 id="gpac">GPAC</h2><p><a href="https://gpac.wp.imt.fr/" target="_blank" rel="noopener">GPAC</a> 是一个为科研和学术领域开发的多媒体的框架，包括几个视频分析和码流编辑的 CLI 工具。官网主要 feature 如下:</p><blockquote><p>GPAC features encoders and multiplexers, publishing and content distribution tools for MP4 and 3GPP or 3GPP2 files and many tools for scene descriptions (BIFS/VRML/X3D converters, SWF/BIFS, SVG/BIFS, etc…). MP4Box provides all these tools in a single command-line application. An exhaustive list of packaging features is available here but a good summary of what MP4Box can do for you is the following:</p><ul><li>MP4/3GP Conversion from MP3, AVI, MEPG-2 TS, MPEG-PS, AAC, H263, H264, AMR, and many others,</li><li>3GPP DIMS Packaging from SVG files,</li><li>File layout: fragmentation or interleaving, and cleaning,</li><li>File hinting for RTP/RTSP and QTSS/DSS servers (MPEG-4 / ISMA / 3GP / 3GP2 files),</li><li>File splitting by size or time, extraction from file and file concatenation,</li><li>XML information dumping for MP4 and RTP hint tracks,</li><li>Media Track extractions,</li><li>ISMA E&amp;A encryption and decryption,</li><li>3GPP timed text tools (SUB/SRT/TTXT/TeXML), VobSub import/export,</li><li>BIFS codec and scene conversion between MP4, BT and XMT-A,</li><li>LASeR codec and scene conversion between MP4, SAF, SVG and XSR (XML LASeR),</li><li>XML scene statistics for BIFS scene (BT, XMT-A and MP4),</li><li>Conversion to and from BT, XMT-A, WRL, X3D and X3DV with support for gzip.</li><li>Preparing MP4,3GP and MPEG-2 TS files for DASH streaming</li></ul></blockquote><p>主要使用的可能是 <code>MP4Box</code> 工具，功能很多，几个例子:</p><pre><code class="hljs bash">MP4Box -add file.av1 file_av1.mp4 <span class="hljs-comment"># 将 av1 码流封装写入 mp4 文件</span></code></pre><h2 id="ffprobe">ffprobe</h2><p>大名鼎鼎的 ffmpeg 项目一员，一身<a href="https://ffmpeg.org/ffprobe.html" target="_blank" rel="noopener">技能和 API 参数</a>。</p><p>其中一个用法是 dump 出所有的 frame:</p><pre><code class="hljs undefined"><span class="hljs-selector-tag">ffprobe</span> <span class="hljs-selector-tag">-show_frames</span> <span class="hljs-selector-tag">some</span><span class="hljs-selector-class">.mp4</span> &gt; <span class="hljs-selector-tag">probe-mp4</span><span class="hljs-selector-class">.txt</span></code></pre><pre><code class="hljs undefined"><span class="hljs-section">[FRAME]</span><span class="hljs-attr">media_type</span>=video<span class="hljs-attr">stream_index</span>=<span class="hljs-number">0</span><span class="hljs-attr">key_frame</span>=<span class="hljs-number">1</span><span class="hljs-attr">pkt_pts</span>=<span class="hljs-number">0</span><span class="hljs-attr">pkt_pts_time</span>=<span class="hljs-number">0.000000</span><span class="hljs-attr">pkt_dts</span>=<span class="hljs-number">0</span><span class="hljs-attr">pkt_dts_time</span>=<span class="hljs-number">0.000000</span><span class="hljs-attr">best_effort_timestamp</span>=<span class="hljs-number">0</span><span class="hljs-attr">best_effort_timestamp_time</span>=<span class="hljs-number">0.000000</span><span class="hljs-attr">pkt_duration</span>=<span class="hljs-number">512</span><span class="hljs-attr">pkt_duration_time</span>=<span class="hljs-number">0.040000</span><span class="hljs-attr">pkt_pos</span>=<span class="hljs-number">48</span><span class="hljs-attr">pkt_size</span>=<span class="hljs-number">27979</span><span class="hljs-attr">width</span>=<span class="hljs-number">320</span><span class="hljs-attr">height</span>=<span class="hljs-number">564</span><span class="hljs-attr">pix_fmt</span>=yuv420p<span class="hljs-attr">sample_aspect_ratio</span>=N/A<span class="hljs-attr">pict_type</span>=I<span class="hljs-attr">coded_picture_number</span>=<span class="hljs-number">0</span><span class="hljs-attr">display_picture_number</span>=<span class="hljs-number">0</span><span class="hljs-attr">interlaced_frame</span>=<span class="hljs-number">0</span><span class="hljs-attr">top_field_first</span>=<span class="hljs-number">0</span><span class="hljs-attr">repeat_pict</span>=<span class="hljs-number">0</span><span class="hljs-attr">color_range</span>=unknown<span class="hljs-attr">color_space</span>=unknown<span class="hljs-attr">color_primaries</span>=unknown<span class="hljs-attr">color_transfer</span>=unknown<span class="hljs-attr">chroma_location</span>=left<span class="hljs-section">[/FRAME]</span><span class="hljs-section">[FRAME]</span><span class="hljs-attr">media_type</span>=audio<span class="hljs-attr">stream_index</span>=<span class="hljs-number">1</span><span class="hljs-attr">key_frame</span>=<span class="hljs-number">1</span><span class="hljs-attr">pkt_pts</span>=<span class="hljs-number">0</span><span class="hljs-attr">pkt_pts_time</span>=<span class="hljs-number">0.000000</span><span class="hljs-attr">pkt_dts</span>=<span class="hljs-number">0</span><span class="hljs-attr">pkt_dts_time</span>=<span class="hljs-number">0.000000</span><span class="hljs-attr">best_effort_timestamp</span>=<span class="hljs-number">0</span><span class="hljs-attr">best_effort_timestamp_time</span>=<span class="hljs-number">0.000000</span><span class="hljs-attr">pkt_duration</span>=<span class="hljs-number">1024</span><span class="hljs-attr">pkt_duration_time</span>=<span class="hljs-number">0.021333</span><span class="hljs-attr">pkt_pos</span>=<span class="hljs-number">28243</span><span class="hljs-attr">pkt_size</span>=<span class="hljs-number">6</span><span class="hljs-attr">sample_fmt</span>=fltp<span class="hljs-attr">nb_samples</span>=<span class="hljs-number">1024</span><span class="hljs-attr">channels</span>=<span class="hljs-number">2</span><span class="hljs-attr">channel_layout</span>=stereo<span class="hljs-section">[/FRAME]</span></code></pre><h1 id="二进制显示编辑">二进制显示/编辑</h1><h2 id="hex-fiend">Hex Fiend</h2><p><a href="https://github.com/ridiculousfish/HexFiend" target="_blank" rel="noopener">Hex Fiend</a>, Mac 下的 hex 编辑 GUI 工具，支持按文本或hex搜索/编辑/diff，功能强大。</p><figure><img src="https://raw.githubusercontent.com/ridiculousfish/HexFiend/master/docs/screenshot.png" alt><figcaption>HexFiend</figcaption></figure><h2 id="hexyl">hexyl</h2><p><a href="https://github.com/sharkdp/hexyl" target="_blank" rel="noopener">hexyl</a> ，一个轻量 CLI 查看二进制数据的工具，用 rust 编写。优点是快速，好看。</p><figure><img src="https://camo.githubusercontent.com/1f71ee7031e1962b23f21c8cc89cb837e1201238/68747470733a2f2f692e696d6775722e636f6d2f4d574f3975534c2e706e67" alt><figcaption>hexyl 效果图</figcaption></figure>]]></content>
    
    <summary type="html">
    
      分享一些学习 avcodec 技术时好用的分析工具
    
    </summary>
    
    
      <category term="工具" scheme="http://hikerpig.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="video" scheme="http://hikerpig.github.io/tags/video/"/>
    
  </entry>
  
  <entry>
    <title>Decode Video Using ffmpeg In Browser</title>
    <link href="http://hikerpig.github.io/2019/03/06/2019-03-06-Decode-Video-Using-FFMpeg-In-Browser/"/>
    <id>http://hikerpig.github.io/2019/03/06/2019-03-06-Decode-Video-Using-FFMpeg-In-Browser/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2020-02-15T04:22:23.566Z</updated>
    
    <content type="html"><![CDATA[<p>音视频开发入门，可能绕不开 ffmpeg 这个项目，最近看了篇 <a href="https://zhuanlan.zhihu.com/p/40786748" target="_blank" rel="noopener">知乎专栏</a>，觉得这个事情很有意思。</p><p>比起直接编辑整个 ffmpeg 项目的 CLI 到前端，更符合实际需求的方式，是先基于 ffmpeg 各种 lib 二次开发出合适的功能，此时结果是可执行的二进制文件，可以用 lldb 或者 gdb 调试。然后再使用 Emscripten 编译到 Webassembly，如此一来可以解决 wasm 不易调试的问题。</p><p>跟着教程实现一个功能：解析出视频任意一帧的图像并绘制到 canvas 上。</p><h2 id="web-demo-应用流程">Web demo 应用流程</h2><p>demo 页的简单流程</p><pre><code class="hljs mermaid">graph TD    P1[获取视频 buffer 并写入wasm将要使用的线性内存空间] -- 进入wasm调用 --&gt; Asubgraph C 程序转成的 wasm    A[avcodec 解析视频文件 buffer] --&gt; B[解出指定时间的图像并转成 RGB 格式数据]    B --&gt; C[将图像等数据写入内存, 并将指针返给 js 端]end    C  -- 回到 js --&gt;  D[根据指针读出数据, 构建 ImageData, 绘制到 canvas 上]</code></pre><h2 id="从源码编译-ffmpeg">从源码编译 ffmpeg</h2><p>本文写就的时候使用的是 ffmpeg <code>n4.2-dev</code> 版，将其源码置于项目相对目录 <code>lib/ffmpeg</code> 下。</p><p>ffmpeg 是一个很大的项目，包含的很多功能对于我们的需求来说，都用不上，可以通过 <a href="https://github.com/FFmpeg/FFmpeg/blob/master/configure" target="_blank" rel="noopener">configure</a> 配置留下合适的功能集。这个其实就是一个可执行的 sh 脚本，比较复杂的项目，通常在实际编译之前，可以使用 configure 根据参数和环境生成实际编译过程需要的 Makefile。</p><h3 id="项目-makefile">项目 Makefile</h3><p>参考 <a href="https://github.com/Kagami/ffmpeg.js/" target="_blank" rel="noopener">ffmpeg.js</a> 项目的一些配置</p><pre><code class="hljs makefile">COMMON_FILTERS = scale crop overlayCOMMON_DEMUXERS = matroska ogg avi mov flv mpegps image2 mp3 concatCOMMON_DECODERS = \mpeg2video mpeg4 h264 hevc \png mjpeg \mp3 ac3 aacMUXERS = mp4 null image2ENCODERS = mjpegFFMPEG_CONFIGURE_ARGS = \--cc=emcc \--ar=emar \--enable-cross-compile \--target-os=none \--cpu=generic \--arch=x86 \--disable-runtime-cpudetect \--disable-asm \--disable-fast-unaligned \--disable-pthreads \--disable-w32threads \--disable-os2threads \--disable-debug \--disable-stripping \\--disable-all \--enable-avcodec \--enable-avformat \--enable-avutil \--enable-swscale \--enable-shared \--enable-protocol=file \<span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> --enable-decoder=,<span class="hljs-variable">$(COMMON_DECODERS)</span>)</span> \<span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> --enable-demuxer=,<span class="hljs-variable">$(COMMON_DEMUXERS)</span>)</span> \<span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> --enable-encoder=,<span class="hljs-variable">$(ENCODERS)</span>)</span> \<span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> --enable-muxer=,<span class="hljs-variable">$(MUXERS)</span>)</span> \<span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> --enable-<span class="hljs-built_in">filter</span>=,<span class="hljs-variable">$(COMMON_FILTERS)</span>)</span> <span class="hljs-comment"># to run ffmpeg configure and emmake</span><span class="hljs-section">lib/ffmpeg/libavcodec/libavcodec.a:</span>cd lib/ffmpeg &amp;&amp; \patch -p1 &lt; ../swscale.c.patch &amp;&amp; \emconfigure ./configure \<span class="hljs-variable">$(FFMPEG_CONFIGURE_ARGS)</span> \&amp;&amp; \emmake make</code></pre><p>说下 <code>lib/ffmpeg/libavcodec/libavcodec.a</code> 这个目标，分成几步:</p><ul><li><code>emconfigure</code> 是 emsdk 提供的工具，执行完这一步之后，会生成 <code>lib/ffmpeg/Makefile</code></li><li><code>emmake make</code> 便是开始编译了，由于我们在前一步 configure 的时候有 <code>--enable-avcodec</code>，所以用这个 Makefile 编译，会生成 <code>lib/ffmpeg/libavcodec/libavcodec.a</code> 这个静态库文件</li><li>编译原本的 ffmpeg 代码会报错，定位到 <code>libswscale/swscale.c</code> 文件里，为了编译通过，在编译前加了个不影响主要功能的简单的 patch</li></ul><p>运行 <code>make lib/ffmpeg/libavcodec/libavcodec.a</code>，等待大约一两分钟，emscripten 编译 ffmpeg 静态库完成，闪过了一堆 warning 可以优雅地无视掉。接下来就是编写我们的应用接口代码并编译到 WebAssembly 了。</p><h2 id="编译和使用">编译和使用</h2><h3 id="生成-js-和-wasm-文件">生成 JS 和 WASM 文件</h3><pre><code class="hljs makefile"><span class="hljs-section">dist/vidy-standalone.js:</span>    emcc transcoder/web.c transcoder/process.c \                lib/ffmpeg/libavformat/libavformat.a \                lib/ffmpeg/libavcodec/libavcodec.a \                lib/ffmpeg/libswscale/libswscale.a \                lib/ffmpeg/libavutil/libavutil.a \                -s TOTAL_MEMORY=33554432 \                -s MODULARIZE=1 \                -O1 -s WASM=1 -s EXTRA_EXPORTED_RUNTIME_METHODS='[<span class="hljs-string">"ccall"</span>, <span class="hljs-string">"cwrap"</span>]' -s ALLOW_MEMORY_GROWTH=1  \                -Ilib/ffmpeg \                --post-js transcoder/js/post.js \                -o dist/vidy-standalone.js</code></pre><p>使用 <code>emcc</code> 编译：</p><ul><li>存放暴露给浏览器的相关接口的 <code>web.c</code></li><li>存放通用的 ffmpeg 方法调用的 <code>process.c</code></li><li>以及之前生成个几个静态库文件 <code>.a</code></li></ul><p>其中一些参数说明一下： - <code>-s MODULARIZE=1</code> 让 emcc 生成模块工厂函数（而且还是 UMD 格式的），留待之后调用。否则默认情况下生成的 JS 会立刻执行，而且还会污染其所在全局环境（例如添加一个 self.Module 对象）</p><p>一起生成目标文件 <code>dist/vidy-standalone.js</code>，由于传递了 <code>-s WASM=1</code>，还会生成同名的 <code>dist/vidy-standalone.wasm</code> 文件。JS 是一个一千来行的胶水代码，负责 WASM 模块的初始化和调用适配。WASM 文件大概 4.7M。</p><p>查看 <a href="%5Bhttps://emscripten.org/docs/tools_reference/emcc.html">emcc 文档</a> 和 <a href="https://github.com/emscripten-core/emscripten/blob/master/src/settings.js" target="_blank" rel="noopener">关于 <code>-s</code> 的全部可选 setting</a>。</p><h3 id="使用方法">使用方法</h3><h4 id="简单的例子">简单的例子</h4><pre><code class="hljs js"><span class="hljs-keyword">import</span> Module <span class="hljs-keyword">from</span> <span class="hljs-string">'../dist/vidy-standalone'</span><span class="hljs-keyword">let</span> vidyModulefetch(<span class="hljs-string">'//path/to/dist/vidy-standalone.wasm'</span>)    .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.arrayBuffer())    .then(<span class="hljs-function">(<span class="hljs-params">arrayBuffer</span>) =&gt;</span> &#123;        vidyModule = Module(&#123;            <span class="hljs-attr">wasmBinary</span>: arrayBuffer        &#125;)        decodeVideoFrameImage(<span class="hljs-string">'some.mp4'</span>, <span class="hljs-number">1.2</span>)    &#125;)<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">decodeVideoFrameImage</span>(<span class="hljs-params">videoPath, timeStamp</span>) </span>&#123;    fetch(videoPath).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.arrayBuffer())        .then(<span class="hljs-function">(<span class="hljs-params">videoBuffer</span>) =&gt;</span> &#123;            <span class="hljs-keyword">const</span> imageResult = vidyModule.getImage(<span class="hljs-keyword">this</span>.result, <span class="hljs-built_in">parseFloat</span>(timeStamp))            <span class="hljs-comment">// ...</span>        &#125;)&#125;</code></pre><h4 id="稍微复杂点的例子">稍微复杂点的例子</h4><p>为了将模块更好地整合到前端工程中，有必要考虑在使用 webpack 的情况下如何引入。</p><p>参考 <a href="https://github.com/GoogleChromeLabs/squoosh/" target="_blank" rel="noopener">GoogleChromeLabs/squoosh</a> 项目中的一些经验，首先看下 webpack 配置。webpack 团队在 v4 以后做了很多努力，想要让 WASM 模块的引入和使用与 js 文件一样方便，但实际实用中有很多边边角角 <a href="https://github.com/webpack/webpack/issues/6725" target="_blank" rel="noopener">奇怪的问题和报错</a>，而且处理一个好几兆的 wasm 文件拖慢 webpack 冷启动许多，我们可以用一下配置让 webpack 不去读取 WASM 文件。使用 file-loader 也可以简单地配置带哈希的文件名，比起在项目中硬编码 WASM 文件路径，少去一些缓存问题。</p><pre><code class="hljs js"><span class="hljs-comment">// webpack config</span>    rules: [    ...      &#123;        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.wasm$/</span>,        <span class="hljs-comment">// This is needed to make webpack NOT process wasm files.</span>        type: <span class="hljs-string">'javascript/auto'</span>,        <span class="hljs-attr">loader</span>: <span class="hljs-string">'file-loader'</span>,        <span class="hljs-attr">options</span>: &#123;          <span class="hljs-attr">name</span>: <span class="hljs-string">'[name].[hash:5].[ext]'</span>,        &#125;,      &#125;,    ...    ]</code></pre><p>跟上面简单例子里效果相似的写法可以变成这样:</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> Module <span class="hljs-keyword">from</span> <span class="hljs-string">'../dist/vidy-standalone'</span><span class="hljs-keyword">import</span> vidyWasmUrl <span class="hljs-keyword">from</span> <span class="hljs-string">'../dist/vidy-standalone.wasm'</span> <span class="hljs-comment">// 会被 file-loader 处理成一个静态文件的 url</span><span class="hljs-keyword">const</span> vidyModule = Module(&#123;    locateFile(url) &#123;        <span class="hljs-comment">// Redirect the request for the wasm binary to whatever webpack gave us.</span>        <span class="hljs-keyword">if</span> (url.endsWith(<span class="hljs-string">'.wasm'</span>)) <span class="hljs-keyword">return</span> vidyWasmUrl;        <span class="hljs-keyword">return</span> url;    &#125;,&#125;)</code></pre><p>emcc 生成的胶水代码里，默认请求的 WASM 文件路径是 <code>vidy-standalone.wasm</code>，但看看 <a href="https://github.com/emscripten-core/emscripten/blob/master/emcc.py#L2800" target="_blank" rel="noopener">emcc 这一部分实现</a> 知道，如果给模块工厂函数 Module 传递了 <code>locateFile</code> 函数，就可以改写其内部会去请求的 WASM 文件路径。使用模块工厂函数的话，也不用自己去调用 <code>fetch</code> 了。</p><h2 id="一些具体实现的代码">一些具体实现的代码</h2><p>首先看看 <code>web.c</code> 里暴露出的方法签名：</p><pre><code class="hljs c"><span class="hljs-function">EMSCRIPTEN_KEEPALIVE MyImageData *<span class="hljs-title">seek_video_to</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *buff, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> buff_length, <span class="hljs-keyword">float</span> time_stamp)</span></span></code></pre><p>buffer 数组头指针 <code>buff</code>，buffer 长度 <code>buff_length</code>，以及用单精度浮点数表示的需要提取图像的时间。返回数据为我们自定义的结构。</p><h3 id="js-将视频数据写入-wasm-线性内存">[JS] 将视频数据写入 WASM 线性内存</h3><p>在 <code>post.js</code> 里，添加的一部分代码。</p><ul><li>根据 C 的方法签名，使用 emscripten 的胶水代码工具函数 <code>Module.cwrap</code> 包装一个 JS 的调用方法</li><li>给 emscripten 模块加上了 <code>Module.getImage</code> 方法，供外部调用</li></ul><pre><code class="hljs js"><span class="hljs-keyword">let</span> seek_video_to = <span class="hljs-literal">null</span>Module.onRuntimeInitialized = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  seek_video_to = Module.cwrap(<span class="hljs-string">'seek_video_to'</span>, <span class="hljs-string">'number'</span>, [<span class="hljs-string">'number'</span>, <span class="hljs-string">'number'</span>, <span class="hljs-string">'number'</span>]);&#125;;Module.getImage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">buffer, timeStamp</span>) </span>&#123;  <span class="hljs-keyword">if</span> (!seek_video_to) &#123;    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">errcode</span>: <span class="hljs-number">1</span> &#125;  &#125;  <span class="hljs-keyword">let</span> ptr = <span class="hljs-number">0</span>;  <span class="hljs-keyword">let</span> offset = <span class="hljs-number">0</span>;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">const</span> before = <span class="hljs-built_in">Date</span>.now()    <span class="hljs-keyword">let</span> data_arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(buffer);    offset = Module._malloc(data_arr.length);    Module.HEAP8.set(data_arr, offset);    ptr = seek_video_to(offset, data_arr.length, timeStamp);    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'seek_video_to costs'</span>, <span class="hljs-built_in">Date</span>.now() - before)  &#125; <span class="hljs-keyword">catch</span> (e) &#123;    <span class="hljs-keyword">throw</span> e;  &#125;  ...</code></pre><h3 id="c-程序头部">[C] 程序头部</h3><p>首先声明一些方便数据读取的全局变量:</p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span>    <span class="hljs-keyword">uint8_t</span> *ptr;    <span class="hljs-keyword">size_t</span> size;&#125; BufferData;<span class="hljs-comment">/** * some global variables */</span>BufferData global_buffer_data;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-keyword">uint32_t</span> width;    <span class="hljs-keyword">uint32_t</span> height;    <span class="hljs-keyword">uint8_t</span> *data;&#125; MyImageData;</code></pre><p>全局变量 <code>global_buffer_data</code> 留作存放原始视频数据的结构，它所在的内存区域会被 JS 直接写入。</p><h3 id="c-avcodec-解析视频文件">[C] avcodec 解析视频文件</h3><p>我们需要让 ffmpeg 能够从内存（而不是文件）中读取视频数据。</p><pre><code class="hljs c">...  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *avio_ctx_buffer = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 对于普通的mp4文件，这个size只要1MB就够了，但是对于mov/m4v需要和buff一样大</span>  <span class="hljs-keyword">size_t</span> avio_ctx_buffer_size = buff_length;  global_buffer_data.ptr = buff;         <span class="hljs-comment">/* will be grown as needed by the realloc above */</span>  global_buffer_data.size = buff_length; <span class="hljs-comment">/* no data at this point */</span>  AVFormatContext *pFormatCtx = avformat_alloc_context();  <span class="hljs-keyword">uint8_t</span> *avio_ctx_buffer = (<span class="hljs-keyword">uint8_t</span> *)av_malloc(avio_ctx_buffer_size);  <span class="hljs-comment">/* 读内存数据 */</span>  AVIOContext *avio_ctx = avio_alloc_context(avio_ctx_buffer, avio_ctx_buffer_size, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, read_packet, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);  pFormatCtx-&gt;pb = avio_ctx;  pFormatCtx-&gt;flags = AVFMT_FLAG_CUSTOM_IO;...</code></pre><p>新建 <code>AVIOContext *avio_ctx</code>，指定目标 buffer 指针，目标 buffer 大小，以及我们提供的读取数据的 <code>read_packet</code> 函数，该 iocontext 需要读下一段数据时， <code>read_packet</code> 函数就将 <code>global_buffer_data</code> 中指定大小的数据写入目标 <code>*buf</code> 位置</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read_packet</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *opaque, <span class="hljs-keyword">uint8_t</span> *buf, <span class="hljs-keyword">int</span> buf_size)</span></span>&#123;    buf_size = FFMIN(buf_size, global_buffer_data.size);    <span class="hljs-comment">/* copy internal buffer data to buf */</span>    <span class="hljs-built_in">memcpy</span>(buf, global_buffer_data.ptr, buf_size);    global_buffer_data.ptr += buf_size;    global_buffer_data.size -= buf_size;    <span class="hljs-keyword">return</span> buf_size;&#125;</code></pre><h3 id="c-获取图片-rgb-数据">[C] 获取图片 rgb 数据</h3><p>这里内容太多，主要涉及 FFMpeg 的接口和视频编解码的知识，准备另写一篇。</p><h3 id="c-将图像等数据写入内存">[C] 将图像等数据写入内存</h3><p>当拿到包含 RGB 格式图像数据的 <code>AVFrame *pFrameRGB</code> 后，是时候将其中的颜色信息取出，转化为线性存储的，利于 JS 中 Canvas 元素使用的数据格式。</p><pre><code class="hljs c"><span class="hljs-keyword">uint8_t</span> *get_image_frame_buffer(AVFrame *pFrame, AVCodecContext *pCodecCtx)&#123;    <span class="hljs-keyword">int</span> width = pCodecCtx-&gt;width;    <span class="hljs-keyword">int</span> height = pCodecCtx-&gt;height;    <span class="hljs-keyword">int</span> buffer_size = height * width * <span class="hljs-number">3</span>;    <span class="hljs-keyword">uint8_t</span> *buffer = (<span class="hljs-keyword">uint8_t</span> *)<span class="hljs-built_in">malloc</span>(buffer_size);    <span class="hljs-comment">// Write pixel data</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; height; y++)    &#123;        <span class="hljs-built_in">memcpy</span>(buffer + y * pFrame-&gt;linesize[<span class="hljs-number">0</span>], pFrame-&gt;data[<span class="hljs-number">0</span>] + y * pFrame-&gt;linesize[<span class="hljs-number">0</span>], width * <span class="hljs-number">3</span>);    &#125;    <span class="hljs-keyword">return</span> buffer;&#125;</code></pre><p>此函数返回的 <code>buffer</code> 指针指向的内存区域，会按照 <code>rgbrgb...</code> 的顺序存储图像颜色数据。每个像素需要 3 个存储单元，所以整个的 <code>buffer_size</code> 会是 <code>height * width * 3</code>。</p><p>接下来我们回到 JS 端。</p><h3 id="js-根据指针读出数据构建-imagedata">[JS] 根据指针读出数据，构建 ImageData</h3><p>WASM 返回的只是一个内存偏移量，此时我们手上有整个 WASM 实例的内存区域，得想办法把有用的数据读取出来。</p><p>首先我们知道 <code>MyImageData</code> 结构体宽和高都是用 <code>uint32_t</code>，紧接着存放颜色信息的数组单元类型为 <code>uint8_t</code>。</p><p>Emscripten 的胶水代码有提供 HEAPU (8/16/32/64) 几种步长的 dataviewer，可以按照以下方法读出数字和颜色数组。</p><pre><code class="hljs ts"><span class="hljs-comment">// ...</span>  <span class="hljs-keyword">let</span> heap32Start = ptr / <span class="hljs-number">4</span>  <span class="hljs-keyword">let</span> width = Module.HEAPU32[heap32Start]  <span class="hljs-keyword">let</span> height = Module.HEAPU32[heap32Start + <span class="hljs-number">1</span>],    imgBufferPtr = Module.HEAPU32[heap32Start + <span class="hljs-number">2</span>],    imageBuffer = Module.HEAP.subarray(imgBufferPtr, imgBufferPtr + width * height * <span class="hljs-number">3</span>)  <span class="hljs-keyword">let</span> imageInfo = &#123; width, height, imageDataArr: imageBuffer &#125;  <span class="hljs-keyword">let</span> imageData = imageInfoToImageData(imageInfo)<span class="hljs-comment">// ...</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">imageInfoToImageData</span>(<span class="hljs-params">imageInfo: VidyImageInfo</span>) </span>&#123;  <span class="hljs-keyword">const</span> &#123; width, height, imageDataArr &#125; = imageInfo  <span class="hljs-keyword">const</span> imageData = <span class="hljs-keyword">new</span> ImageData(width, height)  <span class="hljs-comment">// 目前只返回 RGB24 格式的数据, 不处理透明度</span>  <span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; imageDataArr.length; i++) &#123;    <span class="hljs-keyword">if</span> (i &amp;&amp; i % <span class="hljs-number">3</span> === <span class="hljs-number">0</span>) &#123;      imageData.data[k++] = <span class="hljs-number">255</span>    &#125;    imageData.data[k++] = imageDataArr[i]  &#125;  imageData.data[k] = <span class="hljs-number">255</span>  <span class="hljs-keyword">return</span> imageData&#125;</code></pre><p>绘制到 canvas 上就很简单了</p><pre><code class="hljs ts">canvas.width = widthcanvas.height = height<span class="hljs-keyword">let</span> ctx = canvas.getContext(<span class="hljs-string">'2d'</span>)ctx.drawImage(imageData, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</code></pre><h2 id="总结">总结</h2><p>跟着别人的文章思路，小小修改，跑通了一个 demo，大致熟悉一下 C 项目使用 Emscripten 转化为前端可用模块的方案。</p><p>不是很熟悉 C 语言，同时在 JS 和 C 端手动管理内存虽然对于入门者来说很容易操作，但稍显繁琐。</p><p>Emscripten 多用于翻译现有的 C/C++ 库代码，对于 Web API 和前端生态的支持，明显没有隔壁 Mozilla 的 Rust 社区积极。不过音视频技术实现，的确是 C 的传统强项领域，若想少造轮子，还是要好好学习的。</p><h2 id="参考">参考</h2><p>https://zhuanlan.zhihu.com/p/40786748</p>]]></content>
    
    <summary type="html">
    
      借助 Emscripten，基于 ffmpeg 二次开发前端音视频功能
    
    </summary>
    
    
      <category term="前端" scheme="http://hikerpig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Avtech" scheme="http://hikerpig.github.io/tags/Avtech/"/>
    
      <category term="Webassembly" scheme="http://hikerpig.github.io/tags/Webassembly/"/>
    
      <category term="Emscripten" scheme="http://hikerpig.github.io/tags/Emscripten/"/>
    
      <category term="ffmpeg" scheme="http://hikerpig.github.io/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>Tips On Viewing Logs</title>
    <link href="http://hikerpig.github.io/2019/02/15/2019-03-08-Tips-On-Viewing-Logs/"/>
    <id>http://hikerpig.github.io/2019/02/15/2019-03-08-Tips-On-Viewing-Logs/</id>
    <published>2019-02-14T16:00:00.000Z</published>
    <updated>2019-08-20T10:19:05.390Z</updated>
    
    <content type="html"><![CDATA[<p>面对浩如烟海的 log，在排查错误和查找信息时使用一些趁手的工具，快速定位，关爱视力，有益身心健康。</p><h1 id="高级的工具">高级的工具</h1><h2 id="lnav">lnav</h2><p><a href="http://lnav.org/" target="_blank" rel="noopener">lnav</a> 是一个非常强大的日志查看器，有多种视图和过滤功能，不过最喜欢的其实还是自动的颜色高亮。</p><figure><img src="https://static1.squarespace.com/static/51bd4e13e4b0052d7873ad34/t/551aa43fe4b065952ea849ad/1427809346467/?format=1500w" alt><figcaption>lnav 官网给出的效果图</figcaption></figure><h1 id="系统自带工具">系统自带工具</h1><p>不用安装额外的程序，linux 多数发行版都有的基础工具。</p><h2 id="less">less</h2><h3 id="高亮搜索命中内容">高亮搜索命中内容</h3><p><a href="https://unix.stackexchange.com/questions/179173/make-less-highlight-search-patterns-instead-of-italicizing-them" target="_blank" rel="noopener">Make Less highlight search patterns instead of italicizing them</a></p><pre><code class="hljs undefined"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">LESS_TERMCAP_se</span>=$'\E[39;49m'</code></pre>]]></content>
    
    <summary type="html">
    
      一些看 LOG 时方便的工具和技巧
    
    </summary>
    
    
      <category term="Tips" scheme="http://hikerpig.github.io/categories/Tips/"/>
    
    
      <category term="tip" scheme="http://hikerpig.github.io/tags/tip/"/>
    
      <category term="工具" scheme="http://hikerpig.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>在 docker 环境中从 gitlab 拉取源码</title>
    <link href="http://hikerpig.github.io/2019/02/15/2019-02-14-Setup-CI-in-docker/"/>
    <id>http://hikerpig.github.io/2019/02/15/2019-02-14-Setup-CI-in-docker/</id>
    <published>2019-02-14T16:00:00.000Z</published>
    <updated>2020-03-03T10:53:43.809Z</updated>
    
    <content type="html"><![CDATA[<p>前注：在 docker 镜像中拉取 git 仓库似乎是一种 anti-pattern，本文只是记录中间的踩坑经历。</p><p>托管在公司 gitlab 上的一个前端项目，最近在尝试 docker 化。</p><h1 id="准备阶段">准备阶段</h1><h2 id="gitlab-上的一些问题">Gitlab 上的一些问题</h2><p>如果项目不是公开的，从 docker 环境中拉取代码会有些许权限问题，可一一解决。</p><h3 id="clone-with-deploy-token">clone with deploy token</h3><p>到 Gitlab 中对应项目的 settings/repository 页面，生成 Deploy Tokens, 便可以使用 https clone 项目，不用输入用户密码，也不必使用设置相对比较麻烦的 ssh deploy key 方式。</p><p>克隆项目的命令为</p><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://&lt;name&gt;:&lt;token&gt;@gitlab.com/&lt;USER&gt;/&lt;REPO&gt;.git</code></pre><p>此处的 <code>name</code> 是 token name, 不是用户名。只对此项目生效，避免使用权限较高的用户 token。</p><h3 id="git-lfs-拉取文件出错">git-lfs 拉取文件出错</h3><p>即便使用了 deploy token 可以克隆项目文件，但其中使用 git-lfs 追踪的一些文件会失败：</p><pre><code class="hljs txt">Error downloading object: some/filename/blah: Smudge error: https://&lt;name&gt;:&lt;token&gt;@gitlab.com/some/repo.git/info/lfs/objects/batch</code></pre><p>应该是权限问题，可以越过 git-lfs 的 smudge 步骤来规避此问题。</p><pre><code class="hljs bash">GIT_LFS_SKIP_SMUDGE=1 git <span class="hljs-built_in">clone</span> &lt;SERVER-REPOSITORY&gt;</code></pre><p>参考: https://stackoverflow.com/questions/42019529/how-to-clone-pull-a-git-repository-ignoring-lfs</p><h1 id="开始">开始</h1><h2 id="dockerfile">Dockerfile</h2><pre><code class="hljs undefined"><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">8.15</span>.<span class="hljs-number">0</span>-slim<span class="hljs-comment"># install git-lfs</span><span class="hljs-keyword">RUN</span><span class="bash"> curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh |  bash</span><span class="hljs-keyword">RUN</span><span class="bash"> apt-get install -y git-lfs</span><span class="hljs-keyword">WORKDIR</span><span class="bash"> /app</span><span class="hljs-keyword">RUN</span><span class="bash"> GIT_LFS_SKIP_SMUDGE=1 git <span class="hljs-built_in">clone</span> https://&lt;name&gt;:&lt;token&gt;@gitlab.com/&lt;USER&gt;/&lt;REPO&gt;.git myrepo</span><span class="hljs-keyword">WORKDIR</span><span class="bash"> /app/myrepo</span><span class="hljs-keyword">RUN</span><span class="bash"> yarn</span></code></pre><h2 id="构建镜像">构建镜像</h2><p>在 Dockerfile 所在目录下:</p><pre><code class="hljs bash">docker build -t my-app .</code></pre><p>等待几分钟，构建完成便可使用 <code>docker inspect my-app</code> 命令看看新添加的镜像。</p><p>若 package.json 依赖较多，且可以接受在 docker host 和 vm 之间共享文件，可以去掉 <code>RUN yarn</code> 这一步，然后使用 <a href="https://docs.docker.com/storage/volumes/" target="_blank" rel="noopener">docker volume</a> 共享宿主环境中已经提前安装好的 node_modules 文件夹。</p><h2 id="启动容器">启动容器</h2><p>启动一个带 tty 的 interactive 容器并运行 bash，可以在容器里转一转，看看有什么东西:</p><pre><code class="hljs bash">docker run -v /path/to/current/node_modules:/app/myrepo/node_modules -it my-app  --name app-tty /bin/bash</code></pre><p>或是直接跑测试:</p><pre><code class="hljs bash">docker run -v /path/to/current/node_modules:/app/myrepo/node_modules -it my-app  --name <span class="hljs-built_in">test</span>-container /bin/bash -c <span class="hljs-string">'cd /app/myrepo &amp;&amp; npm run test'</span></code></pre>]]></content>
    
    <summary type="html">
    
      在 docker 环境中从 gitlab 拉取源码
    
    </summary>
    
    
      <category term="运维" scheme="http://hikerpig.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="git" scheme="http://hikerpig.github.io/tags/git/"/>
    
      <category term="前端" scheme="http://hikerpig.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="docker" scheme="http://hikerpig.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>CSS 中的两种模糊半径</title>
    <link href="http://hikerpig.github.io/2018/12/22/2018-12-22-svg-blur-and-css-text-shadow/"/>
    <id>http://hikerpig.github.io/2018/12/22/2018-12-22-svg-blur-and-css-text-shadow/</id>
    <published>2018-12-22T05:52:02.288Z</published>
    <updated>2018-12-30T04:23:40.503Z</updated>
    
    <content type="html"><![CDATA[<p>CSS 中两种实现阴影的方式</p><ol type="1"><li>text-shadow 和 box-shadow</li><li>filter: drop-shadow</li></ol><p>前者的 blur-radius 指的是阴影的最外延半径，后者的 blur-radius 指的是高斯模糊中的标准差($σ)</p><p><a href="https://drafts.csswg.org/css-backgrounds/#shadow-blur" target="_blank" rel="noopener">W3C 的 CSS 标准此处</a> 说到将 stdDeviation 设为 blur-radius 的一半可以得到近似的效果</p><blockquote><p>A non-zero blur radius indicates that the resulting shadow should be blurred, such as by a Gaussian filter. The exact algorithm is not defined; however the resulting shadow must approximate (with each pixel being within 5% of its expected value) the image that would be generated by applying to the shadow a Gaussian blur with a standard deviation equal to half the blur radius</p></blockquote><h2 id="一个实验">一个实验</h2><script async src="//jsfiddle.net/hikerpig/1wq70fgn/embed/result,html,js,css/"></script><p>相同的数值，在不同浏览器中效果不同。总体来说 drop-shadow 的结果会比 text-shadow/box-shadow 的效果更加发散和柔和。</p><h2 id="参考">参考</h2><ul><li><a href="https://dbaron.org/log/20110225-blur-radius" target="_blank" rel="noopener">What does a blur radius mean?</a></li><li><a href="https://drafts.csswg.org/css-backgrounds/#blur-radius" target="_blank" rel="noopener">Blurring Shadow Edges</a></li><li>https://github.com/w3c/fxtf-drafts/issues/102</li><li>https://bugs.chromium.org/p/chromium/issues/detail?id=677689</li><li>https://developer.mozilla.org/en-US/docs/Web/CSS/filter</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CSS 中两种实现阴影的方式&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;text-shadow 和 box-shadow&lt;/li&gt;
&lt;li&gt;filter: drop-shadow&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;前者的 blur-radius 指的是阴影的最外延半径，后者的 
      
    
    </summary>
    
    
      <category term="前端" scheme="http://hikerpig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="http://hikerpig.github.io/tags/CSS/"/>
    
      <category term="SVG" scheme="http://hikerpig.github.io/tags/SVG/"/>
    
  </entry>
  
  <entry>
    <title>浏览器中的字体信息测量</title>
    <link href="http://hikerpig.github.io/2018/11/15/2018-11-15-font-metrics-in-browser/"/>
    <id>http://hikerpig.github.io/2018/11/15/2018-11-15-font-metrics-in-browser/</id>
    <published>2018-11-14T16:00:00.000Z</published>
    <updated>2019-08-28T10:39:34.166Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题图来自 http://iamvdo.me/en/blog/css-font-metrics-line-height-and-vertical-align</p></blockquote><h1 id="为什么同样的-font-size-文字高度不一样">为什么同样的 font-size ，文字高度不一样？</h1><p>每个字体在设计的时候，都是基于一个 <a href="http://designwithfontforge.com/zh-CN/The_EM_Square.html" target="_blank" rel="noopener">EM Square</a>，这是活字印刷中字模的高度。</p><blockquote><p>在数字化字体中，em 是空间的数字化定义总量。在OpenType字体中，UPM或em大小通常是1000单位。在TrueType字体中，UPM约定是2的幂，通常是1024或2048。</p></blockquote><p>实际情况中，许多字体的内容高度其实是比 em box 要大的。</p><p>同是 <code>font-size: 30px</code> 情况下，此处的 Noto Sans JP 的字体空间就比 Kosugi Maru 要高。而且在字体框内，垂直方向上还有留白。</p><img src="//images-hikerpig.oss-cn-beijing.aliyuncs.com/image/fonts/noto-sans-jp-1.jpg" alt="undefined" title="undefined"><img src="//images-hikerpig.oss-cn-beijing.aliyuncs.com//image/fonts/kosugi-maru-1.jpg" alt="undefined" title="undefined"><p>垂直方向留白大小的计算公式，可以由字体文件中的定义得到：</p><blockquote><p>internal leading = ascent - descent - EM_size</p></blockquote><h1 id="代码片段">代码片段</h1><p>可以在<a href="https://jsfiddle.net/hikerpig/xkt3o4sd/4/" target="_blank" rel="noopener">这个 fiddle</a> 里看到结果。</p><h2 id="使用-canvas-度量文字宽度">使用 canvas 度量文字宽度</h2><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMetricsByCanvas</span>(<span class="hljs-params">canvas, str, font</span>) </span>&#123;  <span class="hljs-keyword">const</span> ctx = canvas.getContext(<span class="hljs-string">'2d'</span>)  ctx.font = font  <span class="hljs-built_in">console</span>.log(str, font, ctx.measureText(str))&#125;<span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">const</span> canvas = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'canvas'</span>)  <span class="hljs-built_in">document</span>.body.appendChild(canvas)  <span class="hljs-built_in">window</span>.canvas = canvas  getMetricsByCanvas(canvas, <span class="hljs-string">'字'</span>, <span class="hljs-string">'30px  Noto Sans JP'</span>) <span class="hljs-comment">// 字 30px  Noto Sans JP TextMetrics &#123;width: 30&#125;</span>&#125;</code></pre><p>不过此 API 是拿不到字符的高度的。就有一些比较黑的方法来估算字体的内容高度，例如使用大写字母 'M' 的宽度作为内功高度的近似。这些技巧其实都与字形设计的惯例有关，在拉丁字母中，'M' 是字形最为饱满和方正的字符，高度与宽度近似。</p><p>不过明显这个惯例对于以上两个日文字体<em>并不适用</em>。</p><p>汉字因为字形多数为饱满的方块字，用宽度去估计内容高度其实更容易，例如 '人' 和 '口' 就很好用。</p><h2 id="创建临时-dom-元素用于度量高度">创建临时 dom 元素用于度量高度</h2><p>能拿到更全的字形盒信息</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMetricsBySpan</span>(<span class="hljs-params">str, font</span>) </span>&#123;  <span class="hljs-keyword">var</span> d = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"span"</span>);  d.style.font = font;  d.textContent = str;  <span class="hljs-built_in">document</span>.body.appendChild(d);  <span class="hljs-keyword">const</span> emHeight = d.offsetHeight;  <span class="hljs-keyword">const</span> emWidth = d.offsetWidth;  <span class="hljs-built_in">console</span>.log(str, font, &#123; emWidth, emHeight &#125;)  <span class="hljs-built_in">document</span>.body.removeChild(d);&#125;getMetricsBySpan(<span class="hljs-string">'字'</span>, <span class="hljs-string">'30px  Noto Sans JP'</span>) <span class="hljs-comment">// 字 30px  Noto Sans JP &#123;emWidth: 30, emHeight: 45&#125;</span></code></pre><h1 id="稍微不那么简单但准确的方法">稍微不那么简单但准确的方法</h1><h2 id="基于-canvas-的-fontmetrics">基于 canvas 的 FontMetrics</h2><p><a href="https://github.com/soulwire/FontMetrics" target="_blank" rel="noopener">FontMetrics</a> 这个库，先清空 canvas，将文字渲染至 canvas 上，然后逐行统计 canvas 上的像素，由此可以知道文字的上下内容边界，再与 font size 换算，便可以得到字符的高度。</p><h2 id="opentype.js">opentype.js</h2><figure><img src="https://camo.githubusercontent.com/2eae816a7d7ec3155c6136a50cc7a939eee608ca/68747470733a2f2f7261772e6769746875622e636f6d2f6f70656e747970656a732f6f70656e747970652e6a732f6d61737465722f672f68656c6c6f2d776f726c642e706e67" alt><figcaption>opentype.js</figcaption></figure><p><a href="https://opentype.js.org/" target="_blank" rel="noopener">opentype.js</a> 是一个优秀的解析 OpenType 字体的 js 库。以 ArrayBuffer 传入字体的数据，解析出所有 OpenType 标准数据，完全可以基于此写出符合自己需求的排版引擎。</p><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> font = parse(buffer)<span class="hljs-keyword">const</span> g = font.charToGlyph(<span class="hljs-string">'字'</span>)<span class="hljs-keyword">const</span> bb = g.getBoundingBox()  <span class="hljs-comment">// 得出 &#123; x1, x2 , y1, y2 &#125;</span></code></pre><h1 id="参考">参考</h1><p><a href="https://stackoverflow.com/questions/1134586/how-can-you-find-the-height-of-text-on-an-html-canvas" target="_blank" rel="noopener">SO 上的一个问题</a></p><p><a href="https://www.freetype.org/freetype2/docs/glyphs/glyphs-3.html" target="_blank" rel="noopener">FreeType Glyph Metrics</a></p><p><a href="https://www.html5rocks.com/en/tutorials/canvas/texteffects/#toc-text-shadow-clipping" target="_blank" rel="noopener">Typographic effects in canvas</a></p><p><a href="http://iamvdo.me/en/blog/css-font-metrics-line-height-and-vertical-align" target="_blank" rel="noopener">Deep dive CSS: font metrics, line-height and vertical-align</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;题图来自 http://iamvdo.me/en/blog/css-font-metrics-line-height-and-vertical-align&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;为什么同样的-font-size-文字高
      
    
    </summary>
    
    
      <category term="前端" scheme="http://hikerpig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="浏览器" scheme="http://hikerpig.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="字体" scheme="http://hikerpig.github.io/tags/%E5%AD%97%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>SVG 元素的自定义  transform origin</title>
    <link href="http://hikerpig.github.io/2018/08/26/2018-08-26-beware-of-svg-transform/"/>
    <id>http://hikerpig.github.io/2018/08/26/2018-08-26-beware-of-svg-transform/</id>
    <published>2018-08-25T16:00:00.000Z</published>
    <updated>2020-03-22T13:25:23.019Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不要使用-transform-origin-属性">不要使用 transform-origin 属性</h2><p>SVG 支持 <code>transform</code>，而且写法似乎与 CSS 中相同，但是它的<a href="https://www.w3.org/TR/SVG11/coords.html" target="_blank" rel="noopener">标准</a>里并不支持 <code>transform-origin</code> 属性。虽然在部分浏览器中，给 SVG 元素指定 <code>transform-origin</code> 似乎是有效果的（写法和结果也与 CSS 一样），但是无法指望这个行为在所有浏览器里都有效。</p><h1 id="自行解释-transformorigin">自行解释 transformOrigin</h1><p>既然不能通过 attribute 来指定变换原点，我们只好通过对其他 transform 值的变动来实现想要的效果了。</p><p>首先建立一个对象系统</p><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> Display &#123;  x: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>  y: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>  width: <span class="hljs-built_in">number</span>  height: <span class="hljs-built_in">number</span>  scale: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]  transformOrigin?: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>]  parent?: Display  element: SVGElement  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) &#123;     <span class="hljs-keyword">this</span>.element = <span class="hljs-keyword">this</span>.createElement() <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>  &#125;  createElement() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'g'</span>)  &#125;  addChild(child: Display) &#123;    child.parent = <span class="hljs-keyword">this</span>    <span class="hljs-keyword">this</span>.element.appendChild(child.element)  &#125;&#125;<span class="hljs-keyword">class</span> Rect <span class="hljs-keyword">extends</span> Display &#123;  createElement() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'rect'</span>)  &#125;&#125;</code></pre><p>此时有</p><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> r1 = <span class="hljs-keyword">new</span> Rect(&#123;  name: <span class="hljs-string">"r1"</span>,  x: <span class="hljs-number">10</span>,  y: <span class="hljs-number">10</span>,  width: <span class="hljs-number">100</span>,  height: <span class="hljs-number">50</span>,&#125;)<span class="hljs-keyword">const</span> r2 = <span class="hljs-keyword">new</span> Rect(&#123;  name: <span class="hljs-string">"r2"</span>,  x: <span class="hljs-number">10</span>,  y: <span class="hljs-number">10</span>,  width: <span class="hljs-number">100</span>,  height: <span class="hljs-number">50</span>,  scale: [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>],&#125;)</code></pre><p>经过简单的属性到 dom 的操作，得到</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">rect</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"r1"</span> <span class="hljs-attr">transform</span>=<span class="hljs-string">"translate(10,10)"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"100"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"50"</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">"blue"</span> <span class="hljs-attr">opacity</span>=<span class="hljs-string">"0.8"</span> /&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">rect</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"r2"</span> <span class="hljs-attr">transform</span>=<span class="hljs-string">"translate(10,10) scale(2,2)"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"100"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"50"</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">"red"</span> <span class="hljs-attr">opacity</span>=<span class="hljs-string">"0.8"</span> /&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span></code></pre><svg style="background: #CCC">&lt;rect name="r1" transform="translate(10,10)" width="100" height="50" fill="blue" opacity="0.8" /&gt; <rect name="r2" transform="translate(10,10) scale(2,2)" width="100" height="50" fill="red" opacity="0.8"/></svg><p>r2 的变换，先平移再缩放，平移的结果就是缩放的原点。</p><p>此处将 x/y 转为 translate 而不是 <code>x</code> 和 <code>y</code> 属性，是为了以统一的方式做坐标系的转换和运算，且考虑到许多元素没有 <code>x</code> 和 <code>y</code> 属性（如 <code>circle</code> 就只有 <code>cx</code> 和 <code>cy</code> ），但所有 SVG 元素都支持 transform 。</p><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formTransform</span>(<span class="hljs-params">d: Display</span>) </span>&#123;  <span class="hljs-keyword">const</span> scales = d.scale  <span class="hljs-keyword">const</span> scaleX = scales[<span class="hljs-number">0</span>]  <span class="hljs-keyword">const</span> scaleY = scales[<span class="hljs-number">1</span>]  <span class="hljs-keyword">return</span> <span class="hljs-string">`translate(<span class="hljs-subst">$&#123;d.x&#125;</span>,<span class="hljs-subst">$&#123;d.y&#125;</span>) scale(<span class="hljs-subst">$&#123;scaleX&#125;</span>,<span class="hljs-subst">$&#123;scaleY&#125;</span>)`</span>&#125;</code></pre><h2 id="带位移补偿的缩放">带位移补偿的缩放</h2><p>计算缩放的位移补偿值，使得缩放再位移后效果就与以变换原点为中心缩放一样。</p><p>假设在缩放系数为 S 时，我们需要的 translate 为 <span class="math inline"><em>T</em><em>R</em></span>，变换完的结果：</p><p><br><span class="math display">$$x'=(x+TR_x)\times S_x\\\\y'=(y+TR_y)\times S_y$$</span><br></p><p>当以变换原点为特征点时，方程易于构建与求解。</p><p>令 <span class="math inline"><em>T</em><sub><em>x</em></sub></span> 和 <span class="math inline"><em>T</em><sub><em>y</em></sub></span> 为变换原点相对于原坐标系左上角的坐标，当 <span class="math inline"><em>x</em> = <em>T</em><sub><em>x</em></sub>, <em>y</em> = <em>T</em><sub><em>y</em></sub></span> 时，代入得到：</p><p><br><span class="math display">$$TO_{x} \ \ =\ ( TO_{x} \ +TR_{x}) \times S_{x}\\\\TO_{y} \ \ =\ ( TO_{y} \ +TR_{y}) \times S_{y}$$</span><br></p><p>所以：</p><p><br><span class="math display">$$TR_{x} \ =\frac{( 1-S_{x}) \times TO_{x}}{S_{x}}\\\\\\\\TR_{y} \ =\frac{( 1-S_{y}) \times TO_{y}}{S_{y}}$$</span><br></p><p>带缩放修正值的 transform 计算方法改为：</p><pre><code class="hljs diff">   const scales = d.scale   const scaleX = scales[0]   const scaleY = scales[1]<span class="hljs-deletion">-  return `translate($&#123;d.x&#125;,$&#123;d.y&#125;) scale($&#123;scaleX&#125;,$&#123;scaleY&#125;)`</span><span class="hljs-addition">+</span><span class="hljs-addition">+  let xToOrigin = d.width / 2</span><span class="hljs-addition">+  let yToOrigin = d.height / 2</span><span class="hljs-addition">+  if (d.transformOrigin) &#123;</span><span class="hljs-addition">+    xToOrigin = d.transformOrigin[0]</span><span class="hljs-addition">+    yToOrigin = d.transformOrigin[1]</span><span class="hljs-addition">+  &#125;</span><span class="hljs-addition">+  const revisedX = (1 - scaleX) * xToOrigin</span><span class="hljs-addition">+  const revisedY = (1 - scaleY) * yToOrigin</span><span class="hljs-addition">+</span><span class="hljs-addition">+  return `translate($&#123;d.x&#125;,$&#123;d.y&#125;) scale($&#123;scaleX&#125;,$&#123;scaleY&#125;) translate($&#123;revisedX&#125;,$&#123;revisedY&#125;)`</span> &#125;</code></pre><p>例如一个缩放为2倍，</p><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> r3 = <span class="hljs-keyword">new</span> Rect(&#123;  x: <span class="hljs-number">50</span>,  y: <span class="hljs-number">50</span>,  width: <span class="hljs-number">100</span>,  height: <span class="hljs-number">50</span>,  scale: [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>],  transformOrigin: [<span class="hljs-number">50</span>, <span class="hljs-number">25</span>],&#125;)</code></pre><p>对应于缩放的变换应该是 <code>scale(2,2) translate(-25,-12.5)</code>，再加上元素本身的位移，最后得到：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">rect</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"r3"</span> <span class="hljs-attr">transform</span>=<span class="hljs-string">"translate(50,50) scale(2,2) translate(-25,-12.5)"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"100"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"50"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span></code></pre><p>变换过程示意:</p><img src="//images-hikerpig.oss-cn-beijing.aliyuncs.com/image/trans-demo-1.svg" alt="变换过程示意" title="变换过程示意"><h2 id="参考">参考</h2><ul><li><a href="https://www.sarasoueidan.com/blog/svg-coordinate-systems/" target="_blank" rel="noopener">svg-coordinate-systems</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;不要使用-transform-origin-属性&quot;&gt;不要使用 transform-origin 属性&lt;/h2&gt;
&lt;p&gt;SVG 支持 &lt;code&gt;transform&lt;/code&gt;，而且写法似乎与 CSS 中相同，但是它的&lt;a href=&quot;https://www.w3
      
    
    </summary>
    
    
      <category term="前端" scheme="http://hikerpig.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="SVG" scheme="http://hikerpig.github.io/tags/SVG/"/>
    
  </entry>
  
</feed>
